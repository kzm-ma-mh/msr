{"instruction": "Would be nice to be able to route request using header's Accept field (or generic header's field)\n\nDetails:\n### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nN.A.\n```\n\n\n### Description\n\nIn some cases would be nice to specify header's field as routing rules.\r\n\r\nOne important example is to support API versioning based on Header's Accept field\n\n### Wanted Solution\n\nAbility to specify some header's fields in the `.get()`, `.post()` .... decorators\n\n### Wanted Code\n\n```python\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.0\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.1\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\n```\n\n\n### Alternatives\n\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.0\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.1\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\r\n\n\n### Operating System\n\nmacOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\npython -c \"import fastapi; print(fastapi.__version__)\"\n\n### Python Version\n\nPython 3.9.7\n\n### Additional Context\n\n_No ", "input": "Repository: FastAPI\nLabels: ", "output": "You still have access to request object, couldn't you use that to retrieve `content-type` and implement your logic as if there are two different endpoints?", "source": "issue", "type": "qa_best_answer", "issue_number": 118}
{"instruction": "Provide a comprehensive answer to this question: Would be nice to be able to route request using header's Accept field (or generic header's field)", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nN.A.\n```\n\n\n### Description\n\nIn some cases would be nice to specify header's field as routing rules.\r\n\r\nOne important example is to support API versioning based on Header's Accept field\n\n### Wanted Solution\n\nAbility to specify some header's fields in the `.get()`, `.post()` .... decorators\n\n### Wanted Code\n\n```python\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.0\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.1\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\n```\n\n\n### Alternatives\n\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.0\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.1\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\r\n\n\n### Operating System\n\nmacOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\npython -c \"import fastapi; print(fastapi.__version__)\"\n\n### Python Version\n\nPython 3.9.7\n\n### Additional Context\n\n_No ", "output": "You still have access to request object, couldn't you use that to retrieve `content-type` and implement your logic as if there are two different endpoints?\n\n---\n\n> You still have access to request object, couldn't you use that to retrieve `content-type` and implement your logic as if there are two different endpoints?\r\n\r\nwell, it's not so easy.\r\nUsually new version of the API means breaking changes in the request body and/or response body.\r\n\r\nHandle it in a single endpoint will end-up in a \"messy\" code.\r\n\r\nFor instance how to define different input body depending of the version?\n\n---\n\nYou could handle the version in the route? Eg /api/v1/person /api/v2/person\n\n---\n\n> You could handle the version in the route? Eg /api/v1/person /api/v2/person\r\n\r\nwell, I know that routing using URLs is available; the feature request is about adding routing using `Accept` header\n\n---\n\nCould you link to any other implementations where this feature is available? It seems quite niche to need to do this.", "source": "issue", "type": "qa_comprehensive", "issue_number": 118}
{"instruction": "Debug and solve this technical issue: Would be nice to be able to route request using header's Accept field (or generic header's field)", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nN.A.\n```\n\n\n### Description\n\nIn some cases would be nice to specify header's field as routing rules.\r\n\r\nOne important example is to support API versioning based on Header's Accept field\n\n### Wanted Solution\n\nAbility to specify some header's fields in the `.get()`, `.post()` .... decorators\n\n### Wanted Code\n\n```python\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.0\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.1\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\n```\n\n\n### Alternatives\n\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.0\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.1\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\r\n\n\n### Operating System\n\nmacOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\npython -c \"import fastapi; print(fastapi.__version__)\"\n\n### Python Version\n\nPython 3.9.7\n\n### Additional Context\n\n_No response_", "output": "You still have access to request object, couldn't you use that to retrieve `content-type` and implement your logic as if there are two different endpoints?", "source": "issue", "type": "qa_technical", "issue_number": 118}
{"instruction": "Need help tracking API usage\n\nDetails:\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom typing import Callable\r\nfrom fastapi import Request, Response, Depends\r\nfrom fastapi.routing import APIRoute\r\nfrom server.routes.users import fastapi_users\r\nfrom server.models.users import *\r\n\r\nclass session_log(APIRoute):\r\n    def get_route_handler(self) -> Callable:\r\n        original_route_handler = super().get_route_handler()\r\n\r\n        async def custom_route_handler(request: Request,\r\n        user: User = fastapi_users.get_current_user\r\n        ) -> Response:\r\n            response: Response = await original_route_handler(request)\r\n            # print(f\"route response: {response}\")\r\n            try:\r\n                print(\"User\", str(user))\r\n            except Exception as e:\r\n                print(f\"Error : {e}\")\r\n            return response\r\n\r\n        return custom_route_handler\r\n```\r\n\r\n\r\n### Description\r\n\r\nHi, I'm looking for a way to track api usage on user basis. We are using fastapi-users for user management. Can anyone please suggest a way to do this. I tried using a custom API Router but was unable to fetch user details as it done through dependency injection and I kept getting errors like Depends object ha", "input": "Repository: FastAPI\nLabels: ", "output": "Hi @ari-jain013, if your logs don't require the response object, you could create a dependency for logging ([that depends on user dependency](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/)) and inject it on all routes.\r\n\r\nFor logging, check:  https://github.com/tiangolo/fastapi/issues/778#issuecomment-563284270\r\n\r\nFor adding the dependency on all paths, check: https://fastapi.tiangolo.com/tutorial/bigger-applications/\r\n> And we can add a list of dependencies that will be added to all the path operations in the router and will be executed/solved for each request made to them.\r\n\r\n**EDIT:** Just to add an example \r\n```python\r\nfrom fastapi import FastAPI, APIRouter, Depends\r\n\r\napp = FastAPI()\r\n\r\ndef user_dep() -> int:\r\n    print(\"CALLED USER DEPENDENCY\")\r\n    user = 0\r\n    return user\r\n\r\ndef logger_dep(user: int = Depends(user_dep)):\r\n    print('CALLED LOGGER', user)\r\n\r\nlogged_router = APIRouter(dependencies=[Depends(logger_dep)])\r\n\r\n@app.get(\"/not-logged\")\r\nasync def not_logged(user: int = Depends(user_dep)):\r\n    return user\r\n\r\n@logged_router.get(\"/logged\")\r\nasync def logged(user: int = Depends(user_dep)):\r\n    return user\r\n\r\napp.include_router(logged_router)\r\n```\r\n\r\nYou can confirm, user dependency is only called once for each path (other calls use cached value): \r\n```python\r\nfrom fastapi.testclient import TestClient\r\nclient = TestClient(app)\r\nclient.get('/logged')\r\n```\r\nGives:\r\n>CALLED USER DEPENDENCY\r\n>CALLED LOGGER 0", "source": "issue", "type": "qa_best_answer", "issue_number": 117}
{"instruction": "Provide a comprehensive answer to this question: Need help tracking API usage", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom typing import Callable\r\nfrom fastapi import Request, Response, Depends\r\nfrom fastapi.routing import APIRoute\r\nfrom server.routes.users import fastapi_users\r\nfrom server.models.users import *\r\n\r\nclass session_log(APIRoute):\r\n    def get_route_handler(self) -> Callable:\r\n        original_route_handler = super().get_route_handler()\r\n\r\n        async def custom_route_handler(request: Request,\r\n        user: User = fastapi_users.get_current_user\r\n        ) -> Response:\r\n            response: Response = await original_route_handler(request)\r\n            # print(f\"route response: {response}\")\r\n            try:\r\n                print(\"User\", str(user))\r\n            except Exception as e:\r\n                print(f\"Error : {e}\")\r\n            return response\r\n\r\n        return custom_route_handler\r\n```\r\n\r\n\r\n### Description\r\n\r\nHi, I'm looking for a way to track api usage on user basis. We are using fastapi-users for user management. Can anyone please suggest a way to do this. I tried using a custom API Router but was unable to fetch user details as it done through dependency injection and I kept getting errors like Depends object ha", "output": "Hi @ari-jain013, if your logs don't require the response object, you could create a dependency for logging ([that depends on user dependency](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/)) and inject it on all routes.\r\n\r\nFor logging, check:  https://github.com/tiangolo/fastapi/issues/778#issuecomment-563284270\r\n\r\nFor adding the dependency on all paths, check: https://fastapi.tiangolo.com/tutorial/bigger-applications/\r\n> And we can add a list of dependencies that will be added to all the path operations in the router and will be executed/solved for each request made to them.\r\n\r\n**EDIT:** Just to add an example \r\n```python\r\nfrom fastapi import FastAPI, APIRouter, Depends\r\n\r\napp = FastAPI()\r\n\r\ndef user_dep() -> int:\r\n    print(\"CALLED USER DEPENDENCY\")\r\n    user = 0\r\n    return user\r\n\r\ndef logger_dep(user: int = Depends(user_dep)):\r\n    print('CALLED LOGGER', user)\r\n\r\nlogged_router = APIRouter(dependencies=[Depends(logger_dep)])\r\n\r\n@app.get(\"/not-logged\")\r\nasync def not_logged(user: int = Depends(user_dep)):\r\n    return user\r\n\r\n@logged_router.get(\"/logged\")\r\nasync def logged(user: int = Depends(user_dep)):\r\n    return user\r\n\r\napp.include_router(logged_router)\r\n```\r\n\r\nYou can confirm, user dependency is only called once for each path (other calls use cached value): \r\n```python\r\nfrom fastapi.testclient import TestClient\r\nclient = TestClient(app)\r\nclient.get('/logged')\r\n```\r\nGives:\r\n>CALLED USER DEPENDENCY\r\n>CALLED LOGGER 0\n\n---\n\nOkay, I think I can start with this but again it would be great analytics if I could also track is the response was successful or not.\r\n\r\nThank you for the quick reply\n\n---\n\nIf you need to wait for the response, I would add a middleware for logging. For user info, [starlette allows you attach states to the request object](https://www.starlette.io/requests/#other-state), which you can then access from the middleware. Not sure if there is a downside to using this with FastAPI, but the following example runs correctly. \r\n\r\n```python\r\nfrom fastapi import FastAPI, Depends, Request\r\n\r\nasync def user_dep() -> int:\r\n    user = 0\r\n    return user\r\n\r\nasync def add_request_state(request: Request, user: int = Depends(user_dep)):\r\n    request.state.user = user\r\n\r\napp = FastAPI(dependencies=[Depends(add_request_state)])\r\n\r\n@app.middleware(\"http\")\r\nasync def add_logs(request: Request, call_next):\r\n    response = await call_next(request)\r\n    print (\"some logging logic for user\", request.state.user)\r\n    print (\"response status code: \", response.status_code)\r\n    return response\r\n\r\n\r\n@app.get(\"/test\")\r\nasync def logged(user: int=Depends(user_dep)):\r\n    return user\r\n\r\n# Test behavior\r\nfrom fastapi.testclient import TestClient\r\nclient = TestClient(app)\r\nclient.get('/test')\r\n```\r\n> some logging logic for user 0\r\n> response status code:  200\n\n---\n\nHi Ahmed, I tried adding a middleware as you suggested\r\n\r\n```\r\nfrom server.routes.users import fastapi_users\r\nfrom server.models.users import *\r\nfrom fastapi import FastAPI, Depends, Request\r\nfrom fastapi_users import FastAPIUsers\r\n\r\n\r\nasync def add_request_state(request: Request, user: User = Depends(fastapi_users)):\r\n    request.state.user = user\r\n\r\n\r\napp = FastAPI(\r\n    title=\"Subtl API\",\r\n    description=\"End to End API interface for SubtlAI\",\r\n    version=\"0.1.0\",\r\n    docs_url=\"/\",\r\n    root_path=ROOT_PATH,\r\n    dependencies=[Depends(add_request_state)]\r\n    # root_path_in_servers=False\r\n)\r\n\r\n@app.middleware(\"http\")\r\nasync def add_logs(request: Request, call_next):\r\n    response = await call_next(request)\r\n    try:\r\n        print (\"some logging logic for user\", request.state.user.id)\r\n        print (\"response status code: \", response.status_code)\r\n    except Exception as e:\r\n        print (\"error: \", e)\r\n    return response\r\n```\r\n\r\nAnd got the following error\r\n\r\n> api_1      | error:  'State' object has no attribute 'user'\n\n---\n\nHi Ahmed, I tried the first option as well\r\n\r\n```\r\n\r\ndef logger_dep(user: User = Depends(fastapi_users.get_current_user)):\r\n    print('CALLED LOGGER', str(user.id))\r\n\r\nrouter = APIRouter(dependencies=[Depends(logger_dep)])\r\n\r\n```\r\nAnd got the following error\r\n\r\n> TypeError: __init__() got an unexpected keyword argument 'dependencies'", "source": "issue", "type": "qa_comprehensive", "issue_number": 117}
{"instruction": "Scale FastApi with sync endpoints\n\nDetails:\n### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport logging\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\nlogger = logging.getLogger()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    logger.info(f\"Running on {os.getpid()}\")\r\n    time.sleep(3600)\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nI've noticed lately that we have some latency problems when the servers are busy. I dived into it and found out that, if for example, I have four uvicorn workers, while one worker is very busy, the rest three are significantly less busier. That has two problems - \r\n1. We're not taking advantage of all our parallelism power\r\n2. We're suffering more from Python's GIL problems on the same worker.\r\n\r\nIn the example code, if I run it with `gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000`, the first five requests will result in the following output - \r\n```\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 642\r\n```\r\n\r\nI investigated uvicorn workers and found out they use asyncio [server](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server) interface, which ac", "input": "Repository: FastAPI\nLabels: ", "output": "Notes for the reader:\r\n\r\n- Concurrency is when 2 or more tasks are being performed at the same time, which might mean that only 1 of them is being worked on while the other ones are paused.\r\n\r\n- Parallelism is when 2 or more tasks are executing at the same time.\r\n\r\nConcurrency:\r\n\r\n- gunicorn: --workers, spawn different processes\r\n- gunicorn: --threads, per worker spawn threads, threads share memory in the same worker\r\n- Async: pseudo threads, asyncio uses one thread & one process, and allows concurrency by jumping between coroutines (async functions)\r\n\r\nParallelism:\r\n- gunicorn: --workers\r\n- gunicorn: --threads\r\n\r\nIn your example you are using the workers, and the issue that is occurring is that the work is not balanced of the workers.\r\n\r\nAccording to the documentation:\r\n\r\n    The default synchronous workers assume that your application is resource-bound in terms of CPU and network bandwidth.\r\n\r\nAnd:\r\n\r\n    Gunicorn relies on the operating system to provide all of the load balancing when handling requests.\r\n\r\nif an application is CPU bound (\"resource bound\") than workers are ideal, if an application is I/O bound threads or pseudo threads are ideal.", "source": "issue", "type": "qa_best_answer", "issue_number": 116}
{"instruction": "Provide a comprehensive answer to this question: Scale FastApi with sync endpoints", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport logging\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\nlogger = logging.getLogger()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    logger.info(f\"Running on {os.getpid()}\")\r\n    time.sleep(3600)\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nI've noticed lately that we have some latency problems when the servers are busy. I dived into it and found out that, if for example, I have four uvicorn workers, while one worker is very busy, the rest three are significantly less busier. That has two problems - \r\n1. We're not taking advantage of all our parallelism power\r\n2. We're suffering more from Python's GIL problems on the same worker.\r\n\r\nIn the example code, if I run it with `gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000`, the first five requests will result in the following output - \r\n```\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 642\r\n```\r\n\r\nI investigated uvicorn workers and found out they use asyncio [server](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server) interface, which ac", "output": "Notes for the reader:\r\n\r\n- Concurrency is when 2 or more tasks are being performed at the same time, which might mean that only 1 of them is being worked on while the other ones are paused.\r\n\r\n- Parallelism is when 2 or more tasks are executing at the same time.\r\n\r\nConcurrency:\r\n\r\n- gunicorn: --workers, spawn different processes\r\n- gunicorn: --threads, per worker spawn threads, threads share memory in the same worker\r\n- Async: pseudo threads, asyncio uses one thread & one process, and allows concurrency by jumping between coroutines (async functions)\r\n\r\nParallelism:\r\n- gunicorn: --workers\r\n- gunicorn: --threads\r\n\r\nIn your example you are using the workers, and the issue that is occurring is that the work is not balanced of the workers.\r\n\r\nAccording to the documentation:\r\n\r\n    The default synchronous workers assume that your application is resource-bound in terms of CPU and network bandwidth.\r\n\r\nAnd:\r\n\r\n    Gunicorn relies on the operating system to provide all of the load balancing when handling requests.\r\n\r\nif an application is CPU bound (\"resource bound\") than workers are ideal, if an application is I/O bound threads or pseudo threads are ideal.\n\n---\n\n+ is there any reason why async is not an option?\n\n---\n\n@extreme4all because we're using not asyncio compatible library (a snowflake driver of sqlalchemy\n\n---\n\nIn addition to what @extreme4all posted \r\n\r\n> I investigated uvicorn workers and found out they use asyncio [server](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server) interface, which accepts new connections on python's event loop\r\n\r\nThis is not always true, Unicorn as the name implies will use uvloop depending on how it is configured / installed \r\n\r\nAnother thing to consider is that FastAPI/Starlette are spawning those def endpoints onto a threadpool, depending on its implementation that could be where you are seeing a bottle neck. \r\n\r\nPythons threads/process story can be difficult to reason about. \r\n\r\nIn the short term depending on the machine you have deployed this on Gunicorn will recommend 2 workers per core. However if the cores are not busy you can probably up the worker count and that may solve your problem / give you some breathing room while you investigate further.\n\n---\n\n@jgould22 I know that def endpoints are spawned with threadpool threads, that's why I suspect we experience low latencies due to GIL limitations with many threads on the same worker (the amount of threads is not limited on each worker)", "source": "issue", "type": "qa_comprehensive", "issue_number": 116}
{"instruction": "Debug and solve this technical issue: Scale FastApi with sync endpoints", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport logging\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\nlogger = logging.getLogger()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    logger.info(f\"Running on {os.getpid()}\")\r\n    time.sleep(3600)\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nI've noticed lately that we have some latency problems when the servers are busy. I dived into it and found out that, if for example, I have four uvicorn workers, while one worker is very busy, the rest three are significantly less busier. That has two problems - \r\n1. We're not taking advantage of all our parallelism power\r\n2. We're suffering more from Python's GIL problems on the same worker.\r\n\r\nIn the example code, if I run it with `gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000`, the first five requests will result in the following output - \r\n```\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 642\r\n```\r\n\r\nI investigated uvicorn workers and found out they use asyncio [server](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server) interface, which accepts new connections on python's event loop, which means that as long we're using not-async endpoints (which run on AnyIo threads), there is no limit on the number of new connections a worker gets, which again takes us back to the GIL problem.\r\n\r\nTo sum it all up, I'm a little confused about what is my best option for using FastApi with not-async endpoints and get better performance. Should I use more workers? Should I use more container instances?\r\nMaybe we should implement a new worker which able to control better multithreading on such cases ? I have some implementation ideas for this purpose, but Iâ€™d like to have your advice here.\n\n### Operating System\n\nLinux\n\n### Operating System Details\n\n-\n\n### FastAPI Version\n\n0.88.0\n\n### Python Version\n\n3.9.4\n\n### Additional Context\n\n-", "output": "Notes for the reader:\r\n\r\n- Concurrency is when 2 or more tasks are being performed at the same time, which might mean that only 1 of them is being worked on while the other ones are paused.\r\n\r\n- Parallelism is when 2 or more tasks are executing at the same time.\r\n\r\nConcurrency:\r\n\r\n- gunicorn: --workers, spawn different processes\r\n- gunicorn: --threads, per worker spawn threads, threads share memory in the same worker\r\n- Async: pseudo threads, asyncio uses one thread & one process, and allows concurrency by jumping between coroutines (async functions)\r\n\r\nParallelism:\r\n- gunicorn: --workers\r\n- gunicorn: --threads\r\n\r\nIn your example you are using the workers, and the issue that is occurring is that the work is not balanced of the workers.\r\n\r\nAccording to the documentation:\r\n\r\n    The default synchronous workers assume that your application is resource-bound in terms of CPU and network bandwidth.\r\n\r\nAnd:\r\n\r\n    Gunicorn relies on the operating system to provide all of the load balancing when handling requests.\r\n\r\nif an application is CPU bound (\"resource bound\") than workers are ideal, if an application is I/O bound threads or pseudo threads are ideal.", "source": "issue", "type": "qa_technical", "issue_number": 116}
{"instruction": "[Feature Request - Community Feedback needed] Additional Responses\n\nDetails:\nHow do we add additional responses (e.g. 401, 403, 500, etc..) to the documentation other than the default 200 response and the 422 validation error response?", "input": "Repository: FastAPI\nLabels: ", "output": "Did you check this link https://fastapi.tiangolo.com/tutorial/response-status-code/ ?", "source": "issue", "type": "qa_best_answer", "issue_number": 115}
{"instruction": "Provide a comprehensive answer to this question: [Feature Request - Community Feedback needed] Additional Responses", "input": "How do we add additional responses (e.g. 401, 403, 500, etc..) to the documentation other than the default 200 response and the 422 validation error response?", "output": "Did you check this link https://fastapi.tiangolo.com/tutorial/response-status-code/ ?\n\n---\n\n@kurtrottmann I did, but that's only for changing the status code of the main (only) response. I'm wondering if it's possible to add documentations of the error responses.\n\n---\n\nThanks @kurtrottmann for helping here! That's highly appreciated :tada: :taco: \r\n\r\n---\r\n\r\n@pulitz There's still no defined way to declare them.\r\n\r\nI knew this would happen, but I didn't want to define the API/functionality for that yet, as I wanted to hear feedback for you guys (and other developers), before implementing it.\r\n\r\n---\r\n\r\n### Here's the problem/situation:\r\n\r\nWhen defining a single response model and status code, no matter what is actually returned by the path operation function, it will be converted to that model (and filtered by it) and that status code will be returned.\r\n\r\nIf we have more than one possible status code, the path operation function has to return a Starlette `Response` (instead of a plain `dict` or Pydantic model), with the final content already converted to the correct JSON data (maybe filtered by the correct Pydantic model) and the correct status code. That has to be done inside the path operation *function*, independently of the declared responses and status codes in the path operation *decorator* (the ones that appear in the OpenAPI generated schema).\r\n\r\nThis is because there is no way for FastAPI (actually for Python) to know what are all the possible values/data returned by the path operation function.\r\n\r\n### What has to be done:\r\n\r\nSo, this would mean, that the declared model and status code has to be declared twice (code repetition :disappointed: , that in this case, we can't avoid). Once in the path operation decorator (to declare it for the generated OpenAPI schema) and once inside the path operation function, to actually return it.\r\n\r\n### The question, requested feedback:\r\n\r\nIn summary, declaring additional response models/schemas and status codes will be \"way more complex\" than declaring a single one. Actually, it won't be that difficult, but will not be super-intuitive and simple, which is the ideal for FastAPI (and is what all the rest tries to achieve).\r\n\r\nI can think of two options:\r\n\r\nAn additional parameter for the path operation decorator, something like `extra_responses` (is that parameter name intuitive enough? any alternatives?).\r\n\r\nThis parameter could receive:\r\n\r\n* Option A: A `dict` mapping status codes (numbers) to Pydantic models. The schema of those Pydantic models would be the optional response schemas for each status code.\r\n    * This option would probably be the more simple and Pythonic, as Pydantic is just plain Python types. But it requires creating and using those additional classes.\r\n    * By using additional Pydantic models, it would be possible to have them in the top level OpenAPI definitions and reference them, as is currently done for the `response_model` parameter. And they could be used by other OpenAPI based client code generators. For example, creating TypeScript interfaces automatically (if you don't know what that is, don't worry about the term).\r\n* Option B: A `dict` mapping status codes to sub-`dict`s with the actual JSON Schema (OpenAPI schema) of the response.\r\n    * This option would require writing the actual output JSON Schema directly, or calling the schema method from Pydantic models by hand.\r\n    * It would allow declaring additional responses inside of the same path operation decorator, without needing to declare anything else outside of the path operation. And would give the maximum flexibility, as the contents would be almost \"free-form\". Although, there's no gain in the \"free-form\" that I can think of, as Pydantic supports all (or almost all) the possible declarations with JSON Schema.\r\n\r\n* Option C: A `dict` mapping status codes to sub-`dict`s containing keys for the `description` (a `str`), `headers` (a `dict`), `content` (here's where the schemas live), the `content` could have the output schema as a `dict` directly, or we could add support for the `example`, `examples`, `schema` and `encoding`.\r\n* Option D: The same as Option C, but instead of having each schema as a `dict`, receive Pydantic models.\r\n    * Options C and D are the most complex, also the most complete (with respect to OpenAPI).\r\n\r\n### References\r\n\r\nOpenAPI operation object, that contains `responses`: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#operationObject\r\n\r\nOpenAPI responses object that contains each `response`: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#responsesObject\r\n\r\nOpenAPI response object that contains each field, and `content`, referencing a \"Media Type Object\" (that contains the actual schema): https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#responseObject\r\n\r\nOpenAPI Media Type object (that contains the actual `schema`): https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#mediaTypeObject\r\n\r\n---\r\n\r\nI know this gets hairy quickly, so I'll leave this issue open as a \"feature request\" to collect more feedback.\r\n\r\nI know each of those options above is doable, but what I'm concerned the most is the **style of the developer-facing API**, I want it to be as **friendly and intuitive** as the rest of FastAPI, or at least as close as possible.\r\n\r\nActually, all the rest of FastAPI was designed similarly, first checking all the possible developer-facing functionality, in several editors, to ensure the best development experience for FastAPI users (developers), and then doing all the implementation to match that design.\r\n\r\nWhat do you guys think?\n\n---\n\nCurrently, I am using FastAPI to create an interface to call AWS services through boto3. And AWS raise ClientErrors which most (if not all) have the same structure and documented.\r\nFor me I think I prefer having to add the decorator while passing a list of models or pre-defined dicts of the possible errors/responses.\n\n---\n\nWould you have simple examples for A,B,C ? I'm not sure I see concretly what that means if used in a simple example.\r\n\r\nSo far for instance I got a post route that returns a 409 if user added is a duplicate, I wrote it this way and didn't feel the need for another black magic, but maybe that's because I was only concerned with the status_code\r\n\r\n```\r\n@users_router.post(\"/\", status_code=HTTP_201_CREATED)\r\nasync def useradd(request: Request, userin: UserInRegister):\r\n    query = users.insert().values(**userin.dict())\r\n    try:\r\n        await request.database.execute(query)\r\n    except UniqueViolationError as e:\r\n        return Response(content=None, status_code=409)\r\n    return userin\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 115}
{"instruction": "How to pass list in query parameters?\n\nDetails:\n**Description**\r\n\r\nI need to support several query parameters with same name in GET route. Typical request looks like this:\r\nhttp://localhost/item?num=1&num=2\r\n\r\nI configured a route\r\n````\r\n@app.get(\"/item\", content_type=UJSONResponse)\r\nasync def get_part(num: list):\r\n    found = False\r\n    for i in num:\r\n         if i in some_data:\r\n             found = True\r\n             break\r\n    return {\"found\": found}\r\n````\r\nThe idea is, that I can pass several numbers to check, if they exist in some_data. In my opinion, it is not a good idea to get numbers from body here, because it is a simple GET request, but in current version application expects argument \"num\" in body, so on my request (written above) I receive a response\r\n\r\n`{\"detail\":[{\"loc\":[\"body\",\"num\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}`\r\n\r\nAs I know, it is not restricted to pass several query parameters with the same name in an HTTP request by any specifications, so I would like to ask, is it possible to configure a route in FastAPI, which will be able to parse several query parameters with the same name?", "input": "Repository: FastAPI\nLabels: ", "output": "It is supported (and tested), but not documented yet, but you can just use standard Python types (a `List`) :)\r\n\r\n```Python\r\nfrom typing import List\r\n\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n@app.get(\"/items/\")\r\ndef read_items(q: List[int] = Query(None)):\r\n    return {\"q\": q}\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 114}
{"instruction": "Provide a comprehensive answer to this question: How to pass list in query parameters?", "input": "**Description**\r\n\r\nI need to support several query parameters with same name in GET route. Typical request looks like this:\r\nhttp://localhost/item?num=1&num=2\r\n\r\nI configured a route\r\n````\r\n@app.get(\"/item\", content_type=UJSONResponse)\r\nasync def get_part(num: list):\r\n    found = False\r\n    for i in num:\r\n         if i in some_data:\r\n             found = True\r\n             break\r\n    return {\"found\": found}\r\n````\r\nThe idea is, that I can pass several numbers to check, if they exist in some_data. In my opinion, it is not a good idea to get numbers from body here, because it is a simple GET request, but in current version application expects argument \"num\" in body, so on my request (written above) I receive a response\r\n\r\n`{\"detail\":[{\"loc\":[\"body\",\"num\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}`\r\n\r\nAs I know, it is not restricted to pass several query parameters with the same name in an HTTP request by any specifications, so I would like to ask, is it possible to configure a route in FastAPI, which will be able to parse several query parameters with the same name?", "output": "It is supported (and tested), but not documented yet, but you can just use standard Python types (a `List`) :)\r\n\r\n```Python\r\nfrom typing import List\r\n\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n@app.get(\"/items/\")\r\ndef read_items(q: List[int] = Query(None)):\r\n    return {\"q\": q}\r\n```\n\n---\n\nIt is now properly documented :memo: :tada: \r\n\r\nFor query parameters: https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#query-parameter-list-multiple-values\r\n\r\nAnd for duplicate headers: https://fastapi.tiangolo.com/tutorial/header-params/#duplicate-headers\n\n---\n\nI guess this is solved now, so I'll close the issue. But feel free to add more comments or create new issues.\n\n---\n\nIs it possible to do:\r\n`http://localhost/item?num=1,2,3,4,5,6`\r\n\r\ninstead of:\r\n`http://localhost/item?num=1&num=2&num=3&num=4&num=5&num=6`?\n\n---\n\n@neilpanchal You could do this by adding a custom dependency that expected a string-value query parameter, then splits the string on `,` and converts the result to ints. But obviously that's a little less ergonomic.\r\n\r\nI think the main reason why this isn't easier is that FastAPI is basically just deferring to starlette for query parameter string extraction, then pydantic for parsing.\r\n\r\nSo starlette gives query parameter `num=\"1,2,3,4,5,6\"`, and pydantic doesn't know how to parse `\"1,2,3,4,5,6\"` into a list of ints.\r\n\r\nStarlette *does* have built-in support for repeated values of the same query parameter, which is why the more verbose approach does work out of the box.", "source": "issue", "type": "qa_comprehensive", "issue_number": 114}
{"instruction": "Only show documentation while logged in\n\nDetails:\n**Description**\r\n\r\nIs it possible to only show the documentation based on being logged in? Many times I create an API which should only expose it's documentation when somebody is logged in.", "input": "Repository: FastAPI\nLabels: ", "output": "Sorry for the delay.\r\n\r\nIn short, **yes** *.\r\n\r\n*Now goes the \"it depends\"...\r\n\r\n## Long version\r\n\r\nHow are you logging in users?\r\n\r\n### Simplest, less secure\r\n\r\nThe simplest, less secure option I can imagine, is embeding your Swagger UI in your frontend, and show it selectively on if the user is authenticated or not.\r\n\r\n### FastAPI security\r\n\r\nFastAPI doesn't enforce a specific way to log in users, but you can use several approaches, e.g.:\r\n\r\n* JWT tokens in HTTP headers.\r\n* Session Cookies.\r\n* HTTP Basic Auth.\r\n* ...others.\r\n\r\n### OAuth2 JWT tokens\r\n\r\n**spoiler**: I think this wouldn't work for you.\r\n\r\nThe suggestion in the docs, using OAuth2 with the \"password flow\" (JWT tokens in HTTP headers), involves the following steps:\r\n\r\n* The client sends a `POST` with form data, including `username` and `password`.\r\n* The server returns a JSON body with an `access_token`.\r\n* For the next requests, to authenticated endpoints, the client sends that access token in a header.\r\n* The server checks that access token in the header, validates it, etc, and returns the content.\r\n\r\nUsing that, it is common to hold that access token in memory in the client (in a JS variable) or in `localStorage`. And then, when the client (your JS code in the browser) requests a protected endpoint, it sends the access token in the HTTP header. But you have to code it explicitly.\r\n\r\nNow, when you open the browser in the docs (Swagger UI), it doesn't automatically send any token from anywhere, because it would have to be added explicitly in code, taken from wherever you put it.\r\n\r\n### Cookies\r\n\r\nAnother option would be to use Cookies. Because the browser sends those Cookies automatically. But in that case, the API and the Swagger UI must live in the same host (the same combination of `http` or `https` and domain), for the browser to actually send the Cookies.\r\n\r\nBut still, all that doesn't change the actual `/openapi.json` endpoint to be available. So, you might want to use Cookies to override it too.\r\n\r\n### Basic Auth\r\n\r\nAnother simpler option would be to protect those endpoints with HTTP Basic Auth. So, the browser would show the default authentication pop-up and would remember the credentials used there for some time. But that would be more or less disconnected from your current authentication system.", "source": "issue", "type": "qa_best_answer", "issue_number": 113}
{"instruction": "Provide a comprehensive answer to this question: Only show documentation while logged in", "input": "**Description**\r\n\r\nIs it possible to only show the documentation based on being logged in? Many times I create an API which should only expose it's documentation when somebody is logged in.", "output": "Sorry for the delay.\r\n\r\nIn short, **yes** *.\r\n\r\n*Now goes the \"it depends\"...\r\n\r\n## Long version\r\n\r\nHow are you logging in users?\r\n\r\n### Simplest, less secure\r\n\r\nThe simplest, less secure option I can imagine, is embeding your Swagger UI in your frontend, and show it selectively on if the user is authenticated or not.\r\n\r\n### FastAPI security\r\n\r\nFastAPI doesn't enforce a specific way to log in users, but you can use several approaches, e.g.:\r\n\r\n* JWT tokens in HTTP headers.\r\n* Session Cookies.\r\n* HTTP Basic Auth.\r\n* ...others.\r\n\r\n### OAuth2 JWT tokens\r\n\r\n**spoiler**: I think this wouldn't work for you.\r\n\r\nThe suggestion in the docs, using OAuth2 with the \"password flow\" (JWT tokens in HTTP headers), involves the following steps:\r\n\r\n* The client sends a `POST` with form data, including `username` and `password`.\r\n* The server returns a JSON body with an `access_token`.\r\n* For the next requests, to authenticated endpoints, the client sends that access token in a header.\r\n* The server checks that access token in the header, validates it, etc, and returns the content.\r\n\r\nUsing that, it is common to hold that access token in memory in the client (in a JS variable) or in `localStorage`. And then, when the client (your JS code in the browser) requests a protected endpoint, it sends the access token in the HTTP header. But you have to code it explicitly.\r\n\r\nNow, when you open the browser in the docs (Swagger UI), it doesn't automatically send any token from anywhere, because it would have to be added explicitly in code, taken from wherever you put it.\r\n\r\n### Cookies\r\n\r\nAnother option would be to use Cookies. Because the browser sends those Cookies automatically. But in that case, the API and the Swagger UI must live in the same host (the same combination of `http` or `https` and domain), for the browser to actually send the Cookies.\r\n\r\nBut still, all that doesn't change the actual `/openapi.json` endpoint to be available. So, you might want to use Cookies to override it too.\r\n\r\n### Basic Auth\r\n\r\nAnother simpler option would be to protect those endpoints with HTTP Basic Auth. So, the browser would show the default authentication pop-up and would remember the credentials used there for some time. But that would be more or less disconnected from your current authentication system.\n\n---\n\nThanks for your elaborate answer! I will check-out the OAuth2 JWT token, Cookies and Basic Auth options and see what the best route is. Is there an easy / quick way to add a Depends / Security option to the documentation endpoints?\n\n---\n\nYes, it is relatively easy to add dependencies to those endpoints. You can create your `FastAPI` removing the automatic docs endpoints: https://fastapi.tiangolo.com/tutorial/application-configuration/#docs-urls\r\n\r\nAnd then you can create them by hand, using the utils from `fastapi.openapi.docs`, there's a `get_swagger_ui_html` and `get_redoc_html` functions. There you can create the endpoints/path operations as normally.\r\n\r\nBut the next problem (probably the main one) is how to authenticate the user and where, outside the docs endpoints.\n\n---\n\nThanks for the input! I just managed to create a custom documentation endpoint, including a Dependency which checks for a valid user (based on your explanation of OAuth2 JWT tokens). What I have done to achieve this is:\r\n\r\n1. Create a /login endpoint which returns a token based on a valid username / password (based on your provided examples)\r\n2. Create a /openapi.json endpoint which is protected with a security dependency, which checks the token (also based on your example)\r\n3. Create a /documentation endpoint which is protected with a security dependency, which checks the token (also based on your example)\r\n\r\nWhen not logged in, I am unable to see the documentation, but when I am logged in and use the token with my requests, I am able to see the documentation (for example with Postman or a Firefox plugin).\r\n\r\nAs a next step I will try the cookie approach and see how this works. Thanks for your time / input and great framework, really love working with it!\n\n---\n\nGreat! Thanks for sharing your discoveries here.", "source": "issue", "type": "qa_comprehensive", "issue_number": 113}
{"instruction": "How to work with form data?\n\nDetails:\nHello everyone!\r\nI need to process form data but I can't do that with fastapi. To try understand how can I do it I used Postman to send data in different ways:\r\nfrom form-data tab\r\nfrom x-www-form-urlencoded\r\nwith header \"Content-Type: application/x-www-form-urlencoded\"\r\nwith header \"Content-Type: application/json\"\r\nwithout headers\r\n\r\nIn any case I have the same result: {\"detail\": \"There was an error parsing the body\"}.\r\n\r\n![postman](https://user-images.githubusercontent.com/22984590/57228831-54404d80-7047-11e9-8fa6-4502b8a29dca.png)\r\n\r\n```\r\nfrom fastapi import FastAPI, HTTPException, Form\r\n\r\n@app.post(\"/subscription_email\")\r\ndef subscription_email(*, customers: int = Form(...)):\r\n    return customers\r\n```\r\nCode based on example from docs.\r\n\r\nPlease, help me to fix it and understand how to work woth form data from POST requests.", "input": "Repository: FastAPI\nLabels: ", "output": "Here is what I'm using for file upload (using forms):\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/request-forms-and-files/\r\n\r\n    @router.post(\"/nanopubs/import/file\", tags=[\"Nanopubs\"])\r\n    def import_nanopubs(\r\n        file: UploadFile = File(...),\r\n        overwrite: bool = Query(False, description=\"Overwrite if exists when true\"),\r\n        validation: bool = Query(True, description=\"Validate nanopub when true\"),\r\n        email: str = Query(\"\", description=\"Will send email with processing results\"),\r\n    ):\r\n\r\n        if file:\r\n            contents = file.file.read().decode(\"utf-8\")\r\n            try:\r\n                nanopubs = json.loads(contents)\r\n            except Exception as e:\r\n                log.error(\"Error reading nanopub json content\", error=str(e))", "source": "issue", "type": "qa_best_answer", "issue_number": 112}
{"instruction": "Provide a comprehensive answer to this question: How to work with form data?", "input": "Hello everyone!\r\nI need to process form data but I can't do that with fastapi. To try understand how can I do it I used Postman to send data in different ways:\r\nfrom form-data tab\r\nfrom x-www-form-urlencoded\r\nwith header \"Content-Type: application/x-www-form-urlencoded\"\r\nwith header \"Content-Type: application/json\"\r\nwithout headers\r\n\r\nIn any case I have the same result: {\"detail\": \"There was an error parsing the body\"}.\r\n\r\n![postman](https://user-images.githubusercontent.com/22984590/57228831-54404d80-7047-11e9-8fa6-4502b8a29dca.png)\r\n\r\n```\r\nfrom fastapi import FastAPI, HTTPException, Form\r\n\r\n@app.post(\"/subscription_email\")\r\ndef subscription_email(*, customers: int = Form(...)):\r\n    return customers\r\n```\r\nCode based on example from docs.\r\n\r\nPlease, help me to fix it and understand how to work woth form data from POST requests.", "output": "Here is what I'm using for file upload (using forms):\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/request-forms-and-files/\r\n\r\n    @router.post(\"/nanopubs/import/file\", tags=[\"Nanopubs\"])\r\n    def import_nanopubs(\r\n        file: UploadFile = File(...),\r\n        overwrite: bool = Query(False, description=\"Overwrite if exists when true\"),\r\n        validation: bool = Query(True, description=\"Validate nanopub when true\"),\r\n        email: str = Query(\"\", description=\"Will send email with processing results\"),\r\n    ):\r\n\r\n        if file:\r\n            contents = file.file.read().decode(\"utf-8\")\r\n            try:\r\n                nanopubs = json.loads(contents)\r\n            except Exception as e:\r\n                log.error(\"Error reading nanopub json content\", error=str(e))\n\n---\n\n@wshayes thank you for advice. It works fine with query parameters but still doesn't work with data from form fields.\n\n---\n\nyour example works fine out of the box with the swagger generated at /docs\r\n\r\nedit: email doesnt support markdown, see screens below\n\n---\n\n![Imgur](https://i.imgur.com/oncN00s.png)\r\n\r\nsame with postman\r\n\r\n![Imgur](https://i.imgur.com/cNDCG6G.png)\n\n---\n\n@euri10 thank you that you try to help me. I tried to make request trough swagger and it doesen't work too. Strange situation. GET-requests work fine, POST-requests with JSON work fine (with pydantic BaseModal). But, it doesen't work for me with form data.", "source": "issue", "type": "qa_comprehensive", "issue_number": 112}
{"instruction": "Choices Dropdown Menu in API Documentation\n\nDetails:\n**Feature Request:**\r\n\r\nIt would be nice to document in the API, which what choices are available to the user as a drop-down menu in the UI. It helps prevent such documentation in the description\\help of the parameter.  \r\n\r\n**Context**\r\n`flask_restplus` library is able to show choices in its Swagger UI, and is able to handle if incorrect choice is provided as an input by the user.  \r\n![Selection_005](https://user-images.githubusercontent.com/43503284/58156014-6dffa880-7c75-11e9-9d35-3c32150a3596.png)\r\n\r\n**Preferred Solution:**\r\nWould like to see `choices` parameter added to possibly `fastapi.Query` class and possibly other classes that handle input from user. \r\nWould be awesome if it was something like this\r\n```\r\n@api.get('/get_countries')\r\ndef get_something(\r\n    choice: str = Query('eu', choices=('eu,'us','cn,'ru'), description='foo bar')\r\n):\r\n    do_something(choice)\r\n``` \r\n\r\nWould be nice to see this feature in `FastAPI`, as I/We would prefer to use `FastAPI` over `flask_restplus`.", "input": "Repository: FastAPI\nLabels: ", "output": "after some digging it seems it works out of the box:\r\n\r\n![Imgur](https://i.imgur.com/tRCaRXM.png)\r\n\r\n```\r\nimport uvicorn\r\n\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get('/get_countries')\r\nasync def get_countries(_q: str = Query(\"eu\", enum=[\"eu\", \"us\", \"cn\", \"ru\"])):\r\n    return {\"selected\": _q}\r\n\r\n\r\nif __name__ == '__main__':\r\n    uvicorn.run(\"test_swagger_dropdown:app\", reload=True)\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 111}
{"instruction": "Provide a comprehensive answer to this question: Choices Dropdown Menu in API Documentation", "input": "**Feature Request:**\r\n\r\nIt would be nice to document in the API, which what choices are available to the user as a drop-down menu in the UI. It helps prevent such documentation in the description\\help of the parameter.  \r\n\r\n**Context**\r\n`flask_restplus` library is able to show choices in its Swagger UI, and is able to handle if incorrect choice is provided as an input by the user.  \r\n![Selection_005](https://user-images.githubusercontent.com/43503284/58156014-6dffa880-7c75-11e9-9d35-3c32150a3596.png)\r\n\r\n**Preferred Solution:**\r\nWould like to see `choices` parameter added to possibly `fastapi.Query` class and possibly other classes that handle input from user. \r\nWould be awesome if it was something like this\r\n```\r\n@api.get('/get_countries')\r\ndef get_something(\r\n    choice: str = Query('eu', choices=('eu,'us','cn,'ru'), description='foo bar')\r\n):\r\n    do_something(choice)\r\n``` \r\n\r\nWould be nice to see this feature in `FastAPI`, as I/We would prefer to use `FastAPI` over `flask_restplus`.", "output": "after some digging it seems it works out of the box:\r\n\r\n![Imgur](https://i.imgur.com/tRCaRXM.png)\r\n\r\n```\r\nimport uvicorn\r\n\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get('/get_countries')\r\nasync def get_countries(_q: str = Query(\"eu\", enum=[\"eu\", \"us\", \"cn\", \"ru\"])):\r\n    return {\"selected\": _q}\r\n\r\n\r\nif __name__ == '__main__':\r\n    uvicorn.run(\"test_swagger_dropdown:app\", reload=True)\r\n```\n\n---\n\nThanks @euri10 for your help!\r\n\r\nLater I'll add full `Enum` support for query values too, that way, apart from showing up in Swagger UI,  Pydantic validates the values given.\n\n---\n\nThanks a lot! This will work! Can't wait for full support!\n\n---\n\nHey @alikhtag, just to let you know, this is available now in the latest versions (actually for some time now).\r\n\r\nHere are docs for how to use enums in paths, but the same applies to queries: https://fastapi.tiangolo.com/tutorial/path-params/#predefined-values\r\n\r\nHere's your same example:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom enum import Enum\r\n\r\n\r\nclass Country(str, Enum):\r\n    eu = \"eu\"\r\n    us = \"us\"\r\n    cn = \"cn\"\r\n    ru = \"ru\"\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef get_something(country: Country = Country.eu):\r\n    return {\"country\": country.value}\r\n```\n\n---\n\n@tiangolo \r\nThanks a lot!", "source": "issue", "type": "qa_comprehensive", "issue_number": 111}
{"instruction": "Add support for Pydantic's dataclasses\n\nDetails:\n**Describe the question**\r\nI am using a  pydantic.dataclasses.dataclass as a response_model of my fast api route.\r\n\r\n\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic.dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass Foo:\r\n    bar: int\r\n\r\napp = FastAPI()\r\n\r\n@app.get('/foo', response_model=Foo)\r\ndef get_bar() -> Foo:\r\n    return Foo(bar=1)\r\n```\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Create a file **app.py** with the above code.\r\n2. Start the app: `uvicorn app:app`\r\n3. Open the browser and go to **localhost:8000/foo**\r\n4. See error: \r\n```\r\npydantic.error_wrappers.ValidationError: 1 validation error\r\nresponse\r\n  __init__() got an unexpected keyword argument '__initialised__' (type=type_error)\r\n```\r\n\r\n**Expected behavior**\r\nNo validation error and serialized json does not contain any keys `__initialised__`.\r\n\r\n\r\n**Environment:**\r\n - OS: Linux\r\n - FastAPI Version 0.25.0\r\n- Python version 3.7.3", "input": "Repository: FastAPI\nLabels: ", "output": "**Possible solution**\r\n\r\nAdd the following to jsonable_encoder in fastapi.encoders:\r\n\r\n```\r\nfrom dataclasses import is_dataclass, asdict\r\n\r\ndef jsonable_encoder(\r\n    obj: Any,\r\n    include: Set[str] = None,\r\n    exclude: Set[str] = set(),\r\n    by_alias: bool = True,\r\n    skip_defaults: bool = False,\r\n    include_none: bool = True,\r\n    custom_encoder: dict = {},\r\n    sqlalchemy_safe: bool = True,\r\n) -> Any:\r\n...\r\n    if is_dataclass(obj):\r\n        return asdict(obj)\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 110}
{"instruction": "Provide a comprehensive answer to this question: Add support for Pydantic's dataclasses", "input": "**Describe the question**\r\nI am using a  pydantic.dataclasses.dataclass as a response_model of my fast api route.\r\n\r\n\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic.dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass Foo:\r\n    bar: int\r\n\r\napp = FastAPI()\r\n\r\n@app.get('/foo', response_model=Foo)\r\ndef get_bar() -> Foo:\r\n    return Foo(bar=1)\r\n```\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Create a file **app.py** with the above code.\r\n2. Start the app: `uvicorn app:app`\r\n3. Open the browser and go to **localhost:8000/foo**\r\n4. See error: \r\n```\r\npydantic.error_wrappers.ValidationError: 1 validation error\r\nresponse\r\n  __init__() got an unexpected keyword argument '__initialised__' (type=type_error)\r\n```\r\n\r\n**Expected behavior**\r\nNo validation error and serialized json does not contain any keys `__initialised__`.\r\n\r\n\r\n**Environment:**\r\n - OS: Linux\r\n - FastAPI Version 0.25.0\r\n- Python version 3.7.3", "output": "**Possible solution**\r\n\r\nAdd the following to jsonable_encoder in fastapi.encoders:\r\n\r\n```\r\nfrom dataclasses import is_dataclass, asdict\r\n\r\ndef jsonable_encoder(\r\n    obj: Any,\r\n    include: Set[str] = None,\r\n    exclude: Set[str] = set(),\r\n    by_alias: bool = True,\r\n    skip_defaults: bool = False,\r\n    include_none: bool = True,\r\n    custom_encoder: dict = {},\r\n    sqlalchemy_safe: bool = True,\r\n) -> Any:\r\n...\r\n    if is_dataclass(obj):\r\n        return asdict(obj)\r\n```\n\n---\n\nThank you. Pydantic's dataclasses are not supported yet. They probably will be at some point.\n\n---\n\nAny updates on this?\n\n---\n\nUsing pydantic BaseModel vs dataclass causes tremendous slowdown as well in my codebase.\n\n---\n\n@manojlds which one is slower?", "source": "issue", "type": "qa_comprehensive", "issue_number": 110}
{"instruction": "Issue when debugging inside docker\n\nDetails:\n**Describe the bug**\r\nWhen I run pdb in docker I run into issues if I have reload enabled.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom starlette.requests import Request\r\n\r\nimport sys\r\nsys.path.insert(0, '.')\r\nfrom app.api.api import api_router\r\nfrom app.core import config\r\nfrom app.db.session import Session\r\n\r\n\r\napp = FastAPI(title='App')\r\napp.include_router(api_router, prefix=config.API_V1_STR)\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def db_session_middleware(request: Request, call_next):\r\n   \r\n    # This set_trace crashes only if I started uvicorn with `debug=True`\r\n    import pdb; pdb.set_trace()\r\n   \r\n    request.state.db = Session()\r\n    response = await call_next(request)\r\n    request.state.db.close()\r\n    return response\r\n\r\n\r\n# For debugging\r\nif __name__ == \"__main__\":\r\n    import uvicorn\r\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=80, reload=True, debug=True)\r\n```\r\n\r\n**Expected behavior**\r\nI should be able to use pdb, but instead get an `bdb.BdbQuit` exception. This doesn't happen if I run outside docker or if I run inside docker but remove `reload=True` argument.\r\n\r\n**Environment:**\r\n`FROM tiangolo/uvicorn-gunicorn:python3.7`", "input": "Repository: FastAPI\nLabels: ", "output": "I have no idea what could be causing this, but my guess is that it's more likely to be a uvicorn issue than a fastapi issue. I'd recommend trying with a non-fastapi (and ideally non-starlette-based) framework -- if you have the same problem hitting breakpoints, it would indicate the problem is in uvicorn.\r\n\r\n@euri10 any other suggestions for debugging in docker? (If I recall you have some experience with this.)", "source": "issue", "type": "qa_best_answer", "issue_number": 109}
{"instruction": "Provide a comprehensive answer to this question: Issue when debugging inside docker", "input": "**Describe the bug**\r\nWhen I run pdb in docker I run into issues if I have reload enabled.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom starlette.requests import Request\r\n\r\nimport sys\r\nsys.path.insert(0, '.')\r\nfrom app.api.api import api_router\r\nfrom app.core import config\r\nfrom app.db.session import Session\r\n\r\n\r\napp = FastAPI(title='App')\r\napp.include_router(api_router, prefix=config.API_V1_STR)\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def db_session_middleware(request: Request, call_next):\r\n   \r\n    # This set_trace crashes only if I started uvicorn with `debug=True`\r\n    import pdb; pdb.set_trace()\r\n   \r\n    request.state.db = Session()\r\n    response = await call_next(request)\r\n    request.state.db.close()\r\n    return response\r\n\r\n\r\n# For debugging\r\nif __name__ == \"__main__\":\r\n    import uvicorn\r\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=80, reload=True, debug=True)\r\n```\r\n\r\n**Expected behavior**\r\nI should be able to use pdb, but instead get an `bdb.BdbQuit` exception. This doesn't happen if I run outside docker or if I run inside docker but remove `reload=True` argument.\r\n\r\n**Environment:**\r\n`FROM tiangolo/uvicorn-gunicorn:python3.7`", "output": "I have no idea what could be causing this, but my guess is that it's more likely to be a uvicorn issue than a fastapi issue. I'd recommend trying with a non-fastapi (and ideally non-starlette-based) framework -- if you have the same problem hitting breakpoints, it would indicate the problem is in uvicorn.\r\n\r\n@euri10 any other suggestions for debugging in docker? (If I recall you have some experience with this.)\n\n---\n\nI'm using pycharm which uses pydevd iirc so no experience with pdb.\nMy guess is that uvicorn reload uses another process and afaik you cant pbd in another process,hence the behavior with reload only. \nBut you should ask in uvicorn imho, if a simple asgi app crashes the same.\n\n---\n\n@euri10 that's a good insight -- I definitely think the separate process issue could explain the problem\n\n---\n\nHey, thanks for the answers! Separate processes could explain the issue, but its weird that reload + pdb works correctly outside docker, running it in macOS.\n\n---\n\nHmm that's a good point. Can you run it outside of docker on a machine with the same operating system as the container? (E.g., on a cloud instance?)", "source": "issue", "type": "qa_comprehensive", "issue_number": 109}
{"instruction": "Post results to Error 405 Method not Allowed\n\nDetails:\nUsed the very code on the docs for simple posting and it only allows me to use get", "input": "Repository: FastAPI\nLabels: ", "output": "actually the log shows im using GET although in code im using POST", "source": "issue", "type": "qa_best_answer", "issue_number": 108}
{"instruction": "Provide a comprehensive answer to this question: Post results to Error 405 Method not Allowed", "input": "Used the very code on the docs for simple posting and it only allows me to use get", "output": "actually the log shows im using GET although in code im using POST\n\n---\n\nWhat was the resolution for this issue? I am getting same behavior.\n\n---\n\nThanks @Finix21 for reporting back and closing the issue :+1: \r\n\r\n@nikhilno1 you might want to follow the tutorial exactly as is. With the integrated docs UI to send the POST and confirm that it works. Then you can check in your own code, gradually what is different.\n\n---\n\n@tiangolo  Hi. I am running into the same issue as mentioned above. Going through the tutorial, and not one of [the snippets](https://fastapi.tiangolo.com/tutorial/body/) here work. The issue is, as @Finix21 mentions, that the code correctly states that the method should run on a POST request, the server executes it as a GET request.\r\n\r\nAs an example, this code:\r\n\r\n```python\r\nfrom typing import Optional\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Item(BaseModel):\r\n    name: str\r\n    description: Optional[str] = None\r\n    price: float\r\n    tax: Optional[float] = None\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post(\"/items/\")\r\nasync def create_item(item: Item):\r\n    return item\r\n```\r\n\r\nwill result in `{\"detail\":\"Method Not Allowed\"}`, and the terminal reports:\r\n\r\n```\r\nâ†[32mINFOâ†[0m:     127.0.0.1:57638 - \"â†[1mGET /items/ HTTP/1.1â†[0m\" â†[31m405 Method Not Allowedâ†[0m\r\n```\r\n\r\nThis is true for all snippets on that page. I have tried without `--reload`, tried restarting the server.\r\n\r\nRunning on Windows 10 64x, Python 3.8.2:\r\n - fastapi    0.61.1\r\n - starlette  0.13.6\r\n - uvicorn    0.12.2\n\n---\n\n@BramVanroy can you try sending a curl request? The code snippet you have works well for me\r\n\r\n```\r\ncurl -X POST \"http://127.0.0.1:8000/items/\" -H  \"accept: application/json\" -H  \"Content-Type: application/json\" -d \"{\\\"name\\\":\\\"string\\\",\\\"description\\\":\\\"string\\\",\\\"price\\\":0,\\\"tax\\\":0}\"\r\n```\r\n\r\n```python\r\nOut: {\"name\":\"string\",\"description\":\"string\",\"price\":0.0,\"tax\":0.0}\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 108}
{"instruction": "Handling Exception Response format\n\nDetails:\nHello.\r\nI want to change the validation error response and make it inside `app` object.\r\n\r\nI've found this example:\r\n```\r\n@app.exception_handler(RequestValidationError)\r\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\r\n    return JSONResponse(\r\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\r\n        content=jsonable_encoder({\"detail\": exc.errors(), \"body\": exc.body}),\r\n    )\r\n```\r\n\r\nBut can't understand how to add this function to `app` object without decorator:\r\n```\r\napp = FastAPI(\r\n    title='Bla API',\r\n    description='Bla description',\r\n    APIRoute('/api', api.toggle, methods=['POST'],\r\n             description='Switch interface state',\r\n             response_description='Interface successfully switched',\r\n             response_class=JSONResponse,\r\n             response_model=api.Success,\r\n             responses={**api.post_responses},\r\n             ),\r\n...\r\n\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "Why is the use of decorators problematic? Defininig pretty much anything inside the FastAPI constructor like that is certainly an uncommon way to do things and much of the discussion in #687 was about how that approach would be likely to be less ergonomic for routes when taking FastAPI's goals into account (like how Path parameters would end up split between the route declaration and the function signature).\r\n\r\nIt's not currently possible to do that with `exception_hadler` with FastAPI right now (upstream Starlette versions support that, but it causes compatibility issues with FastAPI, see #683), but why do you want to do that with the exception handler?", "source": "issue", "type": "qa_best_answer", "issue_number": 107}
{"instruction": "Provide a comprehensive answer to this question: Handling Exception Response format", "input": "Hello.\r\nI want to change the validation error response and make it inside `app` object.\r\n\r\nI've found this example:\r\n```\r\n@app.exception_handler(RequestValidationError)\r\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\r\n    return JSONResponse(\r\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\r\n        content=jsonable_encoder({\"detail\": exc.errors(), \"body\": exc.body}),\r\n    )\r\n```\r\n\r\nBut can't understand how to add this function to `app` object without decorator:\r\n```\r\napp = FastAPI(\r\n    title='Bla API',\r\n    description='Bla description',\r\n    APIRoute('/api', api.toggle, methods=['POST'],\r\n             description='Switch interface state',\r\n             response_description='Interface successfully switched',\r\n             response_class=JSONResponse,\r\n             response_model=api.Success,\r\n             responses={**api.post_responses},\r\n             ),\r\n...\r\n\r\n```", "output": "Why is the use of decorators problematic? Defininig pretty much anything inside the FastAPI constructor like that is certainly an uncommon way to do things and much of the discussion in #687 was about how that approach would be likely to be less ergonomic for routes when taking FastAPI's goals into account (like how Path parameters would end up split between the route declaration and the function signature).\r\n\r\nIt's not currently possible to do that with `exception_hadler` with FastAPI right now (upstream Starlette versions support that, but it causes compatibility issues with FastAPI, see #683), but why do you want to do that with the exception handler?\n\n---\n\nI have an app that has both GUI (rendering HTML page) and API.\r\nIt is pretty convenient to keep code of web view in one module and API code in another one, then import these modules and build an app object.\r\nThis approach just keeps everything in its own place.\r\n\r\nThis is how I like it:\r\n```\r\n\r\nimport api\r\nfrom views import home\r\n\r\nstatics = StaticFiles(directory=\"statics\", packages=[\"bootstrap4\"])\r\n\r\n\r\napp = FastAPI(\r\n    title='Yandex.Cloud Netinfra API',\r\n    description='A bundled API for Yandex.Cloud Netinfra team tools',\r\n    routes=[\r\n        Route('/', home, methods=['GET', 'POST']),\r\n        APIRoute('/api', api.check, methods=['GET'], tags=['VlanToggler'],\r\n                 # name='String replaces function name on Swagger API page',\r\n                 # summary='String replaces function name AND name on Swagger API page',\r\n                 description='Get current interface state',\r\n                 response_description='Successfully got interface state',\r\n                 response_class=JSONResponse,\r\n                 response_model=api.Success,\r\n                 responses={**api.get_responses}\r\n                 ),\r\n        APIRoute('/api', api.toggle, methods=['POST'], tags=['VlanToggler'],\r\n                 description='Switch interface state',\r\n                 response_description='Interface successfully switched',\r\n                 response_class=JSONResponse,\r\n                 response_model=api.Success,\r\n                 responses={**api.post_responses},\r\n                 ),\r\n        Mount('/statics', statics, name='static'),\r\n    ],\r\n)\r\n```\n\n---\n\nSo you're defining each route in separate modules, importing each of them in your app module and then declaring your routes inside your constructor? Usually you would want to either [create an `APIRouter` in these modules and do something like this](https://fastapi.tiangolo.com/tutorial/bigger-applications/):\r\n\r\n```py\r\nfrom api import api_router\r\napp.include_router(api_router, prefix='/api')\r\n```\r\n\r\n...or build secondary app objects for your API and your HTML views and [mount those onto your primary app](https://fastapi.tiangolo.com/advanced/sub-applications-proxy/#mounting-a-fastapi-application):\r\n\r\n```py\r\nfrom api import api_app\r\napp.mount('/api', api_app)\r\n```\n\n---\n\nThat code style looks a lot like the style Starlette 0.13 is moving to, you might want to read #687 to see why it tends to be problematic with FastAPI (though it still works fine for mounting routes and routers, nothing wrong with it).\r\n\r\nRegarding exception handlers, though, you can't do that, at least not for the time being, as FastAPI still uses Starlette 0.12.9, specifically because putting exception handlers in the constructor proved to be a breaking change.\n\n---\n\nI didn't know I can mount one app to another. I can use this to keep API separated from VIEW module. Thanks for this tip.\r\n\r\nIs it fine to mount FastAPI app object to Starlette app object?", "source": "issue", "type": "qa_comprehensive", "issue_number": 107}
{"instruction": "about qps\n\nDetails:\n# Description\r\n\r\nThe simple get 'hello world' server crashed when I send more than 510 requests in a second to the fastAPI.\r\n\r\n```\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return \"Hello World\"\r\n```\r\n\r\nHow to improve qps for it?\r\n\r\nIâ€˜ve checked and can't find an effective way in question[https://github.com/tiangolo/fastapi/issues/603](https://github.com/tiangolo/fastapi/issues/603) or any other issues.\r\n\r\nMy environments:\r\nwin10 1903\r\nPython 3.7.5 64bit\r\nfastapi 0.52.0\r\nuvicorn 0.11.3\r\n\r\nused module grequests to send the requests.\r\n```\r\nimport grequests, time, collections\r\n\r\ndef qps_test(url, N):\r\n    start_time = time.time()\r\n    res_list = grequests.map([\r\n        grequests.get(url) \r\n        for _ in range(N)\r\n    ])\r\n    print(f'time: {time.time() - start_time}\\nstatue_code:')\r\n    print('\\n'.join(\r\n        f'{k}: {v}'\r\n        for k, v in collections.Counter(\r\n            res is None and 'LOST' or res.status_code\r\n            for res in res_list\r\n        ).items()\r\n    ))\r\n\r\nif __name__ == '__main__':\r\n    qps_test('http://127.0.0.1:8000/', 500)\r\n    # qps_test('http://127.0.0.1:8000/', 511) #crashed\r\n```\r\n\r\n`uvicorn main:app --reload` run in cmd (follow the docs).\r\nand i also tried `uvicorn main:app` , the same.\r\n\r\nerror message:\r\n\r\n`Process SpawnProcess-1:\r\nTraceback (most recent call last):\r\n  File \"d:\\python37\\lib\\multiprocessing\\process.py\", line 297, in _bootstrap\r\n    self.run()\r\n  File \"d:\\python37\\lib\\multiprocessing\\process.py\", line 99, in run\r\n    self._target(*self._args, **self._kwargs)\r\n  File \"d:\\python37\\lib\\site-packages\\uvicorn\\subprocess.py\", line 61, in subprocess_started\r\n    target(sockets=sockets)\r\n  File \"d:\\python37\\lib\\site-packages\\uvicorn\\main.py\", line 382, in run\r\n    loop.run_until_complete(self.serve(sockets=sockets))\r\n  File \"d:\\python37\\lib\\asyncio\\base_events.py\", line 566, in run_until_complete\r\n    self.run_forever()\r\n  File \"d:\\python37\\lib\\asyncio\\base_events.py\", line 534, in", "input": "Repository: FastAPI\nLabels: ", "output": "What is the code of your hello world server?\r\n\r\nAlso see https://stackoverflow.com/questions/47675410/python-asyncio-aiohttp-valueerror-too-many-file-descriptors-in-select-on-win", "source": "issue", "type": "qa_best_answer", "issue_number": 106}
{"instruction": "Provide a comprehensive answer to this question: about qps", "input": "# Description\r\n\r\nThe simple get 'hello world' server crashed when I send more than 510 requests in a second to the fastAPI.\r\n\r\n```\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return \"Hello World\"\r\n```\r\n\r\nHow to improve qps for it?\r\n\r\nIâ€˜ve checked and can't find an effective way in question[https://github.com/tiangolo/fastapi/issues/603](https://github.com/tiangolo/fastapi/issues/603) or any other issues.\r\n\r\nMy environments:\r\nwin10 1903\r\nPython 3.7.5 64bit\r\nfastapi 0.52.0\r\nuvicorn 0.11.3\r\n\r\nused module grequests to send the requests.\r\n```\r\nimport grequests, time, collections\r\n\r\ndef qps_test(url, N):\r\n    start_time = time.time()\r\n    res_list = grequests.map([\r\n        grequests.get(url) \r\n        for _ in range(N)\r\n    ])\r\n    print(f'time: {time.time() - start_time}\\nstatue_code:')\r\n    print('\\n'.join(\r\n        f'{k}: {v}'\r\n        for k, v in collections.Counter(\r\n            res is None and 'LOST' or res.status_code\r\n            for res in res_list\r\n        ).items()\r\n    ))\r\n\r\nif __name__ == '__main__':\r\n    qps_test('http://127.0.0.1:8000/', 500)\r\n    # qps_test('http://127.0.0.1:8000/', 511) #crashed\r\n```\r\n\r\n`uvicorn main:app --reload` run in cmd (follow the docs).\r\nand i also tried `uvicorn main:app` , the same.\r\n\r\nerror message:\r\n\r\n`Process SpawnProcess-1:\r\nTraceback (most recent call last):\r\n  File \"d:\\python37\\lib\\multiprocessing\\process.py\", line 297, in _bootstrap\r\n    self.run()\r\n  File \"d:\\python37\\lib\\multiprocessing\\process.py\", line 99, in run\r\n    self._target(*self._args, **self._kwargs)\r\n  File \"d:\\python37\\lib\\site-packages\\uvicorn\\subprocess.py\", line 61, in subprocess_started\r\n    target(sockets=sockets)\r\n  File \"d:\\python37\\lib\\site-packages\\uvicorn\\main.py\", line 382, in run\r\n    loop.run_until_complete(self.serve(sockets=sockets))\r\n  File \"d:\\python37\\lib\\asyncio\\base_events.py\", line 566, in run_until_complete\r\n    self.run_forever()\r\n  File \"d:\\python37\\lib\\asyncio\\base_events.py\", line 534, in", "output": "What is the code of your hello world server?\r\n\r\nAlso see https://stackoverflow.com/questions/47675410/python-asyncio-aiohttp-valueerror-too-many-file-descriptors-in-select-on-win\n\n---\n\n> What is the code of your hello world server?\r\n> \r\n> Also see https://stackoverflow.com/questions/47675410/python-asyncio-aiohttp-valueerror-too-many-file-descriptors-in-select-on-win\r\n\r\nthanks for comments\r\n\r\n```\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return \"Hello World\"\r\n```\r\n\r\ni also tried to run in power shell, but still not work, and it much slower than in cmd.\r\n\r\nand i worte a c-extern for it yesterday, but it doesn't work, doesn't real set the maxstdio in python program.\r\n\r\nc:\r\n```\r\n#include<stdio.h>\r\n\r\nvoid set_max_stdio()\r\n{\r\n    printf(\"%d \\n\", _getmaxstdio()); // stdout 512\r\n    _setmaxstdio(2048); // If the parameter is bigger than 2048, it changes back to 512\r\n    printf(\"setmaxstdio: %d \\n\", _getmaxstdio()); // stdout 2048\r\n}\r\n```\r\npython:\r\n```\r\nfrom ctypes import cdll\r\ncdll.LoadLibrary(\"./setmaxstdio.so\").set_max_stdio()\r\n```\r\n\r\ni checked it in stackoverflow, but still have no idea how to set it in main.py\n\n---\n\nany reason to use the `--reload` flag ?\n\n---\n\n> any reason to use the `--reload` flag ?\r\n\r\njust follow the docs from https://fastapi.tiangolo.com/\r\n\r\ndoesn't matter to the error whether use it or not\n\n---\n\nok, one way to deal with it would be to try set your loop to be a ProactorEventLoop as advised in the stackoverflow thread.\r\nthis one has been removed by default since https://github.com/encode/uvicorn/commit/abd68704ea75cdbac8ffb1b5c59578a17a716a56 but you can still change it", "source": "issue", "type": "qa_comprehensive", "issue_number": 106}
{"instruction": "Use TestClient in an async fashion\n\nDetails:\n### Is your feature request related to a problem\n\nUnfortunately, test client runs it's own event loop. This causes an issue when attempting to do other async operations in the background.\nRunning it inside an executor will cause it to run in a different threat, which in turn causes issues with other async libraries a they're calling coroutines from a different thread.\n\n### The solution you would like\n\nMake a TestClient that doesn't create it's own loop. Just have it async. \n\n### Describe alternatives you've considered\n\nOther than executor or partching fastapi, there are no alternatives.", "input": "Repository: FastAPI\nLabels: ", "output": "There are plans (https://github.com/encode/starlette/issues/440 and https://github.com/encode/starlette/issues/652) to move `starlette.testclient.TestClient` from `requests` to `httpx` to fix this behaviour. Before this happens you can try using `httpx` [directly](https://www.python-httpx.org/async/#calling-into-python-web-apps) or try the [`async-asgi-client`](https://pypi.org/project/async-asgi-testclient/) package. But there may be some problems with the templates, if you are using them.", "source": "issue", "type": "qa_best_answer", "issue_number": 105}
{"instruction": "Provide a comprehensive answer to this question: Use TestClient in an async fashion", "input": "### Is your feature request related to a problem\n\nUnfortunately, test client runs it's own event loop. This causes an issue when attempting to do other async operations in the background.\nRunning it inside an executor will cause it to run in a different threat, which in turn causes issues with other async libraries a they're calling coroutines from a different thread.\n\n### The solution you would like\n\nMake a TestClient that doesn't create it's own loop. Just have it async. \n\n### Describe alternatives you've considered\n\nOther than executor or partching fastapi, there are no alternatives.", "output": "There are plans (https://github.com/encode/starlette/issues/440 and https://github.com/encode/starlette/issues/652) to move `starlette.testclient.TestClient` from `requests` to `httpx` to fix this behaviour. Before this happens you can try using `httpx` [directly](https://www.python-httpx.org/async/#calling-into-python-web-apps) or try the [`async-asgi-client`](https://pypi.org/project/async-asgi-testclient/) package. But there may be some problems with the templates, if you are using them.\n\n---\n\nAs long as fastapi doesn't support it, may I suggest adding a note to the docs?\n\n---\n\nYes, good idea. I think adding an [`info`](https://squidfunk.github.io/mkdocs-material/extensions/admonition/#info) block after the introduction on [this](https://fastapi.tiangolo.com/tutorial/testing/) page will be good place, right? \r\n\r\nIn addition, it is possible to create a new page that will show how to use `httpx` (or `async-asgi-client`) for tests. Probably in the advanced section. \r\n\r\nWould you submit a PR?\n\n---\n\nYep, as @nsidnev says. :point_up: \r\n\r\nAnd yeah, that could probably have a small section in the advanced tutorial.\n\n---\n\nI've done some async testing using `httpx` in the last few days, as I wanted to verify the state of the database in my tests as well, and that works really well! I don't have experience with the `async-asgi-client` though.\r\n\r\nWould be up to write a section in the docs on it!", "source": "issue", "type": "qa_comprehensive", "issue_number": 105}
{"instruction": "FastAPI and Uvicorn is running synchronously and very slow\n\nDetails:\nI'm new in FastAPI and i'm testing file uploads and asyncronous requests. However, when i perform several request with clients parallel and serial the FastAPI process each upload in Queue (synchronously) and very slow. I'm performing the API with uvicorn and gunicorn and with 1 worker. With both execution the time spent was the same.\r\n\r\nMy client send 4 files with approximately 20MB in parallel (or in serial) for FastAPI endpoint, however, it is storing the files one at a time and very slow.\r\n\r\nI made the same upload with a aiohttp endpoint and the files was stored in approximately 0.6 seconds with client making request in parallel (multiprocessing) and 0.8 seconds with client making request in serial (in mean). When i made this uploads in FastAPI the files was stored in approximately 13 seconds with client making parallel request and 15 seconds with client making serial request (in mean)\r\n\r\nWould I like know if i'm making anything wrong?\r\n\r\n\r\n### Server Code\r\n\r\n```python\r\n\r\n# app.py\r\n\r\nfrom fastapi import FastAPI, File, UploadFile\r\nimport random\r\nimport aiofiles\r\nimport os\r\n\r\napp = FastAPI()\r\n\r\nSTORAGE_PATH = 'storage'\r\n\r\n@app.post(\"/\")\r\nasync def read_root(file: UploadFile=File('teste')):\r\n    fpath = os.path.join(\r\n        STORAGE_PATH, f'{random.randint(0, 5000)}_{file.filename}'\r\n    )\r\n    async with aiofiles.open(fpath, 'wb') as f:\r\n        content = await file.read()\r\n        await f.write(content)\r\n\r\n    return {\"Test\": \"Test\"}\r\n\r\n\r\n# uvicorn app:app --host 0.0.0.0 --port 8000 --workers 1\r\n# gunicorn -w=1 -k=uvicorn.workers.UvicornWorker --bind=0.0.0.0:8000 app:app\r\n```\r\n\r\n\r\n### Client Code\r\n```python\r\nFILES = ['f1.txt', 'f2.txt', 'f3.txt', 'f4.txt' ]\r\n\r\ndef request(fname):\r\n    files = {'file': open(fname,'rb')} \r\n    requests.post(\"http://localhost:8000/\", files=files)\r\n\r\n\r\ndef req_mp():\r\n    start = datetime.now() \r\n    pool = Pool(4) \r\n    pool.map(request, FILES) \r\n    print(datetime.now() - start)\r\n\r\n\r\ndef req_serial():\r\n    start = datetime.now()  \r\n", "input": "Repository: FastAPI\nLabels: ", "output": "aiofiles itself is very slow, I would try re-running this using open and write directly, which will block but will probably be faster\r\n\r\nfile.read() is also going to read the entire file then put i into memory, which I believe under the covers may be a blocking operation despite saying async\r\n\r\nI would try the following which may not work, alternatively you can use `async read(bytes)` to choose the rate at which you read and then write it.\r\n\r\n```python\r\n    async with aiofiles.open(fpath, 'wb') as f:\r\n        for line in file:\r\n            await f.write(content)\r\n```\r\n\r\nIf you really want to have non blocking uploads you'll need to send a binary stream, and read it directly from the body, that's how I'm handling multi gb uploads in my own system.", "source": "issue", "type": "qa_best_answer", "issue_number": 104}
{"instruction": "Provide a comprehensive answer to this question: FastAPI and Uvicorn is running synchronously and very slow", "input": "I'm new in FastAPI and i'm testing file uploads and asyncronous requests. However, when i perform several request with clients parallel and serial the FastAPI process each upload in Queue (synchronously) and very slow. I'm performing the API with uvicorn and gunicorn and with 1 worker. With both execution the time spent was the same.\r\n\r\nMy client send 4 files with approximately 20MB in parallel (or in serial) for FastAPI endpoint, however, it is storing the files one at a time and very slow.\r\n\r\nI made the same upload with a aiohttp endpoint and the files was stored in approximately 0.6 seconds with client making request in parallel (multiprocessing) and 0.8 seconds with client making request in serial (in mean). When i made this uploads in FastAPI the files was stored in approximately 13 seconds with client making parallel request and 15 seconds with client making serial request (in mean)\r\n\r\nWould I like know if i'm making anything wrong?\r\n\r\n\r\n### Server Code\r\n\r\n```python\r\n\r\n# app.py\r\n\r\nfrom fastapi import FastAPI, File, UploadFile\r\nimport random\r\nimport aiofiles\r\nimport os\r\n\r\napp = FastAPI()\r\n\r\nSTORAGE_PATH = 'storage'\r\n\r\n@app.post(\"/\")\r\nasync def read_root(file: UploadFile=File('teste')):\r\n    fpath = os.path.join(\r\n        STORAGE_PATH, f'{random.randint(0, 5000)}_{file.filename}'\r\n    )\r\n    async with aiofiles.open(fpath, 'wb') as f:\r\n        content = await file.read()\r\n        await f.write(content)\r\n\r\n    return {\"Test\": \"Test\"}\r\n\r\n\r\n# uvicorn app:app --host 0.0.0.0 --port 8000 --workers 1\r\n# gunicorn -w=1 -k=uvicorn.workers.UvicornWorker --bind=0.0.0.0:8000 app:app\r\n```\r\n\r\n\r\n### Client Code\r\n```python\r\nFILES = ['f1.txt', 'f2.txt', 'f3.txt', 'f4.txt' ]\r\n\r\ndef request(fname):\r\n    files = {'file': open(fname,'rb')} \r\n    requests.post(\"http://localhost:8000/\", files=files)\r\n\r\n\r\ndef req_mp():\r\n    start = datetime.now() \r\n    pool = Pool(4) \r\n    pool.map(request, FILES) \r\n    print(datetime.now() - start)\r\n\r\n\r\ndef req_serial():\r\n    start = datetime.now()  \r\n", "output": "aiofiles itself is very slow, I would try re-running this using open and write directly, which will block but will probably be faster\r\n\r\nfile.read() is also going to read the entire file then put i into memory, which I believe under the covers may be a blocking operation despite saying async\r\n\r\nI would try the following which may not work, alternatively you can use `async read(bytes)` to choose the rate at which you read and then write it.\r\n\r\n```python\r\n    async with aiofiles.open(fpath, 'wb') as f:\r\n        for line in file:\r\n            await f.write(content)\r\n```\r\n\r\nIf you really want to have non blocking uploads you'll need to send a binary stream, and read it directly from the body, that's how I'm handling multi gb uploads in my own system.\n\n---\n\nThanks for answer @chris-allnutt. I don't know exactly how do make \"async read(bytes)\" . i made another tests, with others algorithm and the result also was slow. I changed the algorithm for write file asynchronously (chunk by chunk) and the result was the same.\r\n### New test 1\r\n```python\r\nwith open(fpath, 'wb') as f:\r\n    content = await file.read(4096)\r\n    f.write(content)\r\n\r\n# uvicorn - time spent: 8 seconds - client serial (req_serial)\r\n# uvicorn - time spent: 6 seconds - client parallel (req_mp)\r\n# gunicorn - time spent: 6 seconds - client - parallel (req_mp)\r\n# gunicorn - time spent: 6 seconds - client serial (req_serial)\r\n```\r\n### New test 2\r\n```python\r\nasync with aiofiles.open(fpath, 'wb') as f:\r\n    while True:\r\n    chunk = await file.read(4096)\r\n    if not bool(chunk):\r\n        break\r\n        await f.write(chunk)\r\n # uvicorn - time spent: 15 seconds - client serial (req_serial)\r\n # uvicorn - time spent: 12 seconds - client parallel (req_mp)\r\n # gunicorn - time spent: 13 seconds - client serial (req_serial)\r\n # gunicorn - time spent: 12 seconds - client parallel (req_mp)\r\n```\r\n\r\nthis same algorithm was used in my tests with aiohttp and the read and write was asyncronously in fact with time between 0.8 and 0.4  seconds (aproximately) for save files. I made these tests with django with all operations sincronouly and the all files are written between 1.2 and 1.8 seconds.\r\n\r\nAnother thing i saw, when i send the requests, exists a delay until request are processed by python code.\r\n\r\nI saw many benchmarks and fastAPI and Uvicorn has great results. But, I can't verify the performance optimization that the tool offers in the tests I'm doing.\r\n\r\nI'd like to use FastAPI in my next projects, but, unfortunately this basic tests aren't show very nice results.\n\n---\n\n<del>Well here nobody wants to sell you anything</del>, but could you post your OS and Python version?\n\n---\n\nThe test was performed in Ubuntu 18.04 (Desktop), CPU I5 4 cores, 8GB RAM and with Python 3.8.0.\n\n---\n\nIIRC, all `aiofiles` does is run the blocking file operations in a threadpool to avoid blocking, so there wouldn't be much difference between using `aiofiles` to manipulate a file from within an `async def read_root()` route and using the standard python file I/O functions from within a `def read_root()` (which FastAPI would automatically run inside a threadpool). From what I'm reading, `aiofile` (no 's' at the end) uses POSIX asynchronous file I/O calls directly, so it might be worth trying that.\r\n\r\nI remember reading in some places that POSIX asyncio operations [have their share of issues](https://lwn.net/Articles/671657/), and it looks like this might be the reason why [asyncio doesn't support them directly](https://github.com/python/asyncio/wiki/ThirdParty#filesystem) (this section looks to have been written in 2015 or before, so it might not reflect the latest state of things). I'm not seeing any mention of IOCP for async file I/O on Windows or io_uring for Linux, so that might be ripe for improvements in the near future. Right now, though, `aiofile` seems to be your best option.\r\n\r\n**TL;DR**: Async file I/O is hard, and it's one use case where support tends to be disappointing in a lot of places, unfortunately.", "source": "issue", "type": "qa_comprehensive", "issue_number": 104}
{"instruction": "Depends object returned instead of session\n\nDetails:\nI am currently trying to migrate from flask to fastapi and trying to keep my files separated. My depends is not called from my routes but from within my crud file but similar to the documentation for relational databases: https://fastapi.tiangolo.com/tutorial/sql-databases/\r\n\r\nThis was my initial way of using a database session which is similar to the sqlalchemy docs\r\nAlso, is this bad practice or is it okay to use this and a mix of depends? I did kind of want to decouple sqlalchemy from fastapi.\r\n```python\r\ndef get_database():\r\n    db = scoped_session(default_session)\r\n    try:\r\n        yield db\r\n    finally:\r\n        db.close()\r\n\r\ndef get_references(db: scoped_session = next(get_database())):\r\n    references = db.query(Reference).all()\r\n    return references\r\n```\r\n\r\nI then tried to switch and use Depends but am getting the same issue as others below with my attempts added at the end:\r\n\r\n> > I am seeing this same issue in .52 using almost verbatim the doc examples with postgres. Depends is not calling the function but returning what appears to be an instantiate Depends object.\r\n> \r\n> @pspierce and @H0r53, Did you solve this? I am seeing in 0.58.1. I also tried: instead of using generator, returning the db directly -- same problem.\r\n\r\n```python\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import scoped_session, sessionmaker\r\n\r\nengine = create_engine('postgresql://postgres:postgres@localhost:5432/postgres', echo=True)\r\ndefault_session = scoped_session(sessionmaker(autocommit=False,\r\n                                         autoflush=False,\r\n                                         bind=engine))\r\n\r\ndef get_database():\r\n    db = default_session()\r\n    try:\r\n        yield db\r\n    finally:\r\n        db.close()\r\n\r\n```\r\n\r\n\r\nFirst error I got:\r\n\r\n> AttributeError: 'Depends' object has no attribute 'query'\r\n\r\n```python\r\nfrom database.data import get_database, scoped_session\r\nfrom database.models.reference import Reference\r\nfrom fastapi import Depends\r\n\r\n\r\ndef ge", "input": "Repository: FastAPI\nLabels: ", "output": "As I can see, you calling `get_database` directly in function arguments, but you have to pass function object into Depends in order to make injection. In your case you should rewrite `def get_references` as:\r\n```\r\ndef get_references(db: scoped_session = Depends(get_database)):\r\n    references = db.query(Reference).all()\r\n    return references\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 103}
{"instruction": "Provide a comprehensive answer to this question: Depends object returned instead of session", "input": "I am currently trying to migrate from flask to fastapi and trying to keep my files separated. My depends is not called from my routes but from within my crud file but similar to the documentation for relational databases: https://fastapi.tiangolo.com/tutorial/sql-databases/\r\n\r\nThis was my initial way of using a database session which is similar to the sqlalchemy docs\r\nAlso, is this bad practice or is it okay to use this and a mix of depends? I did kind of want to decouple sqlalchemy from fastapi.\r\n```python\r\ndef get_database():\r\n    db = scoped_session(default_session)\r\n    try:\r\n        yield db\r\n    finally:\r\n        db.close()\r\n\r\ndef get_references(db: scoped_session = next(get_database())):\r\n    references = db.query(Reference).all()\r\n    return references\r\n```\r\n\r\nI then tried to switch and use Depends but am getting the same issue as others below with my attempts added at the end:\r\n\r\n> > I am seeing this same issue in .52 using almost verbatim the doc examples with postgres. Depends is not calling the function but returning what appears to be an instantiate Depends object.\r\n> \r\n> @pspierce and @H0r53, Did you solve this? I am seeing in 0.58.1. I also tried: instead of using generator, returning the db directly -- same problem.\r\n\r\n```python\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import scoped_session, sessionmaker\r\n\r\nengine = create_engine('postgresql://postgres:postgres@localhost:5432/postgres', echo=True)\r\ndefault_session = scoped_session(sessionmaker(autocommit=False,\r\n                                         autoflush=False,\r\n                                         bind=engine))\r\n\r\ndef get_database():\r\n    db = default_session()\r\n    try:\r\n        yield db\r\n    finally:\r\n        db.close()\r\n\r\n```\r\n\r\n\r\nFirst error I got:\r\n\r\n> AttributeError: 'Depends' object has no attribute 'query'\r\n\r\n```python\r\nfrom database.data import get_database, scoped_session\r\nfrom database.models.reference import Reference\r\nfrom fastapi import Depends\r\n\r\n\r\ndef ge", "output": "As I can see, you calling `get_database` directly in function arguments, but you have to pass function object into Depends in order to make injection. In your case you should rewrite `def get_references` as:\r\n```\r\ndef get_references(db: scoped_session = Depends(get_database)):\r\n    references = db.query(Reference).all()\r\n    return references\r\n```\n\n---\n\nJust to complement: `Depends` receives a callable.\r\nThere's something that there's a miss concept when you do this:\r\n```\r\ndef get_references(db: scoped_session = Depends(get_database())):\r\n```\r\nNotice that `Depends` is not receiving a callable, you're calling `get_database()`. Which means that `Depends` will not receive the callable, and will try to solve it without success. That's why you're having the current error.\r\n\r\nAs @SirTelemak said, you should use this notation:\r\n```\r\ndef get_references(db: scoped_session = Depends(get_database)):\r\n```\r\nAnd here you can see that `get_database` is not being called. Now `Depends` can successfully solve it.\r\n\r\nPs.: You can still use the last notation, without `Depends`, but the problem is that you're getting a generator in your snippet. To solve it you should use `next`. I don't recommend this approach, but I'll show you anyway:\r\n```\r\ndef get_references(db: scoped_session = next(get_database())):\r\n```\r\nor:\r\n```\r\ndef get_references(db: scoped_session = get_database()):\r\n    # some_var = next(db)\r\n```\n\n---\n\n> Ps.: You can still use the last notation, without `Depends`, but the problem is that you're getting a generator in your snippet. To solve it you should use `next`. I don't recommend this approach, but I'll show you anyway:\r\n> \r\n> ```\r\n> def get_references(db: scoped_session = next(get_database())):\r\n> ```\r\n> \r\n> or:\r\n> \r\n> ```\r\n> def get_references(db: scoped_session = get_database()):\r\n>     # some_var = next(db)\r\n> ```\r\n\r\nWhy do you not recommend this approach? My first example was like the example you put.\r\n\r\nI ended getting the initial approach cause I was declaring in its own module. I ended up reading somewhere that it might be because it was outside of my routes but I did not dig further yet since I was unsure if sqlalchemy's way was enough for my use case.\n\n---\n\n> Why do you not recommend this approach? My first example was like the example you put.\r\n\r\nFirst of all, that will be executed only once when this function imported, so you losing your \"one session for one call\" functionality and if something happens during handling db request you can lose session and won't be able to reopen it again.\r\nSecond, tear-down won't be working since it's feature of Depends. So you should manually call `next(db)` but it will close connection and won't be reopened again as I said (if you using second variant), in first variant you unable to close connection at all\r\n\r\nSo, with this approach you lose versatility and control in your program,\n\n---\n\nThird reason not to use that approach is that you lose the dependency injection/substitution feature of FastAPI, which makes it very easy to swap out dependencies when running tests, for example to use a testing database.", "source": "issue", "type": "qa_comprehensive", "issue_number": 103}
{"instruction": "AsyncClient ignores the startup and shutdown events\n\nDetails:\nThis is very close to #1072, but for AsyncClient.\r\n\r\nThe problem is that AsyncClient ignores the startup and shutdown events. \r\n\r\n# To Reproduce\r\n\r\nSteps to reproduce the behavior with a minimum self-contained file.\r\n\r\nReplace each part with your own scenario:\r\n- Create a main.py file with:\r\n\r\n```python\r\nfrom fastapi import FastAPI, Request\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def read_main():\r\n    return {\"msg\": \"Hello World\"}\r\n\r\n\r\nasync def add_test_header(request: Request, call_next):\r\n    response = await call_next(request)\r\n    response.headers[\"X-Test-Header\"] = 'Hello'\r\n    return response\r\n\r\n\r\n@app.on_event(\"startup\")\r\ndef setup():\r\n    # example code that runs on startup\r\n    global add_test_header\r\n    print('executing startup!!')\r\n    add_test_header = app.middleware(\"http\")(add_test_header)\r\n```\r\n\r\n- Create a test_startup.py file with:\r\n\r\n```python\r\nimport pytest\r\n\r\nfrom httpx import AsyncClient\r\n\r\nfrom main import app\r\n\r\n\r\n@pytest.fixture()\r\nasync def client():\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as \r\n        yield client\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_read_main(client):\r\n    response = await client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {\"msg\": \"Hello World\"}\r\n    assert 'X-Test-Header' in response.headers\r\n```\r\nRun pytest -s -v test_startup.py\r\nYou will see an AssertionError for the X-Test-Header not being there\r\nThe test should pass\r\n\r\n\r\n\r\nSo far I am using a hack to make it work:\r\n```python\r\n@pytest.fixture()\r\nasync def client():\r\n    \"\"\"Test client pytest fixture.\r\n\r\n    Example:\r\n        >>> from httpx import Response\r\n        >>>\r\n        >>>\r\n        >>> @pytest.mark.asyncio\r\n        >>> async def test_health_check(client):\r\n        >>>    resp: Response = await client.get(\"/health_check\")\r\n        >>>    assert resp.status_code == 200\r\n\r\n    \"\"\"\r\n    app = build_app()\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\r\n        await connect", "input": "Repository: FastAPI\nLabels: ", "output": "If a minimal example is provided, others can check. :tada:", "source": "issue", "type": "qa_best_answer", "issue_number": 102}
{"instruction": "Provide a comprehensive answer to this question: AsyncClient ignores the startup and shutdown events", "input": "This is very close to #1072, but for AsyncClient.\r\n\r\nThe problem is that AsyncClient ignores the startup and shutdown events. \r\n\r\n# To Reproduce\r\n\r\nSteps to reproduce the behavior with a minimum self-contained file.\r\n\r\nReplace each part with your own scenario:\r\n- Create a main.py file with:\r\n\r\n```python\r\nfrom fastapi import FastAPI, Request\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def read_main():\r\n    return {\"msg\": \"Hello World\"}\r\n\r\n\r\nasync def add_test_header(request: Request, call_next):\r\n    response = await call_next(request)\r\n    response.headers[\"X-Test-Header\"] = 'Hello'\r\n    return response\r\n\r\n\r\n@app.on_event(\"startup\")\r\ndef setup():\r\n    # example code that runs on startup\r\n    global add_test_header\r\n    print('executing startup!!')\r\n    add_test_header = app.middleware(\"http\")(add_test_header)\r\n```\r\n\r\n- Create a test_startup.py file with:\r\n\r\n```python\r\nimport pytest\r\n\r\nfrom httpx import AsyncClient\r\n\r\nfrom main import app\r\n\r\n\r\n@pytest.fixture()\r\nasync def client():\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as \r\n        yield client\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_read_main(client):\r\n    response = await client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {\"msg\": \"Hello World\"}\r\n    assert 'X-Test-Header' in response.headers\r\n```\r\nRun pytest -s -v test_startup.py\r\nYou will see an AssertionError for the X-Test-Header not being there\r\nThe test should pass\r\n\r\n\r\n\r\nSo far I am using a hack to make it work:\r\n```python\r\n@pytest.fixture()\r\nasync def client():\r\n    \"\"\"Test client pytest fixture.\r\n\r\n    Example:\r\n        >>> from httpx import Response\r\n        >>>\r\n        >>>\r\n        >>> @pytest.mark.asyncio\r\n        >>> async def test_health_check(client):\r\n        >>>    resp: Response = await client.get(\"/health_check\")\r\n        >>>    assert resp.status_code == 200\r\n\r\n    \"\"\"\r\n    app = build_app()\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\r\n        await connect", "output": "If a minimal example is provided, others can check. :tada:\n\n---\n\n@Kludex pls take a look one more time\n\n---\n\n@ZhukovGreen \r\nYou're using `httpx` and it's `AsyncClient` which i don't believe supports test?\r\nYou can use `pip install async_asgi_testclient` \r\n\r\nWhich will look like this:\r\n```\r\nimport pytest\r\n\r\nfrom main import app\r\nfrom async_asgi_testclient import TestClient\r\n\r\n\r\n@pytest.fixture\r\nasync def client():\r\n    async with TestClient(app) as client:\r\n        yield client\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_read_main(client):\r\n    response = await client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {\"msg\": \"Hello World\"}\r\n    assert 'X-Test-Header' in response.headers\r\n```\n\n---\n\n@ArcLightSlavik It's the recommended solution on our [documentation](https://fastapi.tiangolo.com/advanced/async-tests/#httpx).\n\n---\n\nAh, didn't see ðŸ™‚ \r\nWhat i did can be used as another workaround i guess Â¯\\_(ãƒ„)_/Â¯", "source": "issue", "type": "qa_comprehensive", "issue_number": 102}
{"instruction": "Error 422: Unprocessable entity when I send form data from JS script\n\nDetails:\n#### Backend\r\n```py\r\nfrom fastapi import FastAPI, File, Form, UploadFile, Request\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\n\r\norigins = [\"http://127.0.0.1:5500\"]\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=origins,\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n\r\n@app.post(\"/test\")\r\ndef test(username: str = Form(...)):\r\n    print(f\"########### Received {username} #############\")\r\n```\r\n### Frontend\r\n```js\r\nasync function sendData() {\r\n    formData = new FormData();\r\n    formData.append('username', 'Kareem');\r\n    const response = await fetch('http://127.0.0.1:8000/test', {\r\n        method: 'POST',\r\n        data: formData\r\n    })\r\n    console.log(response)\r\n```\r\n### Response\r\n```\r\nResponse {\r\nbody: (...)\r\nbodyUsed: false\r\nheaders: Headers {}\r\nok: false\r\nredirected: false\r\nstatus: 422\r\nstatusText: \"Unprocessable Entity\"\r\ntype: \"cors\"\r\nurl: \"http://127.0.0.1:8000/test\"\r\n__proto__: Response }\r\n```\r\n### Description\r\n- The `/test` endpoint is simply supposed to recieve a form containing only `username` and print it out.\r\n- When I test the API using swagger docs it works fine as expected, but when I try to send form data from an external script it throws me this error and that response object above.\r\n### Environment\r\n- OS: Linux\r\n- FastAPI version: 0.61.1\r\n- Python version: 3.8.2", "input": "Repository: FastAPI\nLabels: ", "output": "Try sending a request with a header.\r\n\r\n```javascript\r\nconst response = await fetch('http://127.0.0.1:8000/test', {\r\n        method: 'POST',\r\n        data: formData,\r\n        headers: {'content-type': 'multipart/form-data'}\r\n    })\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 101}
{"instruction": "Provide a comprehensive answer to this question: Error 422: Unprocessable entity when I send form data from JS script", "input": "#### Backend\r\n```py\r\nfrom fastapi import FastAPI, File, Form, UploadFile, Request\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\n\r\norigins = [\"http://127.0.0.1:5500\"]\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=origins,\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n\r\n@app.post(\"/test\")\r\ndef test(username: str = Form(...)):\r\n    print(f\"########### Received {username} #############\")\r\n```\r\n### Frontend\r\n```js\r\nasync function sendData() {\r\n    formData = new FormData();\r\n    formData.append('username', 'Kareem');\r\n    const response = await fetch('http://127.0.0.1:8000/test', {\r\n        method: 'POST',\r\n        data: formData\r\n    })\r\n    console.log(response)\r\n```\r\n### Response\r\n```\r\nResponse {\r\nbody: (...)\r\nbodyUsed: false\r\nheaders: Headers {}\r\nok: false\r\nredirected: false\r\nstatus: 422\r\nstatusText: \"Unprocessable Entity\"\r\ntype: \"cors\"\r\nurl: \"http://127.0.0.1:8000/test\"\r\n__proto__: Response }\r\n```\r\n### Description\r\n- The `/test` endpoint is simply supposed to recieve a form containing only `username` and print it out.\r\n- When I test the API using swagger docs it works fine as expected, but when I try to send form data from an external script it throws me this error and that response object above.\r\n### Environment\r\n- OS: Linux\r\n- FastAPI version: 0.61.1\r\n- Python version: 3.8.2", "output": "Try sending a request with a header.\r\n\r\n```javascript\r\nconst response = await fetch('http://127.0.0.1:8000/test', {\r\n        method: 'POST',\r\n        data: formData,\r\n        headers: {'content-type': 'multipart/form-data'}\r\n    })\r\n```\n\n---\n\n@ycd the error is now `400 Bad request`\n\n---\n\nWhat is the error in the response?\n\n---\n\n@Mause \r\n```\r\nResponse {\r\nbody: (...)\r\nbodyUsed: false\r\nheaders: Headers {}\r\nok: false\r\nredirected: false\r\nstatus: 400\r\nstatusText: \"Bad Request\"\r\ntype: \"cors\"\r\nurl: \"http://127.0.0.1:8000/test\"\r\n__proto__: Response }\r\n```\n\n---\n\nClick on the three little dots next to body?", "source": "issue", "type": "qa_comprehensive", "issue_number": 101}
{"instruction": "FastAPI+Uvicorn is running slow than Flask+uWSGI\n\nDetails:\nI'm new to fastapi and I'm trying to test speed between fastapi and flask, but I didn't get a better result by fastapi. pls tell me if I'm making anything wrong?\r\n\r\n### Example\r\n1. fastapi\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI(debug=False)\r\n\r\n@app.get(\"/\")\r\nasync def run():\r\n    return {\"message\": \"hello\"}\r\n```\r\n+ run command: `uvicorn --log-level error --workers 4 fastapi_test:app > /dev/null 2>&1 `\r\n\r\n2. flask\r\n```Python\r\nimport flask\r\n\r\napp = flask.Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef run():\r\n    return {\"message\": \"hello\"}\r\n```\r\n+ run command: `uwsgi --wsgi-file flask_test.py --process 4 --callable app --http :8000 > /dev/null 2>&1`\r\n\r\n### Result\r\n* use `ab -n 10000 -c 500 http://127.0.0.1:8000/` to test speed\r\n1. FastApi\r\n```\r\nRequests per second:    1533.91 [#/sec] (mean)\r\nTime per request:       325.965 [ms] (mean)\r\nTime per request:       0.652 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          244.17 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0   46 208.1      0    1000\r\nProcessing:     1  268 171.1    245     950\r\nWaiting:        0  201 146.1    174     909\r\nTotal:          1  314 296.7    246    1918\r\n```\r\n2. Flask\r\n```\r\nRequests per second:    1829.40 [#/sec] (mean)\r\nTime per request:       273.313 [ms] (mean)\r\nTime per request:       0.547 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          162.57 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0   18 131.3      0    1000\r\nProcessing:    12  192 556.3     36    4302\r\nWaiting:        0  191 556.3     35    4301\r\nTotal:         17  210 612.7     36    5300\r\n```\r\n\r\n### Environment\r\n\r\n* OS: CentOS 7\r\n* Python Version: 3.9.1\r\n* FastAPI Version: 0.63.0\r\n\r\n### Additional context\r\n\r\n<!-- Add any other context or screenshots about the question here. -->", "input": "Repository: FastAPI\nLabels: ", "output": "> I'm new to fastapi and I'm trying to test speed between fastapi and flask, but I didn't get a better result by fastapi. pls tell me if I'm making anything wrong?\r\n> \r\n> ### Example\r\n> 1. fastapi\r\n> \r\n> ```python\r\n> from fastapi import FastAPI\r\n> \r\n> app = FastAPI(debug=False)\r\n> \r\n> @app.get(\"/\")\r\n> async def run():\r\n>     return {\"message\": \"hello\"}\r\n> ```\r\n> \r\n> * run command: `uvicorn --log-level error --workers 4 fastapi_test:app > /dev/null 2>&1 `\r\n> \r\n> 1. flask\r\n> \r\n> ```python\r\n> import flask\r\n> \r\n> app = flask.Flask(__name__)\r\n> \r\n> @app.route(\"/\")\r\n> def run():\r\n>     return {\"message\": \"hello\"}\r\n> ```\r\n> \r\n> * run command: `uwsgi --wsgi-file flask_test.py --process 4 --callable app --http :8000 > /dev/null 2>&1`\r\n> \r\n> ### Result\r\n> * use `ab -n 10000 -c 500 http://127.0.0.1:8000/` to test speed\r\n> \r\n> 1. FastApi\r\n> \r\n> ```\r\n> Requests per second:    1533.91 [#/sec] (mean)\r\n> Time per request:       325.965 [ms] (mean)\r\n> Time per request:       0.652 [ms] (mean, across all concurrent requests)\r\n> Transfer rate:          244.17 [Kbytes/sec] received\r\n> \r\n> Connection Times (ms)\r\n>               min  mean[+/-sd] median   max\r\n> Connect:        0   46 208.1      0    1000\r\n> Processing:     1  268 171.1    245     950\r\n> Waiting:        0  201 146.1    174     909\r\n> Total:          1  314 296.7    246    1918\r\n> ```\r\n> \r\n> 1. Flask\r\n> \r\n> ```\r\n> Requests per second:    1829.40 [#/sec] (mean)\r\n> Time per request:       273.313 [ms] (mean)\r\n> Time per request:       0.547 [ms] (mean, across all concurrent requests)\r\n> Transfer rate:          162.57 [Kbytes/sec] received\r\n> \r\n> Connection Times (ms)\r\n>               min  mean[+/-sd] median   max\r\n> Connect:        0   18 131.3      0    1000\r\n> Processing:    12  192 556.3     36    4302\r\n> Waiting:        0  191 556.3     35    4301\r\n> Total:         17  210 612.7     36    5300\r\n> ```\r\n> \r\n> ### Environment\r\n> * OS: CentOS 7\r\n> * Python Version: 3.9.1\r\n> * FastAPI Version: 0.63.0\r\n> \r\n> ### Additional context\r\n\r\nWell... you're using \"async def\" in the FastAPI example when you're doing zeeo asynchronous operations in the endpoint. Try make it a normal function, then re-run the benchmarks.", "source": "issue", "type": "qa_best_answer", "issue_number": 100}
{"instruction": "Provide a comprehensive answer to this question: FastAPI+Uvicorn is running slow than Flask+uWSGI", "input": "I'm new to fastapi and I'm trying to test speed between fastapi and flask, but I didn't get a better result by fastapi. pls tell me if I'm making anything wrong?\r\n\r\n### Example\r\n1. fastapi\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI(debug=False)\r\n\r\n@app.get(\"/\")\r\nasync def run():\r\n    return {\"message\": \"hello\"}\r\n```\r\n+ run command: `uvicorn --log-level error --workers 4 fastapi_test:app > /dev/null 2>&1 `\r\n\r\n2. flask\r\n```Python\r\nimport flask\r\n\r\napp = flask.Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef run():\r\n    return {\"message\": \"hello\"}\r\n```\r\n+ run command: `uwsgi --wsgi-file flask_test.py --process 4 --callable app --http :8000 > /dev/null 2>&1`\r\n\r\n### Result\r\n* use `ab -n 10000 -c 500 http://127.0.0.1:8000/` to test speed\r\n1. FastApi\r\n```\r\nRequests per second:    1533.91 [#/sec] (mean)\r\nTime per request:       325.965 [ms] (mean)\r\nTime per request:       0.652 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          244.17 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0   46 208.1      0    1000\r\nProcessing:     1  268 171.1    245     950\r\nWaiting:        0  201 146.1    174     909\r\nTotal:          1  314 296.7    246    1918\r\n```\r\n2. Flask\r\n```\r\nRequests per second:    1829.40 [#/sec] (mean)\r\nTime per request:       273.313 [ms] (mean)\r\nTime per request:       0.547 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          162.57 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0   18 131.3      0    1000\r\nProcessing:    12  192 556.3     36    4302\r\nWaiting:        0  191 556.3     35    4301\r\nTotal:         17  210 612.7     36    5300\r\n```\r\n\r\n### Environment\r\n\r\n* OS: CentOS 7\r\n* Python Version: 3.9.1\r\n* FastAPI Version: 0.63.0\r\n\r\n### Additional context\r\n\r\n<!-- Add any other context or screenshots about the question here. -->", "output": "> I'm new to fastapi and I'm trying to test speed between fastapi and flask, but I didn't get a better result by fastapi. pls tell me if I'm making anything wrong?\r\n> \r\n> ### Example\r\n> 1. fastapi\r\n> \r\n> ```python\r\n> from fastapi import FastAPI\r\n> \r\n> app = FastAPI(debug=False)\r\n> \r\n> @app.get(\"/\")\r\n> async def run():\r\n>     return {\"message\": \"hello\"}\r\n> ```\r\n> \r\n> * run command: `uvicorn --log-level error --workers 4 fastapi_test:app > /dev/null 2>&1 `\r\n> \r\n> 1. flask\r\n> \r\n> ```python\r\n> import flask\r\n> \r\n> app = flask.Flask(__name__)\r\n> \r\n> @app.route(\"/\")\r\n> def run():\r\n>     return {\"message\": \"hello\"}\r\n> ```\r\n> \r\n> * run command: `uwsgi --wsgi-file flask_test.py --process 4 --callable app --http :8000 > /dev/null 2>&1`\r\n> \r\n> ### Result\r\n> * use `ab -n 10000 -c 500 http://127.0.0.1:8000/` to test speed\r\n> \r\n> 1. FastApi\r\n> \r\n> ```\r\n> Requests per second:    1533.91 [#/sec] (mean)\r\n> Time per request:       325.965 [ms] (mean)\r\n> Time per request:       0.652 [ms] (mean, across all concurrent requests)\r\n> Transfer rate:          244.17 [Kbytes/sec] received\r\n> \r\n> Connection Times (ms)\r\n>               min  mean[+/-sd] median   max\r\n> Connect:        0   46 208.1      0    1000\r\n> Processing:     1  268 171.1    245     950\r\n> Waiting:        0  201 146.1    174     909\r\n> Total:          1  314 296.7    246    1918\r\n> ```\r\n> \r\n> 1. Flask\r\n> \r\n> ```\r\n> Requests per second:    1829.40 [#/sec] (mean)\r\n> Time per request:       273.313 [ms] (mean)\r\n> Time per request:       0.547 [ms] (mean, across all concurrent requests)\r\n> Transfer rate:          162.57 [Kbytes/sec] received\r\n> \r\n> Connection Times (ms)\r\n>               min  mean[+/-sd] median   max\r\n> Connect:        0   18 131.3      0    1000\r\n> Processing:    12  192 556.3     36    4302\r\n> Waiting:        0  191 556.3     35    4301\r\n> Total:         17  210 612.7     36    5300\r\n> ```\r\n> \r\n> ### Environment\r\n> * OS: CentOS 7\r\n> * Python Version: 3.9.1\r\n> * FastAPI Version: 0.63.0\r\n> \r\n> ### Additional context\r\n\r\nWell... you're using \"async def\" in the FastAPI example when you're doing zeeo asynchronous operations in the endpoint. Try make it a normal function, then re-run the benchmarks.\n\n---\n\nFor a more detailed benchmark, check [TechEmpowers](https://www.techempower.com/benchmarks/#section=data-r19&hw=ph&test=composite&l=zijzen-1r&f=0-jz6rk-4ftog0-0-5jrvnk-1ekg-29gxz6-hragaq-4fuwq0-5jw554-0)\r\n\r\n Framework | JSON | 1-query | 20-query | Fortunes | Updates | Plaintext \r\n -- | -- | -- | -- | -- | -- | -- \r\nfastapi | 171,055 | 66,185 | 13,022 | 52,080 | 5,926 | 159,445 | 1,212 \r\n flask | 63,026 | 34,217 | 6,647 | 23,136 | 1,327 | 83,398 | 465\n\n---\n\nI believe using Uvicorn's Gunicorn worker class along with gunicorn offers more performance than the uvicorn workers\n\n---\n\n> Well... you're using \"async def\" in the FastAPI example when you're doing zeeo asynchronous operations in the endpoint. Try make it a normal function, then re-run the benchmarks.\r\n\r\n@dstlny It will be even costly if you do that.\n\n---\n\n> > Well... you're using \"async def\" in the FastAPI example when you're doing zeeo asynchronous operations in the endpoint. Try make it a normal function, then re-run the benchmarks.\r\n> \r\n> @dstlny It will be even costly if you do that.\r\n\r\nBecause of the overhead of using a threadpool executor for something that *takes an instant* to run anyways?", "source": "issue", "type": "qa_comprehensive", "issue_number": 100}
{"instruction": "Gunicorn on Google Cloud Run get an 504 error status (Upstream Request Timeout)\n\nDetails:\nWhy my gunicorn always get a 504 error status code when I open my URL from Cloud Runabout 15 seconds for the first time, and after that the URL can be opened without an error. But after I leave it without opening the URL for about 30-60 minutes, it will return the 504 error again? Is my Gunicorn dead/shutdown? Because when i check it from my Cloud Run log, my gunicorn got a `Shutting down`, and I think my gunicorn was dead. So I need to keep my Gunicorn always on, but how can I make it to set my gunicorn always on?\r\n\r\nMy code at startup need to load the Machine Learning Model that got a 1 pickle about 100MB, in my case I need to load 6 pickle file (around 600mb++), and I use FastAPI for my API code.\r\n\r\nThis is how my pickle load :\r\n```python\r\n# Load all model\r\n@app.on_event(\"startup\")\r\nasync def load_model():\r\n    # Pathfile\r\n    pathfile_model = os.path.join(\"modules\", \"model/\")\r\n    pathfile_data = os.path.join(\"modules\", \"data/\")\r\n\r\n    start_time = time.time()\r\n\r\n    # Load Model\r\n    usedcar.price_engine_4w = {}\r\n    top5_brand = [\"honda\", \"toyota\", \"nissan\", \"suzuki\", \"daihatsu\"]\r\n    for i in top5_brand:\r\n        with open(pathfile_model + f'{i}_all_in_one.pkl', 'rb') as file:\r\n            usedcar.price_engine_4w[i] = pickle.load(file)\r\n    with open(pathfile_model + 'ex_Top5_all_in_one.pkl', 'rb') as file:\r\n        usedcar.price_engine_4w['non'] = pickle.load(file)\r\n\r\n    # Load Dataset Match\r\n    with open(pathfile_data + settings.DATA_LIST) as path:\r\n        usedcar.list_match_seva = pd.read_csv(path)\r\n\r\n    elapsed_time = time.time() - start_time\r\n\r\n    print(\"======================================\")\r\n    print(\"INFO  : Model loaded Succesfully\")\r\n    print(\"MODEL :\", usedcar.price_engine_4w)\r\n    print(\"ELAPSED MODEL TIME : \", elapsed_time)\r\n```\r\n\r\nHere are how my main.py code run :\r\n```python\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(app, host=\"0.0.0.0\", port=8080, log_level=\"info\", loop=asyncio)\r\n```\r\n\r\nThis is my Dockerfile :\r\n```Dockerfile\r\nFROM p", "input": "Repository: FastAPI\nLabels: ", "output": "Could you give us your Cloud Run configuration (or the command you make to deploy your service)? By default, Cloud Run instances start with 256 Mb of RAM so, given the size of your model, I suspect you run out of memory.", "source": "issue", "type": "qa_best_answer", "issue_number": 99}
{"instruction": "Provide a comprehensive answer to this question: Gunicorn on Google Cloud Run get an 504 error status (Upstream Request Timeout)", "input": "Why my gunicorn always get a 504 error status code when I open my URL from Cloud Runabout 15 seconds for the first time, and after that the URL can be opened without an error. But after I leave it without opening the URL for about 30-60 minutes, it will return the 504 error again? Is my Gunicorn dead/shutdown? Because when i check it from my Cloud Run log, my gunicorn got a `Shutting down`, and I think my gunicorn was dead. So I need to keep my Gunicorn always on, but how can I make it to set my gunicorn always on?\r\n\r\nMy code at startup need to load the Machine Learning Model that got a 1 pickle about 100MB, in my case I need to load 6 pickle file (around 600mb++), and I use FastAPI for my API code.\r\n\r\nThis is how my pickle load :\r\n```python\r\n# Load all model\r\n@app.on_event(\"startup\")\r\nasync def load_model():\r\n    # Pathfile\r\n    pathfile_model = os.path.join(\"modules\", \"model/\")\r\n    pathfile_data = os.path.join(\"modules\", \"data/\")\r\n\r\n    start_time = time.time()\r\n\r\n    # Load Model\r\n    usedcar.price_engine_4w = {}\r\n    top5_brand = [\"honda\", \"toyota\", \"nissan\", \"suzuki\", \"daihatsu\"]\r\n    for i in top5_brand:\r\n        with open(pathfile_model + f'{i}_all_in_one.pkl', 'rb') as file:\r\n            usedcar.price_engine_4w[i] = pickle.load(file)\r\n    with open(pathfile_model + 'ex_Top5_all_in_one.pkl', 'rb') as file:\r\n        usedcar.price_engine_4w['non'] = pickle.load(file)\r\n\r\n    # Load Dataset Match\r\n    with open(pathfile_data + settings.DATA_LIST) as path:\r\n        usedcar.list_match_seva = pd.read_csv(path)\r\n\r\n    elapsed_time = time.time() - start_time\r\n\r\n    print(\"======================================\")\r\n    print(\"INFO  : Model loaded Succesfully\")\r\n    print(\"MODEL :\", usedcar.price_engine_4w)\r\n    print(\"ELAPSED MODEL TIME : \", elapsed_time)\r\n```\r\n\r\nHere are how my main.py code run :\r\n```python\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(app, host=\"0.0.0.0\", port=8080, log_level=\"info\", loop=asyncio)\r\n```\r\n\r\nThis is my Dockerfile :\r\n```Dockerfile\r\nFROM p", "output": "Could you give us your Cloud Run configuration (or the command you make to deploy your service)? By default, Cloud Run instances start with 256 Mb of RAM so, given the size of your model, I suspect you run out of memory.\n\n---\n\n@frankie567 Oh sorry, I forgot to attach my Cloud Run Configuration:\r\n\r\nThis is for build and submit:\r\n```shell\r\ngcloud builds submit --tag gcr.io/subscription/priceengine-3rd-iteration\r\n```\r\n\r\nThis is for Cloud Run:\r\n```shell\r\ngcloud run deploy priceengine \\\r\n    --image=\"gcr.io/subscription/priceengine-3rd-iteration\" \\\r\n    --region asia-southeast2 \\\r\n    --allow-unauthenticated \\\r\n    --platform managed \\\r\n    --memory 4Gi \\\r\n    --cpu 2 \\\r\n    --set-env-vars \"SECRET_API_KEY=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\" \\\r\n    --set-env-vars \"PROJECT_ID=subscription\" \\\r\n    --add-cloudsql-instances database:asia-southeast2:price-engine \\\r\n    --set-env-vars \"DATA_LIST=20210105_Dictionary_List_Model_Variant.csv\" \\\r\n    --set-env-vars \"DATABASE_URL_API=postgres+pg8000://user:user@/api?unix_sock=/cloudsql/database:asia-southeast2:price-engine/.s.PGSQL.5432\" \\\r\n    --set-env-vars \"DATABASE_URL_CAR=postgres+pg8000://user:user@/api_database?unix_sock=/cloudsql/database:asia-southeast2:price-engine/.s.PGSQL.5432\" \\\r\n    --project=subscription\r\n```\r\n\r\nI've set my memory 4Gi and CPU 2 core.\n\n---\n\nThanks! May I suggest to increase Cloud Run timeout:\r\n\r\n* https://cloud.google.com/sdk/gcloud/reference/run/deploy?hl=fr#--timeout\r\n* https://cloud.google.com/run/docs/configuring/request-timeout\r\n\r\nIt clearly states that a 504 error is triggered when the timeout is reached.\n\n---\n\n@frankie567 So, from what I see, the default cloud run timeout is 300 sec, right? but in my case, when I accessing my URL Cloud Run, around 15 seconds it got a 504 error? whereas the timeout from the cloud run was much higher than 15 seconds (300 sec)?\n\n---\n\nYes, the default is 5 minutes. Should be sufficient for you but, you know, computers ðŸ˜…\r\n\r\nJust to be sure we understand on what's happening:\r\n1. You make a first HTTP request\r\n2. The service makes a cold start (first request received) and executes your startup event ; which takes around 15 seconds\r\n3. Then, the route logic is executed (it could be interesting that you post it also). **How much time does it take?**\r\n4. You get a response (right?)\r\n5. You wait 30-60 minutes. At this point, it's probable that Cloud Run shuts down the container because it doesn't receive traffic (https://cloud.google.com/run/docs/about-instance-autoscaling#idle-instance).\r\n6. You make a new HTTP request.\r\n7. You get the 504 timeout error.\r\n\r\nIs that so?", "source": "issue", "type": "qa_comprehensive", "issue_number": 99}
{"instruction": "Ability to define response_model with native typing\n\nDetails:\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass TypicalResponse(BaseModel):\r\n    msg: str\r\n    data: int\r\n\r\n\r\n@app.get(\"/add/{x}/{y}\")\r\nasync def add(x: int, y: int) -> TypicalResponse:\r\n    return TypicalResponse(msg=\"Done!\", data=x + y)\r\n```\r\n\r\n\r\n### Description\r\n\r\nOpen the automatic doc on this handler\r\nSee no output schema defined\r\nI would like to use typing \"-> *Type*\" for annotate response model.\r\nThis is good for simple handlers.\r\n\r\n### Wanted Solution\r\n\r\nI would like to autodoc parse this typing same as \"response_model=TypicalResponse\"\r\n\r\n### Wanted Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n# Same\r\nclass TypicalResponse(BaseModel):\r\n    msg: str\r\n    data: int\r\n\r\n\r\n@app.get(\"/add/{x}/{y}\")\r\nasync def add(x: int, y: int) -> TypicalResponse:\r\n    return TypicalResponse(msg=\"Done!\", data=x + y)\r\n```\r\n\r\n\r\n### Alternatives\r\n\r\nI use kwarg \"response_model\" as single alternative\r\nBut typing already defines the output model, necessary duplicate as result.\r\n\r\n### Operating System\r\n\r\nLinux\r\n\r\n### Operating System Details\r\n", "input": "Repository: FastAPI\nLabels: ", "output": "> May be dirty, so welcome to search another ways.\r\n\r\nNot at all dirty! I like the idea, it is more 'pythonic' and best of all its additional to current practice, so in the future it could be decided to phase it out. If you want, I can put a pull request together.", "source": "issue", "type": "qa_best_answer", "issue_number": 98}
{"instruction": "Provide a comprehensive answer to this question: Ability to define response_model with native typing", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass TypicalResponse(BaseModel):\r\n    msg: str\r\n    data: int\r\n\r\n\r\n@app.get(\"/add/{x}/{y}\")\r\nasync def add(x: int, y: int) -> TypicalResponse:\r\n    return TypicalResponse(msg=\"Done!\", data=x + y)\r\n```\r\n\r\n\r\n### Description\r\n\r\nOpen the automatic doc on this handler\r\nSee no output schema defined\r\nI would like to use typing \"-> *Type*\" for annotate response model.\r\nThis is good for simple handlers.\r\n\r\n### Wanted Solution\r\n\r\nI would like to autodoc parse this typing same as \"response_model=TypicalResponse\"\r\n\r\n### Wanted Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n# Same\r\nclass TypicalResponse(BaseModel):\r\n    msg: str\r\n    data: int\r\n\r\n\r\n@app.get(\"/add/{x}/{y}\")\r\nasync def add(x: int, y: int) -> TypicalResponse:\r\n    return TypicalResponse(msg=\"Done!\", data=x + y)\r\n```\r\n\r\n\r\n### Alternatives\r\n\r\nI use kwarg \"response_model\" as single alternative\r\nBut typing already defines the output model, necessary duplicate as result.\r\n\r\n### Operating System\r\n\r\nLinux\r\n\r\n### Operating System Details\r\n", "output": "> May be dirty, so welcome to search another ways.\r\n\r\nNot at all dirty! I like the idea, it is more 'pythonic' and best of all its additional to current practice, so in the future it could be decided to phase it out. If you want, I can put a pull request together.\n\n---\n\n> Not at all dirty! I like the idea, it is more 'pythonic' and best of all its additional to current practice, so in the future it could be decided to phase it out. If you want, I can put a pull request together.\r\n\r\nI am highly interested, why this \"**essential**\" feautre didn't imlemented earlier.\r\nMaybe some hidden problems in corner cases or something else.\r\n\r\nP.S. I think it's essential\n\n---\n\nYeah I am just thinking about that, for example when you have multiple return types (anyOf situation in OpenAPI), but that would still work actually. I'll run the test suite, see what happens.\r\n\r\nI don't agree that it is \"essential\" as the functionality is now already there, well documented and in use by literally thousands of projects, but  I do think it is more idiomatic.\n\n---\n\nWell the test work, if you take into account one edge case: if the endpoint is a `functools.partial` (of which I am of opinion is not really a use case IRL), one of the tests will fail as that type doesn't have an `__annotations__` dunder. Circumventing, this is code that is working: \r\n\r\n```python\r\n# self.response_model = response_model\r\nif type(endpoint) != functools.partial:\r\n    self.response_model = response_model or endpoint.__annotations__.get(\"return\")\r\nelse:\r\n    self.response_model = response_model or endpoint.func.__annotations__.get(\"return\")\r\n```\r\nIt's not a crazy idea. Though I am wondering, why is this in your opinion an essential feature?\n\n---\n\n> Well the test work, if you take into account one edge case: if the endpoint is a `functools.partial` (of which I am of opinion is not really a use case IRL), one of the tests will fail as that type doesn't have an `__annotations__` dunder. Circumventing, this is code that is working:\r\n> \r\n> ```python\r\n> # self.response_model = response_model\r\n> if type(endpoint) != functools.partial:\r\n>     self.response_model = response_model or endpoint.__annotations__.get(\"return\")\r\n> else:\r\n>     self.response_model = response_model or endpoint.func.__annotations__.get(\"return\")\r\n> ```\r\n> \r\n> It's not a crazy idea. Though I am wondering, why is this in your opinion an essential feature?\r\n\r\nThanks for help!\r\n\r\nEssential... \r\nWell, i mean it's because this functionality expected to be as basic (by any newbie at least).\r\n\r\nFastAPI have Pydantic native intergration, very pythonic style, you may think \"wow, nice framework!\"\r\nAnd boom! - This typing isn't working.\r\n\r\nNot critical, but still.", "source": "issue", "type": "qa_comprehensive", "issue_number": 98}
{"instruction": "Use third party class as property in pydantic schema\n\nDetails:\n**Describe the bug**\r\nI have a pydantic schema that needs a third party class (bson.objectid.ObjectID) as a property. For this reason I created a custom validator and encoder as per pydantic documentation.\r\n<details><summary>Code</summary>\r\n<p>\r\n\r\n```python\r\nfrom bson.objectid import ObjectId\r\nfrom pydantic import BaseModel\r\nfrom pydantic import validators\r\nfrom pydantic.errors import PydanticTypeError\r\nfrom pydantic.utils import change_exception\r\n\r\nclass ObjectIdError(PydanticTypeError):\r\n    msg_template = 'value is not a valid bson.objectid.ObjectId'\r\n\r\ndef object_id_validator(v) -> ObjectId:\r\n    with change_exception(ObjectIdError, ValueError):\r\n        v = ObjectId(v)\r\n    return v\r\n\r\ndef get_validators() -> None:\r\n    yield validators.not_none_validator\r\n    yield object_id_validator\r\n\r\nObjectId.__get_validators__ = get_validators\r\n\r\ndef encode_object_id(object_id: ObjectId):\r\n    return str(object_id)\r\n\r\nclass UserId(BaseModel):\r\n    object_id: ObjectId = None\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            ObjectId: encode_object_id\r\n        }\r\n\r\nclass User(UserId):\r\n    email: str\r\n    salt: str\r\n    hashed_password: str\r\n\r\n# Just for testing\r\nuser = User(object_id = ObjectId(), email=\"john.doe@example.com\", salt=\"12345678\", hashed_password=\"letmein\")\r\nprint(user.json())\r\n# Outputs:\r\n# {\"object_id\": \"5c7e424225e2971c8c548a86\", \"email\": \"john.doe@example.com\", \"salt\": \"12345678\", \"hashed_password\": \"letmein\"}\r\n```\r\n\r\n</p>\r\n</details></br>\r\n\r\nAs you can see at the bottom of the code, the serialization seems to work just fine. But when I use this schema as an argument (and/or response type) in API operations and then open the automatic documentation, I get presented with an error.\r\n\r\n<details><summary>Code</summary>\r\n<p>\r\n\r\n```python\r\nfrom bson import ObjectId\r\nfrom fastapi import FastAPI\r\nfrom user import User, UserId\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post(\"/user\", tags=[\"user\"], response_model=UserId)\r\ndef create_user(user: User):\r\n    # Create user", "input": "Repository: FastAPI\nLabels: ", "output": "Thanks for the report, sorry for the delay.\r\n\r\nI see/assume you are using MongoDB, right?\r\n\r\nI hope to check and debug it soon, but it might take a bit as I have to set up a stack with mongo (and I don't have a project generator with Mongo just yet).", "source": "issue", "type": "qa_best_answer", "issue_number": 97}
{"instruction": "Provide a comprehensive answer to this question: Use third party class as property in pydantic schema", "input": "**Describe the bug**\r\nI have a pydantic schema that needs a third party class (bson.objectid.ObjectID) as a property. For this reason I created a custom validator and encoder as per pydantic documentation.\r\n<details><summary>Code</summary>\r\n<p>\r\n\r\n```python\r\nfrom bson.objectid import ObjectId\r\nfrom pydantic import BaseModel\r\nfrom pydantic import validators\r\nfrom pydantic.errors import PydanticTypeError\r\nfrom pydantic.utils import change_exception\r\n\r\nclass ObjectIdError(PydanticTypeError):\r\n    msg_template = 'value is not a valid bson.objectid.ObjectId'\r\n\r\ndef object_id_validator(v) -> ObjectId:\r\n    with change_exception(ObjectIdError, ValueError):\r\n        v = ObjectId(v)\r\n    return v\r\n\r\ndef get_validators() -> None:\r\n    yield validators.not_none_validator\r\n    yield object_id_validator\r\n\r\nObjectId.__get_validators__ = get_validators\r\n\r\ndef encode_object_id(object_id: ObjectId):\r\n    return str(object_id)\r\n\r\nclass UserId(BaseModel):\r\n    object_id: ObjectId = None\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            ObjectId: encode_object_id\r\n        }\r\n\r\nclass User(UserId):\r\n    email: str\r\n    salt: str\r\n    hashed_password: str\r\n\r\n# Just for testing\r\nuser = User(object_id = ObjectId(), email=\"john.doe@example.com\", salt=\"12345678\", hashed_password=\"letmein\")\r\nprint(user.json())\r\n# Outputs:\r\n# {\"object_id\": \"5c7e424225e2971c8c548a86\", \"email\": \"john.doe@example.com\", \"salt\": \"12345678\", \"hashed_password\": \"letmein\"}\r\n```\r\n\r\n</p>\r\n</details></br>\r\n\r\nAs you can see at the bottom of the code, the serialization seems to work just fine. But when I use this schema as an argument (and/or response type) in API operations and then open the automatic documentation, I get presented with an error.\r\n\r\n<details><summary>Code</summary>\r\n<p>\r\n\r\n```python\r\nfrom bson import ObjectId\r\nfrom fastapi import FastAPI\r\nfrom user import User, UserId\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post(\"/user\", tags=[\"user\"], response_model=UserId)\r\ndef create_user(user: User):\r\n    # Create user", "output": "Thanks for the report, sorry for the delay.\r\n\r\nI see/assume you are using MongoDB, right?\r\n\r\nI hope to check and debug it soon, but it might take a bit as I have to set up a stack with mongo (and I don't have a project generator with Mongo just yet).\n\n---\n\nThanks for your response.\r\n\r\nYou are right, I'm using MongoDB.\r\nBut the problem isn't related to MongoDB, so I don't think you need it to debug the error.\r\n\r\nYou just need to install the following pip packages:\r\n- FastAPI\r\n- bson\r\n\r\nAnd then put the first code snippet in a module called `user.py` and the second one into some arbitrary module (e.g. `server.py`). When you then start the server and open the automatic documentation in your browser, you should be greeted by the error in the `Log` accordion above.\r\n\r\n_Note: I had to slightly modify my code snippets to make it possible to just copy-paste them._\n\n---\n\nExcellent, I'll use that to debug/develop it.\n\n---\n\nWas there a conclusion to this? Trying to parse mongos _id field is proving to be quite tricky unless i just delete it before returning the response\n\n---\n\n@Charlie-iProov not yet, but it's on the backlog.", "source": "issue", "type": "qa_comprehensive", "issue_number": 97}
{"instruction": "How to manage relationships in (pydantic) models\n\nDetails:\nEDIT: add proper greetings ðŸ™„ \r\n\r\nHi guys,\r\n\r\nMany thanks for this fantastic repo. It rocks. Not to mention https://dockerswarm.rocks/, I am now in the process to review all my projects from this base ðŸ¥‡ \r\n\r\n**Here is my question :**\r\n\r\nHow can I declare a one-to-many relationship in the pydantic models?\r\n\r\n**Context**\r\n\r\nI have a first object 'Rule', that is attached to a second 'City'.\r\n\r\nI have tried the following without success :\r\n\r\nrules.py\r\n```\r\nfrom app.models.cities import City\r\n\r\nclass RuleBase(BaseModel):\r\n    mode: Optional[RuleMode] = None\r\n    value: Optional[float] = None\r\n    city: Optional[City] = None\r\n```\r\n\r\n\r\ncities.py\r\n```\r\nclass City(BaseModel):\r\n    id: int\r\n    name: str\r\n    rules: Optional[List['Rule']]\r\n```\r\n\r\nError in tests:\r\n\r\n```\r\nImportError while loading conftest '/app/app/tests/conftest.py'.\r\napp/app/tests/conftest.py:4: in <module>\r\n    from app.models.cities import City, Rectangle, Point\r\napp/app/models/cities.py:50: in <module>\r\n    class City(BaseModel):\r\nusr/local/lib/python3.6/site-packages/pydantic/main.py:179: in __new__\r\n    config=config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:118: in infer\r\n    schema=schema,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:152: in prepare\r\n    self._populate_sub_fields()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in _populate_sub_fields\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in <listcomp>\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:210: in _create_sub_type\r\n    model_config=self.model_config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/si", "input": "Repository: FastAPI\nLabels: ", "output": "It won't answer your question exactly but I feel it's the same pattern where you have recursivity and declare an attribute of a model while that depends on another not yet created\r\n\r\nmy model looks like this :\r\n\r\n```\r\n<LoggerModel name='root' level=20 children=[<LoggerModel name='__main__' level=10 children=[]>, <LoggerModel name='__mp_maâ€¦>\r\n```\r\n\r\n```\r\nfrom __future__ import annotations\r\n\r\nfrom typing import ForwardRef, List, Optional\r\n\r\nfrom pydantic import BaseModel\r\n\r\nListLoggerModel = ForwardRef(\"List[LoggerModel]\")\r\n\r\nclass LoggerModel(BaseModel):\r\n    name: str\r\n    level: Optional[int]\r\n    children: ListLoggerModel = None\r\n\r\n\r\nLoggerModel.update_forward_refs()\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 96}
{"instruction": "Provide a comprehensive answer to this question: How to manage relationships in (pydantic) models", "input": "EDIT: add proper greetings ðŸ™„ \r\n\r\nHi guys,\r\n\r\nMany thanks for this fantastic repo. It rocks. Not to mention https://dockerswarm.rocks/, I am now in the process to review all my projects from this base ðŸ¥‡ \r\n\r\n**Here is my question :**\r\n\r\nHow can I declare a one-to-many relationship in the pydantic models?\r\n\r\n**Context**\r\n\r\nI have a first object 'Rule', that is attached to a second 'City'.\r\n\r\nI have tried the following without success :\r\n\r\nrules.py\r\n```\r\nfrom app.models.cities import City\r\n\r\nclass RuleBase(BaseModel):\r\n    mode: Optional[RuleMode] = None\r\n    value: Optional[float] = None\r\n    city: Optional[City] = None\r\n```\r\n\r\n\r\ncities.py\r\n```\r\nclass City(BaseModel):\r\n    id: int\r\n    name: str\r\n    rules: Optional[List['Rule']]\r\n```\r\n\r\nError in tests:\r\n\r\n```\r\nImportError while loading conftest '/app/app/tests/conftest.py'.\r\napp/app/tests/conftest.py:4: in <module>\r\n    from app.models.cities import City, Rectangle, Point\r\napp/app/models/cities.py:50: in <module>\r\n    class City(BaseModel):\r\nusr/local/lib/python3.6/site-packages/pydantic/main.py:179: in __new__\r\n    config=config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:118: in infer\r\n    schema=schema,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:152: in prepare\r\n    self._populate_sub_fields()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in _populate_sub_fields\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in <listcomp>\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:210: in _create_sub_type\r\n    model_config=self.model_config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/si", "output": "It won't answer your question exactly but I feel it's the same pattern where you have recursivity and declare an attribute of a model while that depends on another not yet created\r\n\r\nmy model looks like this :\r\n\r\n```\r\n<LoggerModel name='root' level=20 children=[<LoggerModel name='__main__' level=10 children=[]>, <LoggerModel name='__mp_maâ€¦>\r\n```\r\n\r\n```\r\nfrom __future__ import annotations\r\n\r\nfrom typing import ForwardRef, List, Optional\r\n\r\nfrom pydantic import BaseModel\r\n\r\nListLoggerModel = ForwardRef(\"List[LoggerModel]\")\r\n\r\nclass LoggerModel(BaseModel):\r\n    name: str\r\n    level: Optional[int]\r\n    children: ListLoggerModel = None\r\n\r\n\r\nLoggerModel.update_forward_refs()\r\n```\n\n---\n\nThanks for the hint!\r\n\r\nI got an ImportError with python 3.6.8\r\n\r\n```\r\n>>> from typing import ForwardRef\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nImportError: cannot import name 'ForwardRef'\r\n```\r\n\r\nTherefore I installed python 3.7.3 and that solved the issue.\r\n\r\nProbably something to report to https://github.com/tiangolo/full-stack-fastapi-postgresql, from which I started from :)\n\n---\n\nForwardref is a python 3 thing indeed, maybe there s a way to achieve the\nsame without, @tiangolo will know for sure !\n\nLe ven. 12 avr. 2019 Ã  7:59 PM, Manu <notifications@github.com> a Ã©crit :\n\n> Thanks for the hint!\n>\n> I got an ImportError with python 3.6.8\n>\n> >>> from typing import ForwardRef\n> Traceback (most recent call last):\n>   File \"<stdin>\", line 1, in <module>\n> ImportError: cannot import name 'ForwardRef'\n>\n> Therefore I installed python 3.7.3 and that solved the issue.\n>\n> Probably something to report to\n> https://github.com/tiangolo/full-stack-fastapi-postgresql, from which I\n> started from :)\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/153#issuecomment-482667182>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABDZPnowf6UmatNDVrS7YpgPPMgkXMCnks5vgMlkgaJpZM4csUX5>\n> .\n>\n\n---\n\n> Many thanks for this fantastic repo. It rocks. Not to mention https://dockerswarm.rocks/, I am now in the process to review all my projects from this base ðŸ¥‡\r\n\r\nThat's cool! Thanks!\r\n\r\nAs @euri10 says, for that case, ForwardRef is the way to go.\r\n\r\nThe caveat is that ForwardRef is Python 3.7 only. And Python 3.7 is not compatible yet with tools like Celery and TensorFlow :/\n\n---\n\nHi @tiangolo ,\r\n\r\nThanks for the confirmation ðŸ‘ \r\n\r\nFair enough for tensorflow. Celery seems to have catch up with python 3.7 and I have made a PR on the postgresql project Generator https://github.com/tiangolo/full-stack-fastapi-postgresql/pull/10 to test 3.7\r\n\r\nCould you have a look at it ? Would it effectively allow the ForwardRef and ease the definition of relationships on a pydantic levels, that would be a great added value for a postgresql project ðŸ˜‡ \r\n\r\nCheers,\r\nEmmanuel", "source": "issue", "type": "qa_comprehensive", "issue_number": 96}
{"instruction": "Hooks to modify request and response body\n\nDetails:\nHow can I modify request body before it's accessed by the api handler and response body before it's returned by the handler?\r\n\r\nIs it possible to implement a middleware or view hooks to change the request body and response body as needed?\r\n\r\n**Additional context**\r\nI am working on implementing API versioning with FastAPI using [Stripe's approach](https://stripe.com/blog/api-versioning). As I understand, it requires modifying the request body and response body depending on requested version of the API. I've been experimenting with different approaches but unable to find a clean way to do it. I've tried implementing it as a middleware but it doesn't seem like the right place. So my question is, are there any hooks that I can rely on to modify the incoming request and modify the response. Thanks!", "input": "Repository: FastAPI\nLabels: ", "output": "@tiangolo has made it really easy to work with the middleware - it's the way I'd handle this if I was doing it the way you are - of course using the mounts - it's really easy to handle /api/v1/... and /api/v2/... in the same application:\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/middleware/", "source": "issue", "type": "qa_best_answer", "issue_number": 95}
{"instruction": "Provide a comprehensive answer to this question: Hooks to modify request and response body", "input": "How can I modify request body before it's accessed by the api handler and response body before it's returned by the handler?\r\n\r\nIs it possible to implement a middleware or view hooks to change the request body and response body as needed?\r\n\r\n**Additional context**\r\nI am working on implementing API versioning with FastAPI using [Stripe's approach](https://stripe.com/blog/api-versioning). As I understand, it requires modifying the request body and response body depending on requested version of the API. I've been experimenting with different approaches but unable to find a clean way to do it. I've tried implementing it as a middleware but it doesn't seem like the right place. So my question is, are there any hooks that I can rely on to modify the incoming request and modify the response. Thanks!", "output": "@tiangolo has made it really easy to work with the middleware - it's the way I'd handle this if I was doing it the way you are - of course using the mounts - it's really easy to handle /api/v1/... and /api/v2/... in the same application:\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/middleware/\n\n---\n\nThank you for your input @wshayes. What I am trying to achieve is slightely different but your suggestion definitely pointed me in the right direction.\n\n---\n\nThanks for your help @wshayes !\r\n\r\n@nav you might also want to look at `APIRouter`s, with them you can add an API prefix to a whole set of routes/path operations: https://fastapi.tiangolo.com/tutorial/bigger-applications/#include-an-apirouter-with-a-prefix-tags-and-responses\n\n---\n\nThanks for the info @tiangolo but I am trying to avoid having to maintain multiple routes (versioning via routes i.e., /v1, /v2, etc). What I am trying to achieve is the ability to modify body of the request before it's processed by the route handler and response after it has been processed by the same handler. \r\n\r\nSo far I haven't had luck in finding an appropriate way to do it. It may be that the answer lies in Starlette since the request and response objects are handled by it. Additionally, request object is a child class of `collections.abc.Mapping` which is immutable so changing the request body might require a layer of abstraction.\n\n---\n\nHmm, by what you describe here in this last comment, it seems that you just need a middleware, as @wshayes was suggesting: https://fastapi.tiangolo.com/tutorial/middleware/", "source": "issue", "type": "qa_comprehensive", "issue_number": 95}
{"instruction": "Awaiting request body in middleware blocks the application\n\nDetails:\n**Describe the bug**\r\nDescription in the title\r\n\r\n**To Reproduce**\r\nMinimal code:\r\n```\r\nfrom typing import Mapping\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.requests import Request\r\n\r\napp = FastAPI()\r\n\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    print(await request.json())\r\n    return await call_next(request)\r\n\r\n@app.post(\"/\")\r\ndef read_root(arg: Mapping[str, str]):\r\n    return {\"Hello\": \"World\"}\r\n```\r\nRun the application with ```uvicorn <file>:app```\r\nTest the bug with ```curl localhost:8000 -d '{\"status\":\"ok\"}'```\r\n\r\n**Expected behavior**\r\nThe body of the request is printed, but the curl command stay pending for ever. If it is interrupted (Ctrl-C), the application then print ```ERROR: Error getting request body:```\r\n\r\n**Environment:**\r\n - OS: macOS\r\n - fastapi 0.33.0\r\n - python 3.7.3\r\n - (tested on Ubuntu too with Python 3.7.0 and 3.7.4)\r\n\r\n**Additional context**\r\n - When the route function has no body argument (```def read_root():```), there is no problem : the body is printed and the response send.\r\n - Thinking the issue was maybe coming from Starlette, I tested the following code, which works without issue. The bug seems thus to come from fastapi\r\n```\r\nfrom starlette.applications import Starlette\r\nfrom starlette.requests import Request\r\nfrom starlette.responses import JSONResponse\r\n\r\napp = Starlette()\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    print(await request.json())\r\n    return await call_next(request)\r\n\r\n\r\n@app.route('/', methods=[\"POST\"])\r\ndef homepage(request):\r\n    return JSONResponse({\"Hello\": \"World\"})\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "works fine for me copy-pasting the exact same thing, only had to comment `    print(await request.json())\r\n` which crashed the app\r\n\r\n```\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    # print(await request.json())\r\n    return await call_next(request)\r\n\r\n\r\n@app.post(\"/bug\")\r\ndef bug(arg: Mapping[str, str]):\r\n    return {\"Hello\": \"World\"}\r\n```\r\n```\r\n âœ— curl -d '{\"status\":\"ok\"}' http://localhost:8000/bug\r\n{\"Hello\":\"World\"}%             \r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 94}
{"instruction": "Provide a comprehensive answer to this question: Awaiting request body in middleware blocks the application", "input": "**Describe the bug**\r\nDescription in the title\r\n\r\n**To Reproduce**\r\nMinimal code:\r\n```\r\nfrom typing import Mapping\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.requests import Request\r\n\r\napp = FastAPI()\r\n\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    print(await request.json())\r\n    return await call_next(request)\r\n\r\n@app.post(\"/\")\r\ndef read_root(arg: Mapping[str, str]):\r\n    return {\"Hello\": \"World\"}\r\n```\r\nRun the application with ```uvicorn <file>:app```\r\nTest the bug with ```curl localhost:8000 -d '{\"status\":\"ok\"}'```\r\n\r\n**Expected behavior**\r\nThe body of the request is printed, but the curl command stay pending for ever. If it is interrupted (Ctrl-C), the application then print ```ERROR: Error getting request body:```\r\n\r\n**Environment:**\r\n - OS: macOS\r\n - fastapi 0.33.0\r\n - python 3.7.3\r\n - (tested on Ubuntu too with Python 3.7.0 and 3.7.4)\r\n\r\n**Additional context**\r\n - When the route function has no body argument (```def read_root():```), there is no problem : the body is printed and the response send.\r\n - Thinking the issue was maybe coming from Starlette, I tested the following code, which works without issue. The bug seems thus to come from fastapi\r\n```\r\nfrom starlette.applications import Starlette\r\nfrom starlette.requests import Request\r\nfrom starlette.responses import JSONResponse\r\n\r\napp = Starlette()\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    print(await request.json())\r\n    return await call_next(request)\r\n\r\n\r\n@app.route('/', methods=[\"POST\"])\r\ndef homepage(request):\r\n    return JSONResponse({\"Hello\": \"World\"})\r\n```", "output": "works fine for me copy-pasting the exact same thing, only had to comment `    print(await request.json())\r\n` which crashed the app\r\n\r\n```\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    # print(await request.json())\r\n    return await call_next(request)\r\n\r\n\r\n@app.post(\"/bug\")\r\ndef bug(arg: Mapping[str, str]):\r\n    return {\"Hello\": \"World\"}\r\n```\r\n```\r\n âœ— curl -d '{\"status\":\"ok\"}' http://localhost:8000/bug\r\n{\"Hello\":\"World\"}%             \r\n```\n\n---\n\n> works fine for me copy-pasting the exact same thing, only had to comment ` print(await request.json())` which crashed the app\r\n\r\nThat's exactly the point, the print statement, or more exactly the ``Ã wait``` inside blocks the application. The question is why ?\r\nAnd the other question, more important for me is : how can I log my request payload if i'm not able to await it in middleware ?\n\n---\n\nI think the middleware is unnecessary, should you want to get your payload just do:\r\n```\r\n@app.post(\"/bug\")\r\nasync def read_root(request: Request, arg: Mapping[str, str]):\r\n    print(await request.json())\r\n    return {\"Hello\": \"World\"}\r\n```\n\n---\n\n> I think the middleware is unnecessary, should you want to get your payload just do:\r\n\r\nBut i don't want to just get the payload of one request, i want to log the payloads of EVERY endpoints of my application. I don't want for that to add code in every endpoint, that's the purpose of a middleware.\n\n---\n\n@wyfo It appears this is sort of a Starlette problem -- if you try to access `request.json()` both inside of and outside of a middleware, you'll run into the same problem you are hitting with fastapi. This has to do with how the json is \"cached\" inside the starlette `Request` -- it isn't transferred to the next called asgi app.\r\n\r\nYou can reproduce the issue in the pure starlette example if you try to print the json contents inside your starlette endpoint:\r\n\r\n* change `def homepage(request):` it to use `async def`\r\n* add a line containing `print(await request.json())`\r\n\r\nFastAPI grabs the request.json() as part of it's request handling, which is why you run into the issue even without explicitly trying to if using FastAPI.\r\n\r\nIn order for this to be handled properly, I think it would require fixes in starlette; I feel like I've seen this discussed in starlette issues, but I'm not sure. I'll reference it if I find it. Even if you weren't using FastAPI, you'd face this issue if you didn't do something funny with to store the json after the first time you read it.\r\n\r\n-------\r\n\r\nOn the other hand, I think there is a neat workaround for this use case (that actually requires FastAPI), since you don't need your middleware to modify anything before the next handler receives it:\r\n\r\n```python\r\nfrom typing import Mapping\r\n\r\nfrom starlette.requests import Request\r\n\r\nfrom fastapi import FastAPI, APIRouter, Depends\r\n\r\napp = FastAPI()\r\napi_router = APIRouter()\r\n\r\n@api_router.post(\"/\")\r\ndef read_root(arg: Mapping[str, str]):\r\n    return {\"Hello\": \"World\"}\r\n\r\nasync def log_json(request: Request):\r\n    print(await request.json())\r\n\r\n# the trick here is including log_json in the dependencies:\r\napp.include_router(api_router, dependencies=[Depends(log_json)])\r\n```\r\nThis requires you to add all endpoints to `api_router` rather than `app`, but ensures that `log_json` will be called for every endpoint added to it (functioning very similarly to a middleware, given that all endpoints pass through `api_router`).\r\n\r\nThis works because no new `Request` instance will be created as part of the asgi request handling process, so the json read off by FastAPI's processing will still be cached on the request when the `log_json` function is called.", "source": "issue", "type": "qa_comprehensive", "issue_number": 94}
{"instruction": "Is this the correct way to save an uploaded file ?\n\nDetails:\nHello,\r\ni am trying to save an uploaded file to disk, the following code works correctly but i wonder if it is the correct way to do that.\r\n\r\n```\r\ndef parse(file: UploadFile = File(...)):\r\n\r\n    extension = os.path.splitext(file.filename)[1]\r\n    _, path = tempfile.mkstemp(prefix='parser_', suffix=extension)\r\n\r\n    with open(path, 'wb') as f:\r\n        f.write(file.file.read())\r\n\r\n```\r\nBasically i need to get the path of the temp file.\r\nI also have tried with .rollover() but file.file.name does not return the path (only the file descriptor)", "input": "Repository: FastAPI\nLabels: ", "output": "1)\r\n\r\nIt's not clear why you making a tempfile - UploadFile already does that under the hood if file size is larger then some configured amount.\r\n\r\n\r\n2)\r\n`file.file.read()` - this line can \"eat\" your entire memory if uploaded file size is larger than free memory space\r\n\r\nyou would need to read(chunk_size) in loop and write chunks to the copy", "source": "issue", "type": "qa_best_answer", "issue_number": 93}
{"instruction": "Provide a comprehensive answer to this question: Is this the correct way to save an uploaded file ?", "input": "Hello,\r\ni am trying to save an uploaded file to disk, the following code works correctly but i wonder if it is the correct way to do that.\r\n\r\n```\r\ndef parse(file: UploadFile = File(...)):\r\n\r\n    extension = os.path.splitext(file.filename)[1]\r\n    _, path = tempfile.mkstemp(prefix='parser_', suffix=extension)\r\n\r\n    with open(path, 'wb') as f:\r\n        f.write(file.file.read())\r\n\r\n```\r\nBasically i need to get the path of the temp file.\r\nI also have tried with .rollover() but file.file.name does not return the path (only the file descriptor)", "output": "1)\r\n\r\nIt's not clear why you making a tempfile - UploadFile already does that under the hood if file size is larger then some configured amount.\r\n\r\n\r\n2)\r\n`file.file.read()` - this line can \"eat\" your entire memory if uploaded file size is larger than free memory space\r\n\r\nyou would need to read(chunk_size) in loop and write chunks to the copy\n\n---\n\n@vitalik i must save the file on the disk. I know UploadFile stores the file if it is larger than free mem space but i have to save all the files i receive.\n\n---\n\nwell my point is - why you use tempfile ?...\r\n\r\nfrom you code looks like you do not close the tempfile handle correctly (your \"_\" variable)\r\n\r\nread more - https://www.logilab.org/blogentry/17873\n\n---\n\n@vitalik any suggestions of a good chunk size?\n\n---\n\n> @vitalik any suggestions of a good chunk size?\r\n\r\nto solve the out of memory issue the maximum chunk size should be:\r\n\r\n`chunk_size = free_ram / number_of_max_possible_concurent_requests`\r\n\r\nbut these days 10kb should be enough for any case I guess", "source": "issue", "type": "qa_comprehensive", "issue_number": 93}
{"instruction": "Body is always parsed as JSON regardless of media_type\n\nDetails:\n### Describe the bug\r\n\r\nThis is to continue the discussion at https://github.com/tiangolo/fastapi/issues/579#issuecomment-589263249. `Body` accepts an argument `media_type`, but regardless of the media_type Body is parsed as JSON. This is a problem for other media_types such as `plain/text`, `application/sql`, etc. And this is not compliant to [OpenAPI content](https://swagger.io/docs/specification/describing-responses/). Body should be able to represent plain text as `str` too.\r\n\r\nBasically I wish I could do this:\r\n```python\r\nrequest: str = Body(..., media_type='text/plain')\r\n```\r\nHowever, this produces 400 parsing error because Body is parsed as JSON anyway.\r\n\r\n### To Reproduce\r\n\r\n1. Create a file with:\r\n\r\n```Python\r\nfrom fastapi import FastAPI, Body\r\n\r\napp = FastAPI()\r\n\r\n@app.post(\"/\")\r\ndef read_root(body: str = Body(..., media_type='text/plain')):\r\n    return {\"I received:\": body}\r\n```\r\n\r\n2. Run the server.\r\n\r\n3. Then execute: `curl -d 'I want to print this' -H 'Content-Type: plain/text' http://localhost:8000` \r\n\r\n4. It returns {\"detail\":\"There was an error parsing the body\"}\r\n\r\n5. But I expected it to return `{\"I received\": \"I want to print this\"}`.\r\n\r\n### Expected behavior\r\n\r\nMy expectation is that the Body should be parsed based on the Content-Type header always. \r\n\r\n### Screenshots\r\n\r\nI think the information is quite comprehensive without screenshots.\r\n\r\n### Environment\r\n\r\n- OS: Ubuntu 18.04\r\n- FastAPI Version: 0.49.0\r\n- Python 3.7.4\r\n\r\n\r\n### Additional context\r\nThe associated part is: https://github.com/tiangolo/fastapi/blob/9c3c9b6e78768374868d690bc05918d58481e880/fastapi/routing.py#L114\r\n\r\nThis does not check Content-Type. My proposal is to fix it as \r\n```python\r\nif body_bytes and request.headers['Content-Type'] == 'application/json':\r\n# if body_bytes and request.headers.get('Content-Type', 'application/json'): # if the content type should be assumed.\r\n    body = await request.json()\r\nelse:\r\n    body = body_bytes\r\n```\r\n\r\nI can make a PR for this, but I wo", "input": "Repository: FastAPI\nLabels: ", "output": "Looking forward to this. I have a bunch of raw text (words from files) I want pumping into my api with a simple api as possible..", "source": "issue", "type": "qa_best_answer", "issue_number": 92}
{"instruction": "Provide a comprehensive answer to this question: Body is always parsed as JSON regardless of media_type", "input": "### Describe the bug\r\n\r\nThis is to continue the discussion at https://github.com/tiangolo/fastapi/issues/579#issuecomment-589263249. `Body` accepts an argument `media_type`, but regardless of the media_type Body is parsed as JSON. This is a problem for other media_types such as `plain/text`, `application/sql`, etc. And this is not compliant to [OpenAPI content](https://swagger.io/docs/specification/describing-responses/). Body should be able to represent plain text as `str` too.\r\n\r\nBasically I wish I could do this:\r\n```python\r\nrequest: str = Body(..., media_type='text/plain')\r\n```\r\nHowever, this produces 400 parsing error because Body is parsed as JSON anyway.\r\n\r\n### To Reproduce\r\n\r\n1. Create a file with:\r\n\r\n```Python\r\nfrom fastapi import FastAPI, Body\r\n\r\napp = FastAPI()\r\n\r\n@app.post(\"/\")\r\ndef read_root(body: str = Body(..., media_type='text/plain')):\r\n    return {\"I received:\": body}\r\n```\r\n\r\n2. Run the server.\r\n\r\n3. Then execute: `curl -d 'I want to print this' -H 'Content-Type: plain/text' http://localhost:8000` \r\n\r\n4. It returns {\"detail\":\"There was an error parsing the body\"}\r\n\r\n5. But I expected it to return `{\"I received\": \"I want to print this\"}`.\r\n\r\n### Expected behavior\r\n\r\nMy expectation is that the Body should be parsed based on the Content-Type header always. \r\n\r\n### Screenshots\r\n\r\nI think the information is quite comprehensive without screenshots.\r\n\r\n### Environment\r\n\r\n- OS: Ubuntu 18.04\r\n- FastAPI Version: 0.49.0\r\n- Python 3.7.4\r\n\r\n\r\n### Additional context\r\nThe associated part is: https://github.com/tiangolo/fastapi/blob/9c3c9b6e78768374868d690bc05918d58481e880/fastapi/routing.py#L114\r\n\r\nThis does not check Content-Type. My proposal is to fix it as \r\n```python\r\nif body_bytes and request.headers['Content-Type'] == 'application/json':\r\n# if body_bytes and request.headers.get('Content-Type', 'application/json'): # if the content type should be assumed.\r\n    body = await request.json()\r\nelse:\r\n    body = body_bytes\r\n```\r\n\r\nI can make a PR for this, but I wo", "output": "Looking forward to this. I have a bunch of raw text (words from files) I want pumping into my api with a simple api as possible..\n\n---\n\nI have the fix suggested above implemented, and it works in the project that I'm currently developing, but I'm unable to figure out a way to get all of the tests to pass. For example, I'm getting a test failure on `tests/test_tutorial/test_body/test_tutorial001.py` during `test_post_broken_body()`. The value of `response.status_code` is 422, which is causing the assertion of `assert response.status_code == expected_status` to fail. Any suggestions, anyone?\n\n---\n\nOh, that's why I cant have a YAML body in an endpoint...\r\n\r\nWith @jbkoh's proposal, I get this error in the tests:\r\n\r\n```\r\nfastapi/routing.py:151: error: Incompatible types in assignment (expression has type \"bytes\", variable has type \"Optional[FormData]\")\r\nFound 1 error in 1 file (checked 40 source files)\r\n```\n\n---\n\n@heitorPB What's the input here?\n\n---\n\n@jbkoh \r\nThis is the output of the `scripts/tests.sh` with the changes you suggested. I'm running on master branch.\r\n\r\nDid you run the tests?", "source": "issue", "type": "qa_comprehensive", "issue_number": 92}
{"instruction": "Error getting request body: The `python-multipart` library must be installed to use form parsing.\n\nDetails:\n(venv) G:\\projects\\python\\fastprojects>pip list\r\n\r\npython-dateutil   2.8.1\r\npython-multipart  0.0.5\r\nrope              0.17.0\r\n\r\n```\r\n@app.post('/token', tags=['safe'])\r\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\r\n  print('form_data', form_data)\r\n  user_dict = fake_users_db.get(form_data.username)\r\n  if not user_dict:\r\n    raise HTTPException(\r\n      status_code=400,\r\n      detail='Incorrect username or password'\r\n    )\r\n  user = UserInDB(**user_dict)\r\n  hashed_password = fake_hash_password(form_data.password)\r\n  if not hashed_password == user.hashed_password:\r\n    raise HTTPException(\r\n      status_code=400,\r\n      detail='Incorrect username or password'\r\n    )\r\n  return {'access_token': user.username, 'token_type': 'bearer'}\r\n\r\n```\r\n\r\nI don't know how to troubleshoot this problem", "input": "Repository: FastAPI\nLabels: ", "output": "@q98765543221 `pip install python-multipart`", "source": "issue", "type": "qa_best_answer", "issue_number": 91}
{"instruction": "Provide a comprehensive answer to this question: Error getting request body: The `python-multipart` library must be installed to use form parsing.", "input": "(venv) G:\\projects\\python\\fastprojects>pip list\r\n\r\npython-dateutil   2.8.1\r\npython-multipart  0.0.5\r\nrope              0.17.0\r\n\r\n```\r\n@app.post('/token', tags=['safe'])\r\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\r\n  print('form_data', form_data)\r\n  user_dict = fake_users_db.get(form_data.username)\r\n  if not user_dict:\r\n    raise HTTPException(\r\n      status_code=400,\r\n      detail='Incorrect username or password'\r\n    )\r\n  user = UserInDB(**user_dict)\r\n  hashed_password = fake_hash_password(form_data.password)\r\n  if not hashed_password == user.hashed_password:\r\n    raise HTTPException(\r\n      status_code=400,\r\n      detail='Incorrect username or password'\r\n    )\r\n  return {'access_token': user.username, 'token_type': 'bearer'}\r\n\r\n```\r\n\r\nI don't know how to troubleshoot this problem", "output": "@q98765543221 `pip install python-multipart`\n\n---\n\nUsing legacy setup.py install for python-multipart, since package 'wheel' is not installed.\r\nInstalling collected packages: python-multipart\r\n    Running setup.py install for python-multipart ... done\r\nSuccessfully installed python-multipart-0.0.5\r\n\r\n?[31mERROR?[0m:    Error getting request body: The `python-multipart` library must be installed to use form parsing\r\n.\r\n?[32mINFO?[0m:     127.0.0.1:13645 - \"?[1mPOST /token HTTP/1.1?[0m\" ?[31m400 Bad Request?[0m\r\n\r\n\r\n**A new project, same error**\n\n---\n\nAre you sure you're running your app in the same environment as the one you're installing `python-multipart`?\n\n---\n\n(venv) G:\\projects\\python\\fastapi2>uvicorn main:app --reload --port 8090\r\n?[32mINFO?[0m:     Uvicorn running on ?[1mhttp://127.0.0.1:8090?[0m (Press CTRL+C to quit)\r\n?[32mINFO?[0m:     Started reloader process [?[36m?[1m10000?[0m] using ?[36m?[1mstatreload?[0m\r\n?[32mINFO?[0m:     Started server process [?[36m14376?[0m]\r\n?[32mINFO?[0m:     Waiting for application startup.\r\n?[32mINFO?[0m:     Application startup complete.\r\n?[32mINFO?[0m:     127.0.0.1:12865 - \"?[1mGET /docs HTTP/1.1?[0m\" ?[32m200 OK?[0m\r\n?[32mINFO?[0m:     127.0.0.1:12865 - \"?[1mGET /openapi.json HTTP/1.1?[0m\" ?[32m200 OK?[0m\r\n?[31mERROR?[0m:    Error getting request body: The `python-multipart` library must be installed to use form parsing.\r\n?[32mINFO?[0m:     127.0.0.1:12873 - \"?[1mPOST /token HTTP/1.1?[0m\" ?[31m400 Bad Request?[0m\r\n?[31mERROR?[0m:    Could not stop child process 14376: [Errno 10] No child processes\r\n?[32mINFO?[0m:     Stopping reloader process [?[36m?[1m10000?[0m]\r\n\r\n(venv) G:\\projects\\python\\fastapi2>pip list\r\nPackage          Version\r\n---------------- -------\r\nfastapi          0.55.1\r\npip              20.1.1\r\npydantic         1.5.1\r\npython-multipart 0.0.5\r\nsetuptools       47.1.1\r\nsix              1.15.0\r\nstarlette        0.13.2\r\nwheel            0.34.2\n\n---\n\nThis problem occurs when I use a virtual environment and does not occur when I use a system environment, where the project was created using pyCharm", "source": "issue", "type": "qa_comprehensive", "issue_number": 91}
{"instruction": "How to Prevent the 307 Temporary Redirect When There's a Missing Trailing Slash\n\nDetails:\n### Description\r\n\r\nJust like the author of #731, I don't want a 307 temporary redirect which is automatically sent by uvicorn when there's a missing trailing slash in the api call. However, the solution given in that issue, i.e. route path like \"/?\" no longer works in the versions after this April as reported in in #1787, #1648 and else. Certain developers states this is an unexpected behavior and won't be supported in the future. In this case, I'm wondering what is the current elegant way to realize this. Or there's any way to handle both \"\" and \"/\" two paths simultaneously?", "input": "Repository: FastAPI\nLabels: ", "output": "You can have multiple decorators with path routes w/ and w/o the trailing slash.  Not incredibly elegant because then you get duplicate endpoints in your swagger docs.\r\n\r\nIt should be mentioned this is a Starlette issue. There are several issues about this in the repo, here is one of them: https://github.com/encode/starlette/issues/1008\r\n\r\nIf FastAPI could handle this, it might be to somehow identify and remove the duplicate entries in swagger docs.", "source": "issue", "type": "qa_best_answer", "issue_number": 90}
{"instruction": "Provide a comprehensive answer to this question: How to Prevent the 307 Temporary Redirect When There's a Missing Trailing Slash", "input": "### Description\r\n\r\nJust like the author of #731, I don't want a 307 temporary redirect which is automatically sent by uvicorn when there's a missing trailing slash in the api call. However, the solution given in that issue, i.e. route path like \"/?\" no longer works in the versions after this April as reported in in #1787, #1648 and else. Certain developers states this is an unexpected behavior and won't be supported in the future. In this case, I'm wondering what is the current elegant way to realize this. Or there's any way to handle both \"\" and \"/\" two paths simultaneously?", "output": "You can have multiple decorators with path routes w/ and w/o the trailing slash.  Not incredibly elegant because then you get duplicate endpoints in your swagger docs.\r\n\r\nIt should be mentioned this is a Starlette issue. There are several issues about this in the repo, here is one of them: https://github.com/encode/starlette/issues/1008\r\n\r\nIf FastAPI could handle this, it might be to somehow identify and remove the duplicate entries in swagger docs.\n\n---\n\n@falkben just use include_in_schema=False on one decorator.\n\n---\n\nYours answers together is a very good workaround!\n\n---\n\nHello! To extend the responses of @SebastianLuebke and @falkben, I think I have a good solution that minimizes the verbosity of doing double annotations. \r\n\r\nEffectively, the following code just wraps an endpoint in two calls to the router. \r\n\r\n```python\r\nclass RouterWrapper:\r\n    def __init__(self, _router: APIRouter):\r\n        self.router = _router\r\n        self.http_verbs = [\r\n            \"get\",\r\n            \"post\",\r\n            \"put\",\r\n            \"patch\",\r\n            \"delete\",\r\n            \"head\",\r\n            \"trace\",\r\n            \"websocket\",\r\n        ]\r\n\r\n    def __getattr__(self, verb):\r\n        if verb in self.http_verbs:\r\n\r\n            def _outer_callable(*router_args, **router_kwargs):\r\n\r\n                if len(router_args) == 1:\r\n                    (original_path,) = router_args\r\n                elif \"path\" in router_kwargs:\r\n                    original_path = router_kwargs.get(\"path\")\r\n                    router_kwargs.pop(\"path\")\r\n                else:\r\n                    raise ValueError(\"path argument isn't filled in\")\r\n\r\n                if original_path.endswith(\"/\"):\r\n                    alternate_path = original_path[:-1]\r\n                else:\r\n                    alternate_path = f\"{original_path}/\"\r\n\r\n                def _inner_callable(endpoint_func: Callable):\r\n                    router_annotation = getattr(self.router, verb)\r\n                    router_annotation(\r\n                        alternate_path, include_in_schema=False, **router_kwargs\r\n                    )(endpoint_func)\r\n                    return router_annotation(original_path, **router_kwargs)(\r\n                        endpoint_func\r\n                    )\r\n\r\n                return _inner_callable\r\n\r\n            return _outer_callable\r\n``` \r\nUsage: \r\n\r\n```python\r\nrouter = APIRouter()\r\nwrapper = RouterWrapper(router)\r\n\r\n\r\n@wrapper.get('/', response_model=SomePydanticModel)\r\ndef endpoint(\r\n    user: User = Depends(get_current_active_user),\r\n    *,\r\n    params: ListParams = Depends()\r\n):\r\n    ...\r\n```\r\nis equivalent to:\r\n```python\r\nrouter = APIRouter()\r\n\r\n\r\n@router.get('', response_model=SomePydanticModel, include_in_schema=False)\r\n@router.get('/', response_model=SomePydanticModel)\r\ndef endpoint(\r\n    user: User = Depends(get_current_active_user),\r\n    *,\r\n    params: ListParams = Depends()\r\n):\r\n    ...\r\n```\r\nI know this obfuscates the usage of the router, but I think it makes larger projects easier to handle.\r\n\r\nI also know that this is a frequently encountered problem based on reading the issues around it, so cc @tiangolo in case anyone else is grumbling about the redirect behavior, this seems like a reasonable shim for now.\n\n---\n\nJust wanted to share a similar solution to @nikhilshinday here:\r\n```python\r\nfrom typing import Any, Callable\r\n\r\nfrom fastapi import APIRouter as FastAPIRouter\r\nfrom fastapi.types import DecoratedCallable\r\n\r\n\r\nclass APIRouter(FastAPIRouter):\r\n    def api_route(\r\n        self, path: str, *, include_in_schema: bool = True, **kwargs: Any\r\n    ) -> Callable[[DecoratedCallable], DecoratedCallable]:\r\n        if path.endswith(\"/\"):\r\n            path = path[:-1]\r\n\r\n        alternate_path = path + \"/\"\r\n        super().api_route(alternate_path, include_in_schema=False, **kwargs)\r\n        return super().api_route(\r\n            path, include_in_schema=include_in_schema, **kwargs\r\n        )\r\n```\r\n\r\nUsage:\r\n```python\r\nfrom module.with.custom_class import APIRouter\r\n\r\nrouter = APIRouter()\r\n\r\n\r\n@router.get(\"/\", response_model=Foo)\r\ndef endpoint(bar: Bar = Depends()):\r\n    ...\r\n\r\n\r\n@router.post(\"\", response_model=Spam)\r\ndef another_endpoint(ham: Ham = Depends()):\r\n    ....\r\n```\r\n\r\nWhich translates to:\r\n```python\r\nfrom fastapi import APIRouter\r\n\r\nrouter = APIRouter()\r\n\r\n\r\n@router.get(\"/\", response_model=Foo, include_in_schema=False)\r\n@router.get(\"\", response_model=Foo)\r\ndef endpoint(bar: Bar = Depends()):\r\n    ...\r\n\r\n\r\n@router.post(\"/\", response_model=Spam, include_in_schema=False)\r\n@router.post(\"\", response_model=Spam)\r\ndef another_endpoint(ham: Ham = Depends()):\r\n    ....\r\n```\r\n\r\nThis will consistently display no trailing slashes in the docs, but it will also handle cases were the originally decorated function has `included_in_schema` as `False`. For example:\r\n```python\r\nfrom some.module import APIRouter\r\n\r\nrouter = APIRouter()\r\n\r\n\r\n@router.get(\"/\", response_model=Foo, include_in_schema=False)\r\ndef endpoint(bar: Bar = Depends()):\r\n    ...\r\n```\r\n\r\nWould translate to:\r\n```python\r\nfrom fastapi import APIRouter\r\n\r\nrouter = APIRouter()\r\n\r\n@router.get(\"\", response_model=Foo, include_in_schema=False)\r\n@router.get(\"/\", response_model=Foo, include_in_schema=False)\r\ndef endpoint(bar: Bar = Depends()):\r\n    ...\r\n```\r\n\r\nEdit: the implementation above has a bug, read on below for working implementations.", "source": "issue", "type": "qa_comprehensive", "issue_number": 90}
{"instruction": "Choosing the Right ASGI Server for Deploying FastAPI\n\nDetails:\nAccording to [ASGI Documentation](https://asgi.readthedocs.io/en/latest/implementations.html#servers) there are 3 ASGI Servers: [Daphne](https://github.com/django/daphne), [Hypercorn](https://pgjones.gitlab.io/hypercorn/index.html) and [Uvicorn](https://www.uvicorn.org/).\r\n\r\nFrom FastAPI's documentation to [Deploy FastAPI without Docker](https://fastapi.tiangolo.com/deployment/#alternatively-deploy-fastapi-without-docker) we could use Uvicorn or Hypercorn.\r\n\r\nBut which ASGI Server works best with FastAPI in terms of performance and scalability? A comparison chart or pros and cons between the available ASGI Servers would be helpful!\r\n\r\nAlso for Serverless Deployment what else should I consider?", "input": "Repository: FastAPI\nLabels: ", "output": "As per documentation, FastAPI is built on top of Starlette which itself is built on top of Uvicorn.\r\nThe performance difference between the ASGI servers is small and arguably is not important in the grand scheme of things (aka going from flask to fast).\r\nSo the suggestion would be to use Uvicorn since it is used by FastAPI under the hood.", "source": "issue", "type": "qa_best_answer", "issue_number": 89}
{"instruction": "Provide a comprehensive answer to this question: Choosing the Right ASGI Server for Deploying FastAPI", "input": "According to [ASGI Documentation](https://asgi.readthedocs.io/en/latest/implementations.html#servers) there are 3 ASGI Servers: [Daphne](https://github.com/django/daphne), [Hypercorn](https://pgjones.gitlab.io/hypercorn/index.html) and [Uvicorn](https://www.uvicorn.org/).\r\n\r\nFrom FastAPI's documentation to [Deploy FastAPI without Docker](https://fastapi.tiangolo.com/deployment/#alternatively-deploy-fastapi-without-docker) we could use Uvicorn or Hypercorn.\r\n\r\nBut which ASGI Server works best with FastAPI in terms of performance and scalability? A comparison chart or pros and cons between the available ASGI Servers would be helpful!\r\n\r\nAlso for Serverless Deployment what else should I consider?", "output": "As per documentation, FastAPI is built on top of Starlette which itself is built on top of Uvicorn.\r\nThe performance difference between the ASGI servers is small and arguably is not important in the grand scheme of things (aka going from flask to fast).\r\nSo the suggestion would be to use Uvicorn since it is used by FastAPI under the hood.\n\n---\n\n@ArcLightSlavik My application needs to be deployed as FaaS on [AWS Lambda](https://aws.amazon.com/lambda/). Previously I used [Zappa](https://github.com/Miserlou/Zappa) for deploying flask application. I've found something similar for this purpose named [Mangum](https://mangum.io/) and [Serverless](https://www.serverless.com/).\r\n\r\nWhen my application is built with any of the mentioned framework above, the total size gets about **~500 MB**! This raises an _**error**_ uploading to AWS Lambda (as [AWS Lambda limits](https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html) zip sizes to **50 MB**). [To solve this problem](https://github.com/Miserlou/Zappa#large-projects) I used a property named **`slim_handler`** on Zappa. Setting this to **`true`** would just upload a small handler to Lambda and load actual project from S3 at runtime.\r\n\r\nI couldn't find anything like this to do with Mangum or Serverless. Do you have any clue how to solve this problem?\n\n---\n\n@ShaonDey \r\nI have no experience with lambda/running application this way so this will be pure speculation.\r\nZappa says `including, but not limited to, WSGI web apps` which means gunicorn should be supported. So you can continue using Zappa but change gunicorn to use the uvicorn worker. This is the recommended behaviour for uvicorn. \r\nWill it work? probably but Â¯\\\\\\_(ãƒ„)\\_/Â¯\n\n---\n\n@ShaonDey FYI https://github.com/Miserlou/Zappa/issues/2159\n\n---\n\n@ShaonDey you might find https://www.serverless.com/plugins/serverless-python-requirements helpful for dealing with the size limitations in AWS Lambda when deploying using Serverless.", "source": "issue", "type": "qa_comprehensive", "issue_number": 89}
{"instruction": "What is the efficient way to get images using FAST API?\n\nDetails:\nHow to get an image using Fast API ?", "input": "Repository: FastAPI\nLabels: ", "output": "Get an image of/from what?", "source": "issue", "type": "qa_best_answer", "issue_number": 88}
{"instruction": "Provide a comprehensive answer to this question: What is the efficient way to get images using FAST API?", "input": "How to get an image using Fast API ?", "output": "Get an image of/from what?\n\n---\n\n```Python\r\n\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom fastapi.responses import FileResponse\r\nfrom pydantic import BaseModel\r\n\r\nimport numpy as np\r\n\r\nfrom PIL import Image\r\n\r\nimport shutil\r\n\r\nimport tensorflow as tf\r\nfrom object_detection.utils import label_map_util\r\nfrom object_detection.utils import visualization_utils as viz_utils\r\n\r\napp = FastAPI()\r\n\r\ndetect_fn = tf.saved_model.load('saved_model')\r\ncategory_index = label_map_util.create_category_index_from_labelmap(\"label_map.pbtxt\",use_display_name=True)\r\n\r\n\r\ndef load_image_into_numpy_array(path):\r\n    \"\"\"Load an image from file into a numpy array.\r\n\r\n    Puts image into numpy array to feed into tensorflow graph.\r\n    Note that by convention we put it into a numpy array with shape\r\n    (height, width, channels), where channels=3 for RGB.\r\n\r\n    Args:\r\n      path: the file path to the image\r\n\r\n    Returns:\r\n      uint8 numpy array with shape (img_height, img_width, 3)\r\n    \"\"\"\r\n    return np.array(Image.open(path))\r\n\r\n\r\ndef predict(image):\r\n     # The input needs to be a tensor, convert it using `tf.convert_to_tensor`.\r\n    image_np = np.array(image.file)\r\n    input_tensor = tf.convert_to_tensor(image_np)\r\n    # The model expects a batch of images, so add an axis with `tf.newaxis`.\r\n    input_tensor = input_tensor[tf.newaxis, ...]\r\n\r\n    # input_tensor = np.expand_dims(image_np, 0)\r\n    detections = detect_fn(input_tensor)\r\n\r\n    # All outputs are batches tensors.\r\n    # Convert to numpy arrays, and take index [0] to remove the batch dimension.\r\n    # We're only interested in the first num_detections.\r\n    num_detections = int(detections.pop('num_detections'))\r\n    \r\n    detections = {key: value[0, :num_detections].numpy()\r\n                   for key, value in detections.items()}\r\n    detections['num_detections'] = num_detections\r\n\r\n    # detection_classes should be ints.\r\n    detections['detection_classes'] = detections['detection_classes'].astype(np.int64)\r\n\r\n    image_np_with_detections = image_np.copy()\r\n\r\n    viz_utils.visualize_boxes_and_labels_on_image_array(\r\n          image_np_with_detections,\r\n          detections['detection_boxes'],\r\n          detections['detection_classes'],\r\n          detections['detection_scores'],\r\n          category_index,\r\n          use_normalized_coordinates=True,\r\n          max_boxes_to_draw=200,\r\n          min_score_thresh=.50,\r\n          agnostic_mode=False)\r\n    print(\"Detected\")\r\n    return image_np_with_detections\r\n\r\n\r\n@app.get(\"/\")\r\nasync def main():\r\n    return FileResponse(r\"misdo.jpg\")\r\n\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(image: UploadFile = File(...)):\r\n    predicted_image = predict(image)\r\n    return predicted_image```\r\n\r\n###ValueError: Failed to convert a NumPy array to a Tensor (Unsupported object type SpooledTemporaryFile).\n\n---\n\n> Get an image of/from what?\r\n\r\nCould you look at my code and suggest me a way to pass image and get inference from it?\n\n---\n\nYou can post an image using a form file upload, the rest is up to you.\n\nSee here: https://fastapi.tiangolo.com/tutorial/request-files/\n\n---\n\nIn what format would the uploaded image/file be?\r\n\r\n> You can post an image using a form file upload, the rest is up to you.\r\n> \r\n> See here: https://fastapi.tiangolo.com/tutorial/request-files/\r\n\r\nIn what format would the uploaded image/file be?", "source": "issue", "type": "qa_comprehensive", "issue_number": 88}
{"instruction": "Usage Graphene Subscriptions in FastAPI - Usage of Starlette-Graphene3 failed\n\nDetails:\nI wanted to make the subscriptions of graphene work in FastAPI. Unfortuantely I saw two other repositories who asked a similar thing and no conclusion made there. After some research I found the package starlette-graphene3, which makes uploading files and the subscription possible in Starlette. Due to the usage of the the GraphQLApp-class of starlette i thought, that this is going to work. Unfortunately there is a little problem when using starlette-graphene3 with fastapi:\r\n\r\n- When installing starlette-graphene3 I get the error: `ERROR: fastapi 0.63.0 has requirement starlette==0.13.6, but you'll have starlette 0.14.1 which is incompatible.`, which makes FastAPI not work anymore.\r\n\r\nMy questions are: \r\n- is it in planning to use a newer Starlette version, that starlette-graphene3 could be used\r\n- Any other way to make subscriptions work in FastAPI?\r\n\r\nWhen trying to use GraphQL  like in the documentation of FastAPI with subscriptions i get the error:\r\n`\"Subscriptions are not allowed. You will need to either use the subscribe function or pass allow_subscriptions=True\"`\r\n\r\nCode to reproduce:\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom starlette.graphql import GraphQLApp\r\nimport graphene\r\nimport asyncio\r\n\r\nclass Subscription(graphene.ObjectType):\r\n    count = graphene.Int(upto=graphene.Int())\r\n\r\n    async def subscribe_count(root, info, upto=3):\r\n        for i in range(upto):\r\n            yield i\r\n            await asyncio.sleep(1)\r\n\r\n\r\napp = FastAPI()\r\napp.add_route(\"/graphql\", GraphQLApp(schema=graphene.Schema(subscription=Subscription)))\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "For the reasoning behind pinning starlette to a specific version, see my comment here: https://github.com/tiangolo/fastapi/discussions/2532#discussioncomment-229069\r\n\r\nAs far as your question goes, what happens if you try the suggestions in the error regarding allowing subscriptions?", "source": "issue", "type": "qa_best_answer", "issue_number": 87}
{"instruction": "Provide a comprehensive answer to this question: Usage Graphene Subscriptions in FastAPI - Usage of Starlette-Graphene3 failed", "input": "I wanted to make the subscriptions of graphene work in FastAPI. Unfortuantely I saw two other repositories who asked a similar thing and no conclusion made there. After some research I found the package starlette-graphene3, which makes uploading files and the subscription possible in Starlette. Due to the usage of the the GraphQLApp-class of starlette i thought, that this is going to work. Unfortunately there is a little problem when using starlette-graphene3 with fastapi:\r\n\r\n- When installing starlette-graphene3 I get the error: `ERROR: fastapi 0.63.0 has requirement starlette==0.13.6, but you'll have starlette 0.14.1 which is incompatible.`, which makes FastAPI not work anymore.\r\n\r\nMy questions are: \r\n- is it in planning to use a newer Starlette version, that starlette-graphene3 could be used\r\n- Any other way to make subscriptions work in FastAPI?\r\n\r\nWhen trying to use GraphQL  like in the documentation of FastAPI with subscriptions i get the error:\r\n`\"Subscriptions are not allowed. You will need to either use the subscribe function or pass allow_subscriptions=True\"`\r\n\r\nCode to reproduce:\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom starlette.graphql import GraphQLApp\r\nimport graphene\r\nimport asyncio\r\n\r\nclass Subscription(graphene.ObjectType):\r\n    count = graphene.Int(upto=graphene.Int())\r\n\r\n    async def subscribe_count(root, info, upto=3):\r\n        for i in range(upto):\r\n            yield i\r\n            await asyncio.sleep(1)\r\n\r\n\r\napp = FastAPI()\r\napp.add_route(\"/graphql\", GraphQLApp(schema=graphene.Schema(subscription=Subscription)))\r\n```", "output": "For the reasoning behind pinning starlette to a specific version, see my comment here: https://github.com/tiangolo/fastapi/discussions/2532#discussioncomment-229069\r\n\r\nAs far as your question goes, what happens if you try the suggestions in the error regarding allowing subscriptions?\n\n---\n\nThanks for the fast response! Unfortunately I couldnt find the location where i can set this. The only solutions i found where directly dedicated to django. Do you have an idea where to set this setting?\n\n---\n\nWe can close this issue. I got it to work with Ariadne\n\n---\n\nThanks for the help here @Mause ! :clap: :bow: \r\n\r\nThanks for reporting back and closing the issue @Sharleedah  :+1:\n\n---\n\n> We can close this issue. I got it to work with Ariadne\r\n\r\nAny chance you can share the approach? I have been starting to research subscriptions for graphQL and python, specifically for FastApi and so far it looks as if the answers are pretty sparse. I'd love to help document how do implement them when we figure out a good pattern.", "source": "issue", "type": "qa_comprehensive", "issue_number": 87}
{"instruction": "The docs page layout is abnormal\n\nDetails:\nLocal service running with fastapi\r\n\r\nvisit docs page, the docs page layout is abnormal.", "input": "Repository: FastAPI\nLabels: ", "output": "I meet the same problem. The css of docs page seems not correct. It shows like this picture.\r\n\r\n![image](https://user-images.githubusercontent.com/26795087/118911679-2d68c180-b959-11eb-8d2a-0572bbe9e62b.png)\r\n\r\nIt seems because it add a button element to contains the origin content, after I check the difference of the correct doc pages.\r\n\r\n![image](https://user-images.githubusercontent.com/26795087/118914311-93efde80-b95d-11eb-9821-36151f1db2d4.png)", "source": "issue", "type": "qa_best_answer", "issue_number": 86}
{"instruction": "Provide a comprehensive answer to this question: The docs page layout is abnormal", "input": "Local service running with fastapi\r\n\r\nvisit docs page, the docs page layout is abnormal.", "output": "I meet the same problem. The css of docs page seems not correct. It shows like this picture.\r\n\r\n![image](https://user-images.githubusercontent.com/26795087/118911679-2d68c180-b959-11eb-8d2a-0572bbe9e62b.png)\r\n\r\nIt seems because it add a button element to contains the origin content, after I check the difference of the correct doc pages.\r\n\r\n![image](https://user-images.githubusercontent.com/26795087/118914311-93efde80-b95d-11eb-9821-36151f1db2d4.png)\n\n---\n\n![fastapi-swagger](https://user-images.githubusercontent.com/12136712/118913058-5722e800-b95b-11eb-9883-063e1b96c76f.png)\r\nsame problem! occured about 1 hour ago. before that, every thing is ok\n\n---\n\nswagger-ui-dist had a release 5 hours ago (3.49.0) which probably broke this, could you give the example endpoint where this issue comes up?\r\n\r\nAfter this you can do:\r\n\r\n```\r\nfrom fastapi import applications\r\nfrom fastapi.openapi.docs import get_swagger_ui_html\r\n\r\n\r\ndef swagger_monkey_patch(*args, **kwargs):\r\n    \"\"\"\r\n    Wrap the function which is generating the HTML for the /docs endpoint and \r\n    overwrite the default values for the swagger js and css.\r\n    \"\"\"\r\n    return get_swagger_ui_html(\r\n        *args, **kwargs,\r\n        swagger_js_url=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.48.0/swagger-ui-bundle.js\",\r\n        swagger_css_url=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.48.0/swagger-ui.css\"\r\n    )\r\n\r\n\r\n# Actual monkey patch\r\napplications.get_swagger_ui_html = swagger_monkey_patch\r\n\r\n\r\n# Your normal code ...\r\napp = FastAPI()\r\n```\n\n---\n\n@ArcLightSlavik monkey patch tested and working ok\n\n---\n\nThanks for the help @ArcLightSlavik ! :bow: \r\n\r\n@fz-gaojian, @leo-lee-4231, @dilless, or anyone else, could you please provide a simple example app that replicates the problem?\r\n\r\nI have tried several things and I can't replicate it locally yet, so I can't check what would solve the problem, what version of Swagger UI to pin, etc.\r\n\r\nIf I could replicate the problem, I would be able to release a quick version of FastAPI with the temporary pin to fix it. And probably also report it to Swagger UI's repo, as it seems it hasn't been reported yet.", "source": "issue", "type": "qa_comprehensive", "issue_number": 86}
{"instruction": "`TestClient.delete()` no longer supports payloads\n\nDetails:\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n\r\n#### App\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n@app.delete(\"/{user_id}\")\r\nasync def _delete_user(user_id: int):\r\n    return {}\r\n```\r\n\r\n\r\n#### Test\r\n\r\n```python\r\ndef test_delete_user(client: TestClient):\r\n    user_id = 123\r\n    response = client.delete(f\"/{user_id}\", json={\"validation_code\": 789})\r\n    assert response.status_code == 200\r\n```\r\n\r\n#### Error\r\n\r\n```\r\nTypeError: TestClient.delete() got an unexpected keyword argument 'json'\r\n```\r\n\r\n### Description\r\n\r\nAfter updating my application to FastAPI 0.87.0 I found out that the new `TestClient` does not support anymore any kind of payload in the `DELETE` method. Although the use of a body within DELETE requests is highly discouraged, it is not forbidden. Hence, we should find a way to allow a full retro-compatibility. \r\n\r\nAn idea would be to wrap the `httpx.delete` method used within the `TestClient` class in order to re-enable this feature. For this to happen, the solution described [here](https://www.python-httpx.org/compatibility/#request-body-on-http-methods) can be reused.\r\n  \r\n\r\n### Operating System\r\n\r\nmacOS\r\n\r\n### Operating System Details\r\n\r\n_No res", "input": "Repository: FastAPI\nLabels: ", "output": "[FastAPI's release 0.87.0](https://github.com/tiangolo/fastapi/releases/tag/0.87.0) upgrades Starlette to [0.21.0](https://github.com/encode/starlette/releases/tag/0.21.0) which replaces `requests` with `httpx`.\r\n`fastapi.testclient.TestClient` is only a shortcut for `starlette.testclient.TestClient`, thus, IMO, you should open an issue in Starlette's issues. You'll also probably receive an answer faster there.", "source": "issue", "type": "qa_best_answer", "issue_number": 85}
{"instruction": "Provide a comprehensive answer to this question: `TestClient.delete()` no longer supports payloads", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n\r\n#### App\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n@app.delete(\"/{user_id}\")\r\nasync def _delete_user(user_id: int):\r\n    return {}\r\n```\r\n\r\n\r\n#### Test\r\n\r\n```python\r\ndef test_delete_user(client: TestClient):\r\n    user_id = 123\r\n    response = client.delete(f\"/{user_id}\", json={\"validation_code\": 789})\r\n    assert response.status_code == 200\r\n```\r\n\r\n#### Error\r\n\r\n```\r\nTypeError: TestClient.delete() got an unexpected keyword argument 'json'\r\n```\r\n\r\n### Description\r\n\r\nAfter updating my application to FastAPI 0.87.0 I found out that the new `TestClient` does not support anymore any kind of payload in the `DELETE` method. Although the use of a body within DELETE requests is highly discouraged, it is not forbidden. Hence, we should find a way to allow a full retro-compatibility. \r\n\r\nAn idea would be to wrap the `httpx.delete` method used within the `TestClient` class in order to re-enable this feature. For this to happen, the solution described [here](https://www.python-httpx.org/compatibility/#request-body-on-http-methods) can be reused.\r\n  \r\n\r\n### Operating System\r\n\r\nmacOS\r\n\r\n### Operating System Details\r\n\r\n_No res", "output": "[FastAPI's release 0.87.0](https://github.com/tiangolo/fastapi/releases/tag/0.87.0) upgrades Starlette to [0.21.0](https://github.com/encode/starlette/releases/tag/0.21.0) which replaces `requests` with `httpx`.\r\n`fastapi.testclient.TestClient` is only a shortcut for `starlette.testclient.TestClient`, thus, IMO, you should open an issue in Starlette's issues. You'll also probably receive an answer faster there.\n\n---\n\n[https://github.com/encode/httpx/discussions/1587](url)\n\n---\n\n> [FastAPI's release 0.87.0](https://github.com/tiangolo/fastapi/releases/tag/0.87.0) upgrades Starlette to [0.21.0](https://github.com/encode/starlette/releases/tag/0.21.0) which replaces `requests` with `httpx`.\n> \n> `fastapi.testclient.TestClient` is only a shortcut for `starlette.testclient.TestClient`, thus, IMO, you should open an issue in Starlette's issues. You'll also probably receive an answer faster there.\n\nThanks @mbroton for the suggestion. I'm quite sure that if I open an issue on Starlette repo they'll tell me to go back to FastAPI repo ðŸ˜…\n\n---\n\n> [https://github.com/encode/httpx/discussions/1587](url)\n\nAs I already said, using payloads is highly discouraged but not forbidden! Furthermore, before this update everything worked fine\n\n---\n\n> > [https://github.com/encode/httpx/discussions/1587](url)\r\n> \r\n> As I already said, using payloads is highly discouraged but not forbidden! Furthermore, before this update everything worked fine\r\nYes, but `httpx` discourages it:(.  maybe you can use `request` instead of `delete`.", "source": "issue", "type": "qa_comprehensive", "issue_number": 85}
{"instruction": "How can I serve static files (html, js) easily?\n\nDetails:\n**Description**\r\n\r\n How can I serve static files (html, js) easily? Even though I don't need to inject python data, I attempted to do it with jinja and encountered issues.\r\n\r\n**Additional context**\r\n I tried something like: \r\n\r\n```\r\n@router.get(\"/webui/{file_name}\", name=\"webui.show\")\r\nasync def webui_show(file_name: str):\r\n    template = jinja2.get_template(file_name)\r\n    content = template.render()\r\n    return HTMLResponse(content=content, status_code=200)\r\n```\r\n\r\nWhere jinja2 was \r\n```\r\nloader = FileSystemLoader(web_dir(\"dist\"))\r\n# no escaping while deubing\r\njinja2 = Environment(loader=loader, autoescape=False)\r\n```\r\n\r\nBut I received an error message \"jinja2.exceptions.TemplateSyntaxError: Expected an expression, got 'end of print statement'\" when returning JavaScript files. What's sanctioned way to implement simple static file serving in fastapi? If so, it'd be nice to have some documentation around it.", "input": "Repository: FastAPI\nLabels: ", "output": "FastAPI being based on Starlette you may use it for that purpose: https://www.starlette.io/staticfiles/", "source": "issue", "type": "qa_best_answer", "issue_number": 84}
{"instruction": "Provide a comprehensive answer to this question: How can I serve static files (html, js) easily?", "input": "**Description**\r\n\r\n How can I serve static files (html, js) easily? Even though I don't need to inject python data, I attempted to do it with jinja and encountered issues.\r\n\r\n**Additional context**\r\n I tried something like: \r\n\r\n```\r\n@router.get(\"/webui/{file_name}\", name=\"webui.show\")\r\nasync def webui_show(file_name: str):\r\n    template = jinja2.get_template(file_name)\r\n    content = template.render()\r\n    return HTMLResponse(content=content, status_code=200)\r\n```\r\n\r\nWhere jinja2 was \r\n```\r\nloader = FileSystemLoader(web_dir(\"dist\"))\r\n# no escaping while deubing\r\njinja2 = Environment(loader=loader, autoescape=False)\r\n```\r\n\r\nBut I received an error message \"jinja2.exceptions.TemplateSyntaxError: Expected an expression, got 'end of print statement'\" when returning JavaScript files. What's sanctioned way to implement simple static file serving in fastapi? If so, it'd be nice to have some documentation around it.", "output": "FastAPI being based on Starlette you may use it for that purpose: https://www.starlette.io/staticfiles/\n\n---\n\n@3lpsy if you have a directory with static files, you can do as @euri10 suggests.\r\n\r\nIf you want to return some specific files (not necessarily from a fixed static directory), you can use a `FileResponse`: https://www.starlette.io/responses/#fileresponse\n\n---\n\nThanks for the responses @euri10  and @tiangolo. I was attaching the StaticFiles instance to the FastAPI() app incorrectly because I thought StaticFiles was a route but it's more of an ASGI app. For anyone else trying to do the same, you can do something like: \r\n\r\n```\r\napi = FastAPI(title=config.API_PROJECT_NAME, openapi_url=\"/api/v1/openapi.json\")\r\napi.mount(\"/static\", StaticFiles(directory=\"static\"))\r\n```\n\n---\n\nGreat!\r\n\r\nI still have to document that properly :smiley:\n\n---\n\nProbably I'm just too stupid but is there a way to make this work with the root path?\r\nIt works with /static but as soon as I try to use / as path for the static content it doesn't work anymore. I would like to use / for the static content and then something like /api as base for all the rest stuff.", "source": "issue", "type": "qa_comprehensive", "issue_number": 84}
{"instruction": "Debug Logging (Maybe just a n00b issue)\n\nDetails:\nDisclaimer: n00b to Python altogether. This is the first Python app that I've ever built.\r\n\r\nTrying to add formatted debug logging to the screen. I've gotten it to the point where the debug output shows twice. Once with the formatting applied, and once raw. \r\n\r\nScaled down code would be:\r\n```\r\nimport logging\r\n\r\nfrom fastapi import FastAPI\r\n\r\napi = FastAPI()\r\n\r\nlogger = logging.getLogger(\"api\")\r\nlogger.setLevel(logging.DEBUG)\r\n\r\nfh = logging.FileHandler(\"QED.log\")\r\nfh.setLevel(logging.ERROR)\r\nch = logging.StreamHandler()\r\nch.setLevel(logging.DEBUG)\r\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\nfh.setFormatter(formatter)\r\nch.setFormatter(formatter)\r\n\r\nlogger.addHandler(fh)\r\nlogger.addHandler(ch)\r\n\r\n@api.get(\"/\")\r\ndef read_root():\r\n    logger.debug(\"THIS IS A DEBUG LOG\")\r\n    logger.error(\"SOMETHING WENT VERY VERY WRONG\")\r\n    return {\"Hello\": \"World\"}\r\n```\r\nOutput to the console is:\r\n\r\n```\r\n2019-06-04 12:44:51,169 - api - DEBUG - THIS IS A DEBUG LOG\r\nDEBUG: THIS IS A DEBUG LOG\r\n2019-06-04 12:44:51,169 - api - ERROR - SOMETHING WENT VERY VERY WRONG\r\nERROR: SOMETHING WENT VERY VERY WRONG\r\nINFO: ('127.0.0.1', 55229) - \"GET / HTTP/1.1\" 200\r\n\r\n```\r\n\r\nSo, two things are happening.\r\n\r\n1. Seeing both the formatted message and the raw message.\r\n2. Seeing the ERROR level message in the console. That should only be written to QED.log\r\n\r\nThanks!", "input": "Repository: FastAPI\nLabels: ", "output": "Guessing that you started the app with uvicorn it looks like this is the\nlogs of it.\nYou can use the log-level flag, see\nhttps://www.uvicorn.org/settings/#logging\n\ne mar. 4 juin 2019 Ã  9:37 PM, Charlie Griefer <notifications@github.com> a\nÃ©crit :\n\n> Disclaimer: n00b to Python altogether. This is the first Python app that\n> I've ever built.\n>\n> Trying to add formatted debug logging to the screen. I've gotten it to the\n> point where the debug output shows twice. Once with the formatting applied,\n> and once raw.\n>\n> Scaled down code would be:\n>\n> import logging\n>\n> from fastapi import FastAPI\n>\n> api = FastAPI()\n>\n> logger = logging.getLogger(\"api\")\n> logger.setLevel(logging.DEBUG)\n>\n> fh = logging.FileHandler(\"QED.log\")\n> fh.setLevel(logging.DEBUG)\n> ch = logging.StreamHandler()\n> ch.setLevel(logging.DEBUG)\n> formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n> fh.setFormatter(formatter)\n> ch.setFormatter(formatter)\n>\n> logger.addHandler(fh)\n> logger.addHandler(ch)\n>\n> @api.get(\"/\")\n> def read_root():\n>     logger.debug(\"THIS IS A DEBUG LOG\")\n>     return {\"Hello\": \"World\"}\n>\n> Output to the console is:\n>\n> 2019-06-04 12:12:05,541 - api - DEBUG - THIS IS A DEBUG LOG\n> DEBUG: THIS IS A DEBUG LOG\n> INFO: ('127.0.0.1', 54183) - \"GET / HTTP/1.1\" 200\n>\n> Any advice to a Python n00b on how to remove that second unformatted debug?\n>\n> Thanks!\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/290?email_source=notifications&email_token=AAINSPTERYYFZ2BZEACYBSDPY2767A5CNFSM4HTAJOIKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GXTSYKA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPS7WED6ZLUAP6B7RK3PY2767ANCNFSM4HTAJOIA>\n> .\n>", "source": "issue", "type": "qa_best_answer", "issue_number": 83}
{"instruction": "Provide a comprehensive answer to this question: Debug Logging (Maybe just a n00b issue)", "input": "Disclaimer: n00b to Python altogether. This is the first Python app that I've ever built.\r\n\r\nTrying to add formatted debug logging to the screen. I've gotten it to the point where the debug output shows twice. Once with the formatting applied, and once raw. \r\n\r\nScaled down code would be:\r\n```\r\nimport logging\r\n\r\nfrom fastapi import FastAPI\r\n\r\napi = FastAPI()\r\n\r\nlogger = logging.getLogger(\"api\")\r\nlogger.setLevel(logging.DEBUG)\r\n\r\nfh = logging.FileHandler(\"QED.log\")\r\nfh.setLevel(logging.ERROR)\r\nch = logging.StreamHandler()\r\nch.setLevel(logging.DEBUG)\r\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\nfh.setFormatter(formatter)\r\nch.setFormatter(formatter)\r\n\r\nlogger.addHandler(fh)\r\nlogger.addHandler(ch)\r\n\r\n@api.get(\"/\")\r\ndef read_root():\r\n    logger.debug(\"THIS IS A DEBUG LOG\")\r\n    logger.error(\"SOMETHING WENT VERY VERY WRONG\")\r\n    return {\"Hello\": \"World\"}\r\n```\r\nOutput to the console is:\r\n\r\n```\r\n2019-06-04 12:44:51,169 - api - DEBUG - THIS IS A DEBUG LOG\r\nDEBUG: THIS IS A DEBUG LOG\r\n2019-06-04 12:44:51,169 - api - ERROR - SOMETHING WENT VERY VERY WRONG\r\nERROR: SOMETHING WENT VERY VERY WRONG\r\nINFO: ('127.0.0.1', 55229) - \"GET / HTTP/1.1\" 200\r\n\r\n```\r\n\r\nSo, two things are happening.\r\n\r\n1. Seeing both the formatted message and the raw message.\r\n2. Seeing the ERROR level message in the console. That should only be written to QED.log\r\n\r\nThanks!", "output": "Guessing that you started the app with uvicorn it looks like this is the\nlogs of it.\nYou can use the log-level flag, see\nhttps://www.uvicorn.org/settings/#logging\n\ne mar. 4 juin 2019 Ã  9:37 PM, Charlie Griefer <notifications@github.com> a\nÃ©crit :\n\n> Disclaimer: n00b to Python altogether. This is the first Python app that\n> I've ever built.\n>\n> Trying to add formatted debug logging to the screen. I've gotten it to the\n> point where the debug output shows twice. Once with the formatting applied,\n> and once raw.\n>\n> Scaled down code would be:\n>\n> import logging\n>\n> from fastapi import FastAPI\n>\n> api = FastAPI()\n>\n> logger = logging.getLogger(\"api\")\n> logger.setLevel(logging.DEBUG)\n>\n> fh = logging.FileHandler(\"QED.log\")\n> fh.setLevel(logging.DEBUG)\n> ch = logging.StreamHandler()\n> ch.setLevel(logging.DEBUG)\n> formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n> fh.setFormatter(formatter)\n> ch.setFormatter(formatter)\n>\n> logger.addHandler(fh)\n> logger.addHandler(ch)\n>\n> @api.get(\"/\")\n> def read_root():\n>     logger.debug(\"THIS IS A DEBUG LOG\")\n>     return {\"Hello\": \"World\"}\n>\n> Output to the console is:\n>\n> 2019-06-04 12:12:05,541 - api - DEBUG - THIS IS A DEBUG LOG\n> DEBUG: THIS IS A DEBUG LOG\n> INFO: ('127.0.0.1', 54183) - \"GET / HTTP/1.1\" 200\n>\n> Any advice to a Python n00b on how to remove that second unformatted debug?\n>\n> Thanks!\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/290?email_source=notifications&email_token=AAINSPTERYYFZ2BZEACYBSDPY2767A5CNFSM4HTAJOIKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GXTSYKA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPS7WED6ZLUAP6B7RK3PY2767ANCNFSM4HTAJOIA>\n> .\n>\n\n---\n\nHey euri10...\r\n\r\nThanks for the reply!\r\n\r\nI started the app with `uvicorn qed.api:api --reload`\r\n\r\n... so I don't _think_ I should be seeing uvicorn log items?\n\n---\n\nI think the uvicorn default is info and that is the\n\nINFO: ('127.0.0.1', 54183) - \"GET / HTTP/1.1\" 200\n\n\nLe mar. 4 juin 2019 Ã  10:05 PM, Charlie Griefer <notifications@github.com>\na Ã©crit :\n\n> Hey euri10...\n>\n> Thanks for the reply!\n>\n> I started the app with uvicorn qed.api:api --reload\n>\n> ... so I don't *think* I should be seeing uvicorn log items?\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/290?email_source=notifications&email_token=AAINSPTKKZLUP57RDYOXHULPY3DH3A5CNFSM4HTAJOIKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODW5WZHQ#issuecomment-498822302>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPVGCNMWAKDZPR3TT4TPY3DH3ANCNFSM4HTAJOIA>\n> .\n>\n\n---\n\nI'm ok with seeing that line specifically. But what I'm seeing is two debug lines:\r\n```\r\n2019-06-04 12:44:51,169 - api - DEBUG - THIS IS A DEBUG LOG\r\nDEBUG: THIS IS A DEBUG LOG\r\n```\r\n... and two error lines:\r\n```\r\n2019-06-04 12:44:51,169 - api - ERROR - SOMETHING WENT VERY VERY WRONG\r\nERROR: SOMETHING WENT VERY VERY WRONG\r\n```\r\n\r\nI should only be seeing one debug line (preferably the formatted one), and no error lines.\n\n---\n\nCould come from the root logger, you could check if handlers exist before\nadding them\nIf not that I'm out of ideas\n\nLe mar. 4 juin 2019 Ã  10:09 PM, Charlie Griefer <notifications@github.com>\na Ã©crit :\n\n> I'm ok with seeing that line specifically. But what I'm seeing is two\n> debug lines:\n>\n> 2019-06-04 12:44:51,169 - api - DEBUG - THIS IS A DEBUG LOG\n> DEBUG: THIS IS A DEBUG LOG\n>\n> ... and two error lines:\n>\n> 2019-06-04 12:44:51,169 - api - ERROR - SOMETHING WENT VERY VERY WRONG\n> ERROR: SOMETHING WENT VERY VERY WRONG\n>\n> I should only be seeing one debug line (preferably the formatted one), and\n> no error lines.\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/290?email_source=notifications&email_token=AAINSPVOB4IZJF4K2FEVVUDPY3DZBA5CNFSM4HTAJOIKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODW5XGHA#issuecomment-498823964>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPX5SJWXDCU5SMBYOPTPY3DZBANCNFSM4HTAJOIA>\n> .\n>", "source": "issue", "type": "qa_comprehensive", "issue_number": 83}
{"instruction": "Starlette 0.13 declarative support?\n\nDetails:\n**Description**\r\n\r\nIn the [upcoming release 0.13 of Starlette](https://github.com/encode/starlette/pull/704), a new declarative way for routing is introduced. At first, decorator style will still be supported but @tomchristie will somewhat *deprecate* it and remove it at some point in the future:\r\n\r\n> Yes, that's not going away here. However I _do think_ that I'm going to stop documenting it everywhere.\r\n> \r\n> Would I like to _eventually_ phase it out? _Possibly at some point in the future, maybe_. One of the key things I'm trying to emphasize in Starlette is a low-complexity stack, and components such as the `Starlette` and `Router` classes get _really_ simple if we move away from all the `.add_route(...)` and `@route()` futzing.\r\n\r\nAt the light of this, it seems that FastAPI needs to take a decision about this: either follow Starlette new convention or stick with the decorator style.\r\n\r\nPersonally, I tend to prefer the decorator style, which is similar to Flask or even Node's Express. However, as Starlette is one of the core component of FastAPI, I think it's better if it keeps up with its evolutions, for several reasons:\r\n\r\n* Keep the friction between the two frameworks as low as possible. Currently, if you know how to write a Starlette app, you know how to write a FastAPI one.\r\n* At some point, FastAPI will have to implement and maintain some wrapper code to convert imperative routing into the declarative style Starlette expects.\r\n\r\nThat's it! Just some quick thoughts in order to keep this subject in mind ðŸ™‚", "input": "Repository: FastAPI\nLabels: ", "output": "FWIW I donâ€™t think FastAPI necessarily needs to consider any changes here - itâ€™s fairly reasonable for higher level frameworks to adopt a different approach, while Starlette itself sticks to a as-plain-as-possible style.\r\n\r\n(Also I donâ€™t think thereâ€™s any changes needed to deal with the 0.12-0.13 update, tho Iâ€™m keen to double check that all before I hit go on it)\r\n\r\nI am *interested* in folks thoughts about the style change, tho. Itâ€™s an odd trade off, because Iâ€™m not sure it necessarily looks nicer, but I think itâ€™s a good thing for the project.\r\n\r\nFrom my POV itâ€™s a good thing for Starlette since it more simply expresses the mechanics, and is easier to override the behaviour (eg subclassing Route makes sense, whereas thatâ€™s more awkward to do if thereâ€™s a .route decorator on the app instance). Those are particularly valuable qualities for Starlette since it makes it easier to build different high level styles on top of it.", "source": "issue", "type": "qa_best_answer", "issue_number": 82}
{"instruction": "Provide a comprehensive answer to this question: Starlette 0.13 declarative support?", "input": "**Description**\r\n\r\nIn the [upcoming release 0.13 of Starlette](https://github.com/encode/starlette/pull/704), a new declarative way for routing is introduced. At first, decorator style will still be supported but @tomchristie will somewhat *deprecate* it and remove it at some point in the future:\r\n\r\n> Yes, that's not going away here. However I _do think_ that I'm going to stop documenting it everywhere.\r\n> \r\n> Would I like to _eventually_ phase it out? _Possibly at some point in the future, maybe_. One of the key things I'm trying to emphasize in Starlette is a low-complexity stack, and components such as the `Starlette` and `Router` classes get _really_ simple if we move away from all the `.add_route(...)` and `@route()` futzing.\r\n\r\nAt the light of this, it seems that FastAPI needs to take a decision about this: either follow Starlette new convention or stick with the decorator style.\r\n\r\nPersonally, I tend to prefer the decorator style, which is similar to Flask or even Node's Express. However, as Starlette is one of the core component of FastAPI, I think it's better if it keeps up with its evolutions, for several reasons:\r\n\r\n* Keep the friction between the two frameworks as low as possible. Currently, if you know how to write a Starlette app, you know how to write a FastAPI one.\r\n* At some point, FastAPI will have to implement and maintain some wrapper code to convert imperative routing into the declarative style Starlette expects.\r\n\r\nThat's it! Just some quick thoughts in order to keep this subject in mind ðŸ™‚", "output": "FWIW I donâ€™t think FastAPI necessarily needs to consider any changes here - itâ€™s fairly reasonable for higher level frameworks to adopt a different approach, while Starlette itself sticks to a as-plain-as-possible style.\r\n\r\n(Also I donâ€™t think thereâ€™s any changes needed to deal with the 0.12-0.13 update, tho Iâ€™m keen to double check that all before I hit go on it)\r\n\r\nI am *interested* in folks thoughts about the style change, tho. Itâ€™s an odd trade off, because Iâ€™m not sure it necessarily looks nicer, but I think itâ€™s a good thing for the project.\r\n\r\nFrom my POV itâ€™s a good thing for Starlette since it more simply expresses the mechanics, and is easier to override the behaviour (eg subclassing Route makes sense, whereas thatâ€™s more awkward to do if thereâ€™s a .route decorator on the app instance). Those are particularly valuable qualities for Starlette since it makes it easier to build different high level styles on top of it.\n\n---\n\n@tomchristie Thank you for your insights! I was just opening the debate here so that FastAPI maintainers can start to think about it :)\r\n\r\nRegarding the style change of Starlette, from my limited API developer point-of-view, I have to say that I *tend* to prefer the decorator style. I find very handy to have the path, the parameters, the HTTP method *and* the logic behind at the same place in the code.\r\n\r\nIf I may make the parallel with Django, I'm often frustrated to go back and forth between `views.py` and `urls.py`, often forgetting either the name of the params, the name of the route or struggle to find back the function associated.\r\n\r\nBut I understand your wish to limit the hidden magic behind the framework and to make it easier to extend.\n\n---\n\n> I am _interested_ in folks thoughts about the style change, tho. Itâ€™s an odd trade off, because Iâ€™m not sure it necessarily looks nicer, but I think itâ€™s a good thing for the project.\r\n> \r\n> From my POV itâ€™s a good thing for Starlette since it more simply expresses the mechanics, and is easier to override the behaviour (eg subclassing Route makes sense, whereas thatâ€™s more awkward to do if thereâ€™s a .route decorator on the app instance). Those are particularly valuable qualities for Starlette since it makes it easier to build different high level styles on top of it.\r\n\r\n@tomchristie: I wasn't sure initially because I've already gotten used to the Flask-like decorator magic, but the more I look at it, the more I believe it's a good thing, especially if the intention is to make Starlette an ASGI library rather than a full-on framework. The problem with decorators is that they require the app or router to always be in-scope, [which leads to odd patterns in Flask-land](https://flask.palletsprojects.com/en/1.1.x/patterns/appfactories/) to avoid depencency loops.\r\n\r\nMaking routes declarative at initialization time provides both a nice tree-like structure of the routes in the code itself, with very little magic to hide sub-application mount points, route subclasses, the evaluation order for each route, etc. Given those have some pretty important repercussions on how the resulting application will behave, I can definitely appreciate making this a bit more explicit.\r\n\r\nThe main problem I can see if FastAPI were to switch to this new model is that decorators clearly show which functions are intended to be routes and which aren't, which becomes important when you consider how dependency injection and parameters work, since those don't work with \"normal\" functions, only routes and the dependencies those route call (which are admittedly unmarked as well). Having the route declaration in a different file could be frustrating in that regard, though it might not be a problem in practice.\r\n\r\n**EDIT:** What I mean is like how, in the example below, the route (`@app.get(\"/users/{user_id}\")`) is coupled with the parameters passed to those functions (`def read_user(user_id: int)`), and a change in either one could break the route.\r\n\r\n```py\r\n@app.get(\"/users/{user_id}\", response_model=schemas.User)\r\ndef read_user(user_id: int, db: Session = Depends(get_db)):\r\n    db_user = crud.get_user(db, user_id=user_id)\r\n    if db_user is None:\r\n        raise HTTPException(status_code=404, detail=\"User not found\")\r\n    return db_user\r\n```\n\n---\n\n> and a change in either one could break the route.\r\n\r\nIndeed yeah. You *could* have the `Router` validate that path parameters *are always* present in the signature of endpoints, but there's likely gnarly cases there.\n\n---\n\n@tiangolo: Regarding what you said in [the starlette issue](https://github.com/encode/starlette/pull/704#issuecomment-550435460), FastAPI would also run into a problem with Response models, [which are specified in the route decorator](https://fastapi.tiangolo.com/tutorial/response-model/) to let functions return any object that can be serialized into this type, regardless of the actual type. Assuming that can't be integrated into the route function's signature in some way (maybe using metaclasses?) or moved to a new decorator, switching to a declarative model like this would also separate the type of the function's parameters from the type of its \"return value\".", "source": "issue", "type": "qa_comprehensive", "issue_number": 82}
{"instruction": "How does one setup a global timeout to all requests?\n\nDetails:\n### First check\r\n<details>\r\n\r\n<summary>\r\n<i>Ticked all checks, then first commitment choice</i>\r\n</summary>\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n\r\n</details>\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Description\r\n\r\nHi there, first of all many thanks for the work on FastAPI - this is now my goto framework for building Python-based REST APIs :)\r\n", "input": "Repository: FastAPI\nLabels: ", "output": "Hi @PLNech \r\n\r\nI am developing my own API using FastAPI and ran into the same \"problem\" as I am trying to add a global timeout to all my requests. \r\n\r\nI am still new to fastapi but from what I understand I believe the \"fastapi\" way to do so would be to use a middleware as they are designed to be ran at every request by nature. As I searched on how to do so I found this\r\n[gitter community thread](https://gitter.im/encode/community?at=5eee4457fa0c9221fc4ddeb4) and thought it could maybe help you. \r\n\r\nI am going to implement both your solution and the middleware based one and see which one I prefer and works best. Also note that there seems to be a problem with starlette 0.13.3 and higher so keep that in mind.\r\n\r\nAlso if you found a workaround by now I am more than interested.\r\n\r\nHope it helped you a bit", "source": "issue", "type": "qa_best_answer", "issue_number": 81}
{"instruction": "Provide a comprehensive answer to this question: How does one setup a global timeout to all requests?", "input": "### First check\r\n<details>\r\n\r\n<summary>\r\n<i>Ticked all checks, then first commitment choice</i>\r\n</summary>\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n\r\n</details>\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Description\r\n\r\nHi there, first of all many thanks for the work on FastAPI - this is now my goto framework for building Python-based REST APIs :)\r\n", "output": "Hi @PLNech \r\n\r\nI am developing my own API using FastAPI and ran into the same \"problem\" as I am trying to add a global timeout to all my requests. \r\n\r\nI am still new to fastapi but from what I understand I believe the \"fastapi\" way to do so would be to use a middleware as they are designed to be ran at every request by nature. As I searched on how to do so I found this\r\n[gitter community thread](https://gitter.im/encode/community?at=5eee4457fa0c9221fc4ddeb4) and thought it could maybe help you. \r\n\r\nI am going to implement both your solution and the middleware based one and see which one I prefer and works best. Also note that there seems to be a problem with starlette 0.13.3 and higher so keep that in mind.\r\n\r\nAlso if you found a workaround by now I am more than interested.\r\n\r\nHope it helped you a bit\n\n---\n\nHi @ZionStage, thanks for your message! I haven't found a workaround for now. Looking forward to continuing this conversation with you as we move forward on this topic :)\n\n---\n\nHey @PLNech \r\n\r\nI have implemented and tested the middleware and it seems to be working fine for me. Here is my code \r\n```python\r\nimport asyncio\r\nimport time\r\n\r\n\r\nimport pytest\r\n\r\nfrom fastapi import FastAPI, Request, Response, HTTPException\r\nfrom fastapi.responses import JSONResponse\r\nfrom httpx import AsyncClient\r\nfrom starlette.status import HTTP_504_GATEWAY_TIMEOUT\r\n\r\nREQUEST_TIMEOUT_ERROR = 1  # Threshold\r\n\r\napp = FastAPI() # Fake app\r\n\r\n# Creating a test path\r\n@app.get(\"/test_path\")\r\nasync def route_for_test(sleep_time: float) -> None:\r\n    await asyncio.sleep(sleep_time)\r\n\r\n# Adding a middleware returning a 504 error if the request processing time is above a certain threshold\r\n@app.middleware(\"http\")\r\nasync def timeout_middleware(request: Request, call_next):\r\n    try:\r\n        start_time = time.time()\r\n        return await asyncio.wait_for(call_next(request), timeout=REQUEST_TIMEOUT_ERROR)\r\n\r\n    except asyncio.TimeoutError:\r\n        process_time = time.time() - start_time\r\n        return JSONResponse({'detail': 'Request processing time excedeed limit',\r\n                             'processing_time': process_time},\r\n                            status_code=HTTP_504_GATEWAY_TIMEOUT)\r\n\r\n# Testing wether or not the middleware triggers\r\n@pytest.mark.asyncio\r\nasync def test_504_error_triggers():\r\n    # Creating an asynchronous client to test our asynchronous function\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\r\n        response = await ac.get(\"/test_path?sleep_time=3\")\r\n    content = eval(response.content.decode())\r\n    assert response.status_code == HTTP_504_GATEWAY_TIMEOUT\r\n    assert content['processing_time'] < 1.1\r\n\r\n# Testing middleware's consistency for requests having a processing time close to the threshold \r\n@pytest.mark.asyncio\r\nasync def test_504_error_consistency():\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\r\n        errors = 0\r\n        sleep_time = REQUEST_TIMEOUT_ERROR*0.9\r\n        for i in range(100):\r\n            response = await ac.get(\"/test_path?sleep_time={}\".format(sleep_time))\r\n            if response.status_code == HTTP_504_GATEWAY_TIMEOUT:\r\n                errors += 1\r\n        assert errors == 0\r\n\r\n# Testing middleware's precision\r\n# ie : Testing if it triggers when it should not and vice versa\r\n@pytest.mark.asyncio\r\nasync def test_504_error_precision():\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\r\n        should_trigger = []\r\n        should_pass = []\r\n        have_triggered = []\r\n        have_passed = []\r\n        for i in range(200):\r\n            sleep_time = 2 * REQUEST_TIMEOUT_ERROR * random.random()\r\n            if sleep_time < 1.1:\r\n                should_pass.append(i)\r\n            else:\r\n                should_trigger.append(i)\r\n            response = await ac.get(\"/test_path?sleep_time={}\".format(sleep_time))\r\n            if response.status_code == HTTP_504_GATEWAY_TIMEOUT:\r\n                have_triggered.append(i)\r\n            else:\r\n                have_passed.append(i)\r\n        assert should_trigger == have_triggered\r\n```\r\n\r\nI created three tests, the first one is designed to see wether or not the middleware actually does its job. \r\nThe second one is just there to check if there is any consistency problem with a single request. \r\nThe third one is here to check if I ran into the same issue raised in the [thread I mentioned](https://gitter.im/encode/community?at=5eee4457fa0c9221fc4ddeb4). \r\n\r\nAs far as I am concerned the first two tests passed without a problem.\r\n**However** the third one failed. There are requests that have triggered when they should not : \r\n```\r\nE           AssertionError: assert [3, 7, 10, 11, 12, 14, ...] == [3, 7, 8, 10, 11, 12, ...]\r\nE             At index 2 diff: 10 != 8\r\nE             Right contains 11 more items, first extra item: 165\r\n```\r\nThis is the issue mentioned in the thread. I'll downgrade to starlette 0.13.2 and see if the test pass.\r\n\r\nI might have made some mistakes or overlooked some things so I you ever have the chance to do some tests on your end let me know.\r\n\r\nCheers !\r\n\r\n_**Note :**_ \r\nI wrote `assert content['processing_time'] < 1.1` and not ` assert content['processing_time'] < 1` because the time I am monitoring isn't really the time it takes for python to execute the function (time to execute _asyncio.wait_for_ and catching the exception I guess) . I do not know the convention in this case.\n\n---\n\n@PLNech have you tried changing the timeout settings for gunicorn? By default it times out after 60 sec I believe but you can overwrite the settings.\r\n\r\nhttps://docs.gunicorn.org/en/latest/settings.html#timeout\r\nhttps://github.com/tiangolo/fastapi/issues/551\n\n---\n\n@ZionStage: thanks for sharing your implementation, this looks promising! I'll make some room in our backlog to give it a try in our next sprint and will let you know how it goes :)", "source": "issue", "type": "qa_comprehensive", "issue_number": 81}
{"instruction": "Python - FastAPI - Optional option for an UploadFile\n\nDetails:\n### First Check\r\n\r\n- [x] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom typing import Optional\r\nfrom fastapi import FastAPI, UploadFile, File\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    pass\r\n\r\n@app.post(\"/OptionOne\")\r\ndef pdf_foo1(file: Optional[UploadFile] = None):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionTwo\")\r\ndef pdf_foo2(file: Optional[UploadFile] = File(None)):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionThree\")\r\ndef pdf_foo3(file: UploadFile = File(None)):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionFour\")\r\ndef pdf_foo4(file: UploadFile = None):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionFive\")\r\ndef pdf_foo5(file: bytes = File(None)):\r\n    print(file)\r\n```\r\n\r\n\r\n### Description\r\n\r\n### Short Summary\r\nI am trying to do what I think is a simple thing but no internet solution has helped me so far, and I didn't find anything helpful yet in the issues.\r\n___\r\n### The desired solution:\r\nA route (function) that will accept an UploadFile but that will be optional, the user will not be have to provide it.\r\n\r\n### Current Case:\r\nIn the code there are 5 different cases I tried, all of them are not working as follows:\r\nCases 1, 3 Gives an 'ValueError: Value not declarabl", "input": "Repository: FastAPI\nLabels: ", "output": "Does the example from the docs work?\r\n\r\n```\r\nfrom typing import Optional\r\n\r\nfrom fastapi import FastAPI, File, UploadFile\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post(\"/files/\")\r\nasync def create_file(file: Optional[bytes] = File(None)):\r\n    if not file:\r\n        return {\"message\": \"No file sent\"}\r\n    else:\r\n        return {\"file_size\": len(file)}\r\n\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(file: Optional[UploadFile] = None):\r\n    if not file:\r\n        return {\"message\": \"No upload file sent\"}\r\n    else:\r\n        return {\"filename\": file.filename}\r\n```\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/request-files/#optional-file-upload", "source": "issue", "type": "qa_best_answer", "issue_number": 80}
{"instruction": "Provide a comprehensive answer to this question: Python - FastAPI - Optional option for an UploadFile", "input": "### First Check\r\n\r\n- [x] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom typing import Optional\r\nfrom fastapi import FastAPI, UploadFile, File\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    pass\r\n\r\n@app.post(\"/OptionOne\")\r\ndef pdf_foo1(file: Optional[UploadFile] = None):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionTwo\")\r\ndef pdf_foo2(file: Optional[UploadFile] = File(None)):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionThree\")\r\ndef pdf_foo3(file: UploadFile = File(None)):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionFour\")\r\ndef pdf_foo4(file: UploadFile = None):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionFive\")\r\ndef pdf_foo5(file: bytes = File(None)):\r\n    print(file)\r\n```\r\n\r\n\r\n### Description\r\n\r\n### Short Summary\r\nI am trying to do what I think is a simple thing but no internet solution has helped me so far, and I didn't find anything helpful yet in the issues.\r\n___\r\n### The desired solution:\r\nA route (function) that will accept an UploadFile but that will be optional, the user will not be have to provide it.\r\n\r\n### Current Case:\r\nIn the code there are 5 different cases I tried, all of them are not working as follows:\r\nCases 1, 3 Gives an 'ValueError: Value not declarabl", "output": "Does the example from the docs work?\r\n\r\n```\r\nfrom typing import Optional\r\n\r\nfrom fastapi import FastAPI, File, UploadFile\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post(\"/files/\")\r\nasync def create_file(file: Optional[bytes] = File(None)):\r\n    if not file:\r\n        return {\"message\": \"No file sent\"}\r\n    else:\r\n        return {\"file_size\": len(file)}\r\n\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(file: Optional[UploadFile] = None):\r\n    if not file:\r\n        return {\"message\": \"No upload file sent\"}\r\n    else:\r\n        return {\"filename\": file.filename}\r\n```\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/request-files/#optional-file-upload\n\n---\n\nThe upload assumes multipart form data: So when you see a JSON error; you might want to test your upload different.\n\n---\n\nHey, if you will look at the options I wrote there, there is an option like that one in the docs (OptionOne and part of OptionFive but OptionFive is not good for me anyway)\n\n---\n\nYes I saw that: no need to be rude.\r\nNot sure how you test your upload. via SWAGGER? via a JS frontend?\r\n\r\nI think I have used it like in the docs without probs. Used a more recent FastAPI though.\n\n---\n\nI'm sorry if it sounded rude, that was not my intention :)\r\n\r\nI'm testing it with Swagger (Locally and Webapp) and using the API links in a different program ( I will update that info as well )", "source": "issue", "type": "qa_comprehensive", "issue_number": 80}
{"instruction": "Inheritance and Polymorphism support\n\nDetails:\nActually, there is no support for Inheritance and Polymorphism as I know in fastapi : https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/\r\n\r\nMaybe annotations like that will do the job : \r\n\r\n```python\r\nclass Item(BaseModel):\r\n    type: str\r\n\r\nclass CarItem(Item):\r\n    type: str\r\n\r\nclass PlaneItem(Item):\r\n    type: str\r\n    size: str\r\n\r\n\r\n@app.post(\"/items/\", response_model=Item, one_of=[CarItem, PlaneItem], discriminator=\"type\")\r\nasync def create_item(*, item: Item):\r\n    return item\r\n```\r\n\r\nFor now, we need to define an `any` response_model since defining an `Item` response_model will remove the extra attributes during serialization.\r\n\r\nI'll try to hack using the based starlette api : https://www.starlette.io/schemas/ but comment are unused by fastapi (except for description)", "input": "Repository: FastAPI\nLabels: ", "output": "You can achieve what I think you need with standard Python `typing.Union`.\r\n\r\nI just added docs documenting it: https://fastapi.tiangolo.com/tutorial/extra-models/#union-or-anyof", "source": "issue", "type": "qa_best_answer", "issue_number": 79}
{"instruction": "Provide a comprehensive answer to this question: Inheritance and Polymorphism support", "input": "Actually, there is no support for Inheritance and Polymorphism as I know in fastapi : https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/\r\n\r\nMaybe annotations like that will do the job : \r\n\r\n```python\r\nclass Item(BaseModel):\r\n    type: str\r\n\r\nclass CarItem(Item):\r\n    type: str\r\n\r\nclass PlaneItem(Item):\r\n    type: str\r\n    size: str\r\n\r\n\r\n@app.post(\"/items/\", response_model=Item, one_of=[CarItem, PlaneItem], discriminator=\"type\")\r\nasync def create_item(*, item: Item):\r\n    return item\r\n```\r\n\r\nFor now, we need to define an `any` response_model since defining an `Item` response_model will remove the extra attributes during serialization.\r\n\r\nI'll try to hack using the based starlette api : https://www.starlette.io/schemas/ but comment are unused by fastapi (except for description)", "output": "You can achieve what I think you need with standard Python `typing.Union`.\r\n\r\nI just added docs documenting it: https://fastapi.tiangolo.com/tutorial/extra-models/#union-or-anyof\n\n---\n\nThanks for the response !!! \r\nIt works well on response thanks !! :+1: \r\n\r\nBut I also try with request body : \r\n```python\r\n\r\nclass Item(BaseModel):\r\n    type: str\r\n\r\nclass CarItem(Item):\r\n    type: str\r\n    wheel: int\r\n\r\nclass PlaneItem(Item):\r\n    type: str\r\n    size: str\r\n\r\n\r\nitem_union = Union[\r\n    CarItem,\r\n    PlaneItem\r\n]\r\n\r\n@app.post(\"/items/\", response_model=item_union)\r\nasync def create_item(*, item: item_union):\r\n    return item\r\n```\r\nseems to pick the first one, so drop the fields that is not on the second one. \r\n\r\nAny suggestion for this one ?\n\n---\n\nconfirmed with a set of tests, specifically `test_create_item_reverse`: https://github.com/euri10/fastapi/tree/post_union\r\nno time for looking further though ! maybe later :_)\r\nUnion order seems important\n\n---\n\nAfter some digging, it seems like it comes from [upstream](https://github.com/samuelcolvin/pydantic/blob/baade9a117c2973519024c31ee3e3c2a78f13984/pydantic/fields.py#L365-L373) \r\n```\r\n        if self.sub_fields:\r\n            errors = []\r\n            for field in self.sub_fields:\r\n                value, error = field.validate(v, values, loc=loc, cls=cls)\r\n                if error:\r\n                    errors.append(error)\r\n                else:\r\n                    return value, None\r\n            return v, errors\r\n```\r\nAs soon as one `sub_fields` of the Union is valid it returns.\r\n\r\nSo the CarItem in my test returns first as it's validated 1st.\r\n\r\nhttps://github.com/tiangolo/fastapi/blob/5a6e47bd495b7ee0bb2f4eb6dce570686c21c554/fastapi/dependencies/utils.py#L358\r\n\r\nNo idea if that's something to report upstream, that seems logic to consider valid a union as soon as one of its members is valid\r\n\r\nMaybe FastAPI should, if there are subfields, loop orderly on them and validate the body from there.\n\n---\n\nI think this case must be handle by fastapi.\r\n\r\nSince pydantic seems to be \"compliant\" with [jsonchema](https://pydantic-docs.helpmanual.io/#schema-creation) and jsonschema [don't support](https://json-schema.org/understanding-json-schema/reference/combining.html) true polymorphism : anyOf, allOf, but no [discriminator](https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/) like OpenApi support.\r\n\r\nIt seems to be more OpenApi feature than JsonSchema feature IMO.", "source": "issue", "type": "qa_comprehensive", "issue_number": 79}
{"instruction": "Websocket Broadcast\n\nDetails:\nIt would be awesome to have a feature to enable broadcast messages to all connected clients at specific websocket endpoint. \n\nThis function could be executed inside a api endpoint, for example after a post method that changes some persistent data, all connected clients at /ws will receive a message telling that it is time to refresh. \n\nCheers guys, this is a incredible project. Like so much!", "input": "Repository: FastAPI\nLabels: ", "output": "@rudmac If I understand your feature request properly, I think it is actually possible without too much effort by making use of an async generator. Admittedly, I still find async generators a little mind bending (this is the first time I've ever had a use for one \"in the wild\"), but I think seeing it in action makes it a little easier. Here's an implementation that makes a small extension of the tutorial app from https://fastapi.tiangolo.com/tutorial/websockets/ to add global push notifications:\r\n```python\r\nfrom typing import List\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.responses import HTMLResponse\r\nfrom starlette.websockets import WebSocket, WebSocketDisconnect\r\n\r\n\r\napp = FastAPI()\r\n\r\nhtml = \"\"\"\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>Chat</title>\r\n    </head>\r\n    <body>\r\n        <h1>WebSocket Chat</h1>\r\n        <form action=\"\" onsubmit=\"sendMessage(event)\">\r\n            <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/>\r\n            <button>Send</button>\r\n        </form>\r\n        <ul id='messages'>\r\n        </ul>\r\n        <script>\r\n            var ws = new WebSocket(\"ws://localhost:8000/ws\");\r\n            ws.onmessage = function(event) {\r\n                var messages = document.getElementById('messages')\r\n                var message = document.createElement('li')\r\n                var content = document.createTextNode(event.data)\r\n                message.appendChild(content)\r\n                messages.appendChild(message)\r\n            };\r\n            function sendMessage(event) {\r\n                var input = document.getElementById(\"messageText\")\r\n                ws.send(input.value)\r\n                input.value = ''\r\n                event.preventDefault()\r\n            }\r\n        </script>\r\n    </body>\r\n</html>\r\n\"\"\"\r\n\r\n\r\n@app.get(\"/\")\r\nasync def get():\r\n    return HTMLResponse(html)\r\n\r\n\r\nclass Notifier:\r\n    def __init__(self):\r\n        self.connections: List[WebSocket] = []\r\n        self.generator = self.get_notification_generator()\r\n\r\n    async def get_notification_generator(self):\r\n        while True:\r\n            message = yield\r\n            await self._notify(message)\r\n\r\n    async def push(self, msg: str):\r\n        await self.generator.asend(msg)\r\n\r\n    async def connect(self, websocket: WebSocket):\r\n        await websocket.accept()\r\n        self.connections.append(websocket)\r\n\r\n    def remove(self, websocket: WebSocket):\r\n        self.connections.remove(websocket)\r\n\r\n    async def _notify(self, message: str):\r\n        living_connections = []\r\n        while len(self.connections) > 0:\r\n            # Looping like this is necessary in case a disconnection is handled\r\n            # during await websocket.send_text(message)\r\n            websocket = self.connections.pop()\r\n            await websocket.send_text(message)\r\n            living_connections.append(websocket)\r\n        self.connections = living_connections\r\n\r\n\r\nnotifier = Notifier()\r\n\r\n\r\n@app.websocket(\"/ws\")\r\nasync def websocket_endpoint(websocket: WebSocket):\r\n    await notifier.connect(websocket)\r\n    try:\r\n        while True:\r\n            data = await websocket.receive_text()\r\n            await websocket.send_text(f\"Message text was: {data}\")\r\n    except WebSocketDisconnect:\r\n        notifier.remove(websocket)\r\n\r\n\r\n@app.get(\"/push/{message}\")\r\nasync def push_to_connected_websockets(message: str):\r\n    await notifier.push(f\"! Push notification: {message} !\")\r\n\r\n\r\n@app.on_event(\"startup\")\r\nasync def startup():\r\n    # Prime the push notification generator\r\n    await notifier.generator.asend(None)\r\n```\r\nIf you want to test it out, copy the above to a file `main.py` and start the server:\r\n```bash\r\nuvicorn main:app --reload\r\n```\r\nThen, open a few tabs at http://localhost:8000/ and send some chat messages (this should work the same as the base tutorial app). Then open http://localhost:8000/push/hello%20world and you should receive a push notification in each of your open tabs showing the message `hello world`.\r\n\r\n@tiangolo I'm a really big fan of this websockets integration, truly awesome stuff.", "source": "issue", "type": "qa_best_answer", "issue_number": 78}
{"instruction": "Provide a comprehensive answer to this question: Websocket Broadcast", "input": "It would be awesome to have a feature to enable broadcast messages to all connected clients at specific websocket endpoint. \n\nThis function could be executed inside a api endpoint, for example after a post method that changes some persistent data, all connected clients at /ws will receive a message telling that it is time to refresh. \n\nCheers guys, this is a incredible project. Like so much!", "output": "@rudmac If I understand your feature request properly, I think it is actually possible without too much effort by making use of an async generator. Admittedly, I still find async generators a little mind bending (this is the first time I've ever had a use for one \"in the wild\"), but I think seeing it in action makes it a little easier. Here's an implementation that makes a small extension of the tutorial app from https://fastapi.tiangolo.com/tutorial/websockets/ to add global push notifications:\r\n```python\r\nfrom typing import List\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.responses import HTMLResponse\r\nfrom starlette.websockets import WebSocket, WebSocketDisconnect\r\n\r\n\r\napp = FastAPI()\r\n\r\nhtml = \"\"\"\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>Chat</title>\r\n    </head>\r\n    <body>\r\n        <h1>WebSocket Chat</h1>\r\n        <form action=\"\" onsubmit=\"sendMessage(event)\">\r\n            <input type=\"text\" id=\"messageText\" autocomplete=\"off\"/>\r\n            <button>Send</button>\r\n        </form>\r\n        <ul id='messages'>\r\n        </ul>\r\n        <script>\r\n            var ws = new WebSocket(\"ws://localhost:8000/ws\");\r\n            ws.onmessage = function(event) {\r\n                var messages = document.getElementById('messages')\r\n                var message = document.createElement('li')\r\n                var content = document.createTextNode(event.data)\r\n                message.appendChild(content)\r\n                messages.appendChild(message)\r\n            };\r\n            function sendMessage(event) {\r\n                var input = document.getElementById(\"messageText\")\r\n                ws.send(input.value)\r\n                input.value = ''\r\n                event.preventDefault()\r\n            }\r\n        </script>\r\n    </body>\r\n</html>\r\n\"\"\"\r\n\r\n\r\n@app.get(\"/\")\r\nasync def get():\r\n    return HTMLResponse(html)\r\n\r\n\r\nclass Notifier:\r\n    def __init__(self):\r\n        self.connections: List[WebSocket] = []\r\n        self.generator = self.get_notification_generator()\r\n\r\n    async def get_notification_generator(self):\r\n        while True:\r\n            message = yield\r\n            await self._notify(message)\r\n\r\n    async def push(self, msg: str):\r\n        await self.generator.asend(msg)\r\n\r\n    async def connect(self, websocket: WebSocket):\r\n        await websocket.accept()\r\n        self.connections.append(websocket)\r\n\r\n    def remove(self, websocket: WebSocket):\r\n        self.connections.remove(websocket)\r\n\r\n    async def _notify(self, message: str):\r\n        living_connections = []\r\n        while len(self.connections) > 0:\r\n            # Looping like this is necessary in case a disconnection is handled\r\n            # during await websocket.send_text(message)\r\n            websocket = self.connections.pop()\r\n            await websocket.send_text(message)\r\n            living_connections.append(websocket)\r\n        self.connections = living_connections\r\n\r\n\r\nnotifier = Notifier()\r\n\r\n\r\n@app.websocket(\"/ws\")\r\nasync def websocket_endpoint(websocket: WebSocket):\r\n    await notifier.connect(websocket)\r\n    try:\r\n        while True:\r\n            data = await websocket.receive_text()\r\n            await websocket.send_text(f\"Message text was: {data}\")\r\n    except WebSocketDisconnect:\r\n        notifier.remove(websocket)\r\n\r\n\r\n@app.get(\"/push/{message}\")\r\nasync def push_to_connected_websockets(message: str):\r\n    await notifier.push(f\"! Push notification: {message} !\")\r\n\r\n\r\n@app.on_event(\"startup\")\r\nasync def startup():\r\n    # Prime the push notification generator\r\n    await notifier.generator.asend(None)\r\n```\r\nIf you want to test it out, copy the above to a file `main.py` and start the server:\r\n```bash\r\nuvicorn main:app --reload\r\n```\r\nThen, open a few tabs at http://localhost:8000/ and send some chat messages (this should work the same as the base tutorial app). Then open http://localhost:8000/push/hello%20world and you should receive a push notification in each of your open tabs showing the message `hello world`.\r\n\r\n@tiangolo I'm a really big fan of this websockets integration, truly awesome stuff.\n\n---\n\n> Cheers guys, this is a incredible project. Like so much!\r\n\r\n@rudmac I'm glad to hear that!\r\n\r\n---\r\n\r\n@dmontagu That's very interesting! And yes, it's mind-bending.\r\n\r\nThis should go in a blog post, a tutorial, a package or something :clap:\n\n---\n\n@dmontagu Very interesting approach. This is what I'm looking for. Thank you so much! I will let you know after implement this in my real application.\n\n---\n\n@dmontagu  When I try this, I get the error: `AttributeError: 'FastAPI' object has no attribute 'websocket'` on the @app.websocket(\"/ws\") decorator. Any clues why?\n\n---\n\nI did implement you code @dmontagu... works like a charm. Now I can broadcast a message to all webclients that itÂ´s time to refresh just after write some infos into database. The old code I was always looking for new data using queries, wasting resource....\r\n\r\nThank you bro! Cheers!", "source": "issue", "type": "qa_comprehensive", "issue_number": 78}
{"instruction": "UploadFile as a CSV file\n\nDetails:\n**Description**\r\nI'm trying to upload csv file to fastapi server. Is there any clear way to read fastapi File object and write it as a csv file?\r\n\r\nWhen I receive byte stream through the api, it's difficult to save it as a csv file since there could be comma anywhere in the string. \r\n\r\nOne solution could be write incoming bytes files to disk and load it back but I'm wondering if there is a direct approach without writing it into a disk", "input": "Repository: FastAPI\nLabels: ", "output": "there is a whole section in the docs about uploading files: https://fastapi.tiangolo.com/tutorial/request-files/\r\nif you want to avoid writing to the disk you can use the io module from standard library: https://docs.python.org/3/library/io.html\r\n\r\nedit : just note the io module is not async", "source": "issue", "type": "qa_best_answer", "issue_number": 77}
{"instruction": "Provide a comprehensive answer to this question: UploadFile as a CSV file", "input": "**Description**\r\nI'm trying to upload csv file to fastapi server. Is there any clear way to read fastapi File object and write it as a csv file?\r\n\r\nWhen I receive byte stream through the api, it's difficult to save it as a csv file since there could be comma anywhere in the string. \r\n\r\nOne solution could be write incoming bytes files to disk and load it back but I'm wondering if there is a direct approach without writing it into a disk", "output": "there is a whole section in the docs about uploading files: https://fastapi.tiangolo.com/tutorial/request-files/\r\nif you want to avoid writing to the disk you can use the io module from standard library: https://docs.python.org/3/library/io.html\r\n\r\nedit : just note the io module is not async\n\n---\n\nTo add to @euri10 's comment, I think you will probably want to make use of `UploadFile` to receive the csv file (as described in the docs @euri10 linked). This will transparently handle writing the file to disk if it is too large to store in memory, and has both a sync and async API for saving to disk if desired.\r\n\r\nMoreover, If you want to load the csv data _without_ saving to disk, I believe it should be possible to pass it directly to `pandas.read_csv` via:\r\n\r\n```python\r\nimport pandas as pd\r\n\r\n@app.post(\"/uploadcsv/\")\r\ndef upload_csv(csv_file: UploadFile = File(...)):\r\n    dataframe = pd.read_csv(csv_file.file)\r\n    # do something with dataframe here (?)\r\n    return {\"filename\": file.filename}\r\n```\r\n\r\n(I haven't tested this, but it seems like it should be supported based on the [pandas docs](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-read-csv-table). Other csv readers may require other modifications.)\n\n---\n\nGreat answers @euri10 and @dmontagu ! Thanks a lot for your help here! :cake: \r\n\r\n@enod yep, right what they said :smile: :point_up:\n\n---\n\nThanks a lot @dmontagu  for the help and it solved the issue quickly :+1: :100:\n\n---\n\n```\r\n@app.post(\"/uploadfile\")\r\nasync def check(file: UploadFile = File(...)):\r\n \r\n    if file.filename.endswith('.csv'):\r\n        df = pd.read_csv(file.file)\r\n        df_head = df.head(5)\r\n        df_tail = df.tail(5)\r\n        # cli.set(\"userId\",str(df))\r\n        head = df_head.to_json(orient='records')\r\n        tail = df_tail.to_json(orient='records')\r\n        head = eval(head)\r\n        tail = eval(tail)\r\n        # create_db_table()\r\n        insert_data(uuid=1,itemname=file.file.read())\r\n        # final return\r\n        return {\r\n            \"head\":head,\r\n            \"tail\":tail\r\n        }\r\n\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 77}
{"instruction": "Elegant way to exclude middleware in unit tests?\n\nDetails:\n**Description**\r\n\r\nIs it possible to disable or override middleware in unit tests?\r\n\r\n**Additional context**\r\n\r\nI have written some middleware to obtain a database pool connection and release it when the request is done.  I'm using asyncpg directly for this as follows:\r\n\r\n```python\r\n@app.middleware(\"http\")\r\nasync def database_middleware(request: Request, call_next):\r\n    conn = None\r\n    try:\r\n        conn = await database_pool.acquire()\r\n\r\n        try:\r\n            await conn.fetch(\"SELECT 1\")\r\n        except ConnectionDoesNotExistError:\r\n            conn = await database_pool.acquire()\r\n\r\n        request.state.db = conn\r\n        return await call_next(request)\r\n    except (PostgresConnectionError, OSError) as e:\r\n        logger.error(\"Unable to connect to the database: %s\", e)\r\n        return Response(\r\n            \"Unable to connect to the database.\", status_code=HTTP_500_INTERNAL_SERVER_ERROR\r\n        )\r\n    except SyntaxOrAccessError as e:\r\n        logger.error(\"Unable to execute query: %s\", e)\r\n        return Response(\r\n            \"Unable to execute the required query to obtain data from the database.\",\r\n            status_code=HTTP_500_INTERNAL_SERVER_ERROR,\r\n        )\r\n    finally:\r\n        if conn:\r\n            await database_pool.release(conn)\r\n```\r\n\r\nI then have a little `get_db` dependency injection which is similar to the docs:\r\n\r\n```python\r\ndef get_db(request: Request):\r\n    return request.state.db\r\n```\r\n\r\nI'd like to mock my database in my unit tests so I can verify that I'm building the correct SQL given the appropriate params.\r\n\r\nI've setup a pytest fixture to mock the database as follows:\r\n\r\n```python\r\n@pytest.fixture(scope=\"function\")\r\ndef db_mock(request):\r\n    def fin():\r\n        del app.dependency_overrides[get_db]\r\n\r\n    db_mock = mock.MagicMock()\r\n    app.dependency_overrides[get_db] = lambda: db_mock\r\n\r\n    request.addfinalizer(fin)\r\n    return db_mock\r\n```\r\n\r\nThis works perfectly when the middleware is disabled.  However, when it's enabled", "input": "Repository: FastAPI\nLabels: ", "output": "I'd try to use asynctest CoroutineMock instead of MagicMock\r\nedit: ha sorry your mock is a on a def", "source": "issue", "type": "qa_best_answer", "issue_number": 76}
{"instruction": "Provide a comprehensive answer to this question: Elegant way to exclude middleware in unit tests?", "input": "**Description**\r\n\r\nIs it possible to disable or override middleware in unit tests?\r\n\r\n**Additional context**\r\n\r\nI have written some middleware to obtain a database pool connection and release it when the request is done.  I'm using asyncpg directly for this as follows:\r\n\r\n```python\r\n@app.middleware(\"http\")\r\nasync def database_middleware(request: Request, call_next):\r\n    conn = None\r\n    try:\r\n        conn = await database_pool.acquire()\r\n\r\n        try:\r\n            await conn.fetch(\"SELECT 1\")\r\n        except ConnectionDoesNotExistError:\r\n            conn = await database_pool.acquire()\r\n\r\n        request.state.db = conn\r\n        return await call_next(request)\r\n    except (PostgresConnectionError, OSError) as e:\r\n        logger.error(\"Unable to connect to the database: %s\", e)\r\n        return Response(\r\n            \"Unable to connect to the database.\", status_code=HTTP_500_INTERNAL_SERVER_ERROR\r\n        )\r\n    except SyntaxOrAccessError as e:\r\n        logger.error(\"Unable to execute query: %s\", e)\r\n        return Response(\r\n            \"Unable to execute the required query to obtain data from the database.\",\r\n            status_code=HTTP_500_INTERNAL_SERVER_ERROR,\r\n        )\r\n    finally:\r\n        if conn:\r\n            await database_pool.release(conn)\r\n```\r\n\r\nI then have a little `get_db` dependency injection which is similar to the docs:\r\n\r\n```python\r\ndef get_db(request: Request):\r\n    return request.state.db\r\n```\r\n\r\nI'd like to mock my database in my unit tests so I can verify that I'm building the correct SQL given the appropriate params.\r\n\r\nI've setup a pytest fixture to mock the database as follows:\r\n\r\n```python\r\n@pytest.fixture(scope=\"function\")\r\ndef db_mock(request):\r\n    def fin():\r\n        del app.dependency_overrides[get_db]\r\n\r\n    db_mock = mock.MagicMock()\r\n    app.dependency_overrides[get_db] = lambda: db_mock\r\n\r\n    request.addfinalizer(fin)\r\n    return db_mock\r\n```\r\n\r\nThis works perfectly when the middleware is disabled.  However, when it's enabled", "output": "I'd try to use asynctest CoroutineMock instead of MagicMock\r\nedit: ha sorry your mock is a on a def\n\n---\n\n> I'd try to use asynctest CoroutineMock instead of MagicMock\r\n> edit: ha sorry your mock is a on a def\r\n\r\nOh interesting idea, but yeah, pytest injection doesn't use async at this stage.  I'm injecting this fixture as follows:\r\n\r\n```python\r\ndef test_events(client, db_mock, current_user_mock):\r\n    db_mock.fetch.return_value = Future()\r\n    db_mock.fetch.return_value.set_result([])\r\n\r\n    response = client.post(\"/v1/events/\", json={\"id\": [\"bla\"]})\r\n    assert response.status_code == 200\r\n    assert response.json() == []\r\n    assert db_mock.fetch.call_args == mock.call(\r\n        \"SELECT * \"\r\n        \"FROM events\"\r\n        \"WHERE id = ANY ($1) \"\r\n        \"ORDER BY event_timestamp DESC \"\r\n        \"LIMIT $2\",\r\n        [\"bla\"], 20\r\n    )\r\n```\r\n\r\nOf course, I'm totally open to better ways of accomplishing this! ðŸ˜„  I'm definitely a bit new to async in Python and am coming from Falcon (which is not async at all).\n\n---\n\nActually @euri10, you're right, I can use the `asynctest` library (which I hadn't heard of) for slightly more elegant results:\r\n\r\n```python\r\n@pytest.fixture(scope=\"function\")\r\ndef db_mock(request):\r\n    def fin():\r\n        del app.dependency_overrides[get_db]\r\n\r\n    db_mock = asynctest.Mock()\r\n    app.dependency_overrides[get_db] = lambda: db_mock\r\n\r\n    request.addfinalizer(fin)\r\n    return db_mock\r\n\r\ndef test_events(client, db_mock, current_user_mock):\r\n    db_mock.fetch = asynctest.CoroutineMock(return_value=[])\r\n\r\n    response = client.post(\"/v1/events/\", json={\"id\": [\"bla\"]})\r\n    assert response.status_code == 200\r\n    assert response.json() == []\r\n    assert db_mock.fetch.call_args == mock.call(\r\n        \"SELECT * \"\r\n        \"FROM events \"\r\n        \"WHERE id = ANY ($1) \"\r\n        \"ORDER BY event_timestamp DESC \"\r\n        \"LIMIT $2\",\r\n        [\"bla\"], 20\r\n    )\r\n```\r\n\r\nThe reason this works is that the endpoint itself uses `await` so it's all good ðŸ˜„\n\n---\n\nyou can even use pytest.asyncio and have \r\n```\r\n@pytest.mark.asyncio\r\nasync def test_events(client, db_mock, current_user_mock):\r\n```\n\n---\n\nSo far, the only idea I can come up with is writing a `create_app` function which selectively adds everything:\r\n\r\n```python\r\ndef create_app(environment: str = os.getenv(\"ENVIRONMENT\")):\r\n    app = FastAPI()\r\n\r\n    # Don't register events and middleware relating to the database while testing.\r\n    # Event handlers don't seem to run during testing anyway but we'll do this to be sure.\r\n    if environment != \"testing\":\r\n        app.add_event_handler(\"startup\", startup)\r\n        app.add_event_handler(\"shutdown\", shutdown)\r\n        app.add_middleware(BaseHTTPMiddleware, database_middleware)\r\n\r\n    api_router = APIRouter()\r\n    api_router.include_router(events.router, prefix=\"/events\", tags=[\"events\"])\r\n    # ...\r\n\r\n    app.include_router(api_router, prefix=\"/v1\")\r\n```\r\n\r\nMore suggestions or ideas welcome though ðŸ˜„", "source": "issue", "type": "qa_comprehensive", "issue_number": 76}
{"instruction": "How to use different middleware for different routes/path\n\nDetails:\n### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nIs it possible to use different middleware for different routes/path?\r\n\r\n### Additional context\r\n\r\nIn my case my need comes from CORS. But, I am sure there is other cases than CORS requirements that someone would need different middlewares for different paths.\r\n\r\n* I want `myapi.com/path1` to allow origins of calls from `myfrontend.com`\r\n* I want `myapi.com/path2` to allow origins of calls from anywhere ('*') since it is a public facing api.\r\n\r\nI checked if it was possible to add a middleware at a router level and did not find any documentation about it.\r\n\r\n### Code example\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\n\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['myfrontend.com'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# I want /path1 to allow only calls from 'myfrontend.com'\r\n@app.get(\"/path1\")\r\nasync def path1():\r\n    return {\"status\": \"alive\"}\r\n\r\n# I want /path2 to be a public facing api that can be accessed from anywhere ['*']\r\n@app.get(\"/path2\")\r\nasync def path2():\r\n    return {\"status\": \"alive\"}\r\n\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "I haven't use this way, but you can have a try.\r\nHow about use subapp?\r\n[documention](https://fastapi.tiangolo.com/advanced/sub-applications-proxy/#mount-the-sub-application)", "source": "issue", "type": "qa_best_answer", "issue_number": 75}
{"instruction": "Provide a comprehensive answer to this question: How to use different middleware for different routes/path", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nIs it possible to use different middleware for different routes/path?\r\n\r\n### Additional context\r\n\r\nIn my case my need comes from CORS. But, I am sure there is other cases than CORS requirements that someone would need different middlewares for different paths.\r\n\r\n* I want `myapi.com/path1` to allow origins of calls from `myfrontend.com`\r\n* I want `myapi.com/path2` to allow origins of calls from anywhere ('*') since it is a public facing api.\r\n\r\nI checked if it was possible to add a middleware at a router level and did not find any documentation about it.\r\n\r\n### Code example\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\n\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['myfrontend.com'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# I want /path1 to allow only calls from 'myfrontend.com'\r\n@app.get(\"/path1\")\r\nasync def path1():\r\n    return {\"status\": \"alive\"}\r\n\r\n# I want /path2 to be a public facing api that can be accessed from anywhere ['*']\r\n@app.get(\"/path2\")\r\nasync def path2():\r\n    return {\"status\": \"alive\"}\r\n\r\n```", "output": "I haven't use this way, but you can have a try.\r\nHow about use subapp?\r\n[documention](https://fastapi.tiangolo.com/advanced/sub-applications-proxy/#mount-the-sub-application)\n\n---\n\nThank you @Dustyposa this looks exactly like what I was looking for.\r\n\r\nHere is a example implementation in case someone else stumble upon the same problem\r\n\r\n```python\r\n# app1.py\r\n\r\nfrom fastapi import FastAPI\r\n\r\napp1 = FastAPI(openapi_prefix=\"/app1\")\r\n\r\n@app1.get(\"path1\")\r\nasync def path1():\r\n    return { \"message\": \"app1\"}\r\n```\r\n\r\n```python\r\n# app2.py\r\n\r\nfrom fastapi import FastAPI\r\n\r\napp2 = FastAPI(openapi_prefix=\"/app2\")\r\n\r\n@app1.get(\"path2\")\r\nasync def path2():\r\n    return { \"message\": \"app2\"}\r\n```\r\n\r\n```python\r\n# main.py\r\n\r\nfrom fastapi import FastAPI\r\nfrom app1 import app1\r\nfrom app2 import app2\r\n\r\n\r\napp1.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['myfrontend.com'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# here we can add middlewares that are only for app2 and not executed on paths of app1\r\n# the CORS policy is different for app2. (allows '*' instead of 'myfrontend.com')\r\napp2.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['*'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\napp = FastAPI()\r\n\r\napp.mount(\"/app1\", app1) # if does not work try: app.mount(app1, \"/app1\")\r\napp.mount(\"/app2\", app2) # if does not work try: app.mount(app2, \"/app2\")\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"alive\"}\r\n\r\n```\n\n---\n\nThanks for your help here @Dustyposa :bowing_man: :cake: \r\n\r\nAnd thanks for reporting back and closing the issue @philippegirard :rocket:\n\n---\n\nThis is a fine approach for some use cases.  But having route based middleware is still a requirement for many projects I work on.  I understand starlette itself cannot yet do this, so perhaps this is the wrong github page to bring it up.  I will see what Tom Cristie thinks about adding route based middleware to starlette.  Then perhaps fastapi can impliment it in the route decorators `router.get('/path', middleware=['abc', 'xyz']` etc...\n\n---\n\nI'm facing a quite similar issue : I want to add custom ['Content-Security-Policy' header](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) the easiest way to do so is to add a middleware : \r\n\r\n@Api.middleware(\"http\")\r\nasync def CSPMiddleware(request: Request, call_next):\r\n\r\n    response = await call_next(request)\r\n    response.headers[\r\n        \"Content-Security-Policy\"\r\n    ] = \"default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline';\"\r\n    return response\r\n\r\nHowever this CSP block the Swagger UI and thus it would be great to only apply the middleware to a subset of routes.\r\n\r\nnb1 : For those who are wondering, i removed the middleware and i had to add a response headers to all routes (ie functions) except for the swaggers (not very clean)\r\nnb2: app.mount does not solve the problem because swaggers are not available for subapps", "source": "issue", "type": "qa_comprehensive", "issue_number": 75}
{"instruction": "How to hide certain fields in Pydantic models?\n\nDetails:\nExample:\r\n\r\nI have created_at and updated_at fields that I want to auto populate on the model using default_factory, but I don't want the user to be able to set them via an endpoint. I thought this could be achieved by the read only Field arg but then I can never set it.\r\n\r\nWhat's the best way to go about this?", "input": "Repository: FastAPI\nLabels: ", "output": "``` python\r\nfrom pydantic import BaseModel,Field\r\nfrom datetime import datetime\r\n\r\n\r\n\r\nclass User(BaseModel):\r\n    name:str\r\n    create_at: datetime = datetime.now()\r\n\r\nuser_in_system = User(name='includeamin')\r\nprint(user_in_system.dict(exclude={'create_at'}))\r\n# output: {'name': 'includeamin'}\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 74}
{"instruction": "Provide a comprehensive answer to this question: How to hide certain fields in Pydantic models?", "input": "Example:\r\n\r\nI have created_at and updated_at fields that I want to auto populate on the model using default_factory, but I don't want the user to be able to set them via an endpoint. I thought this could be achieved by the read only Field arg but then I can never set it.\r\n\r\nWhat's the best way to go about this?", "output": "``` python\r\nfrom pydantic import BaseModel,Field\r\nfrom datetime import datetime\r\n\r\n\r\n\r\nclass User(BaseModel):\r\n    name:str\r\n    create_at: datetime = datetime.now()\r\n\r\nuser_in_system = User(name='includeamin')\r\nprint(user_in_system.dict(exclude={'create_at'}))\r\n# output: {'name': 'includeamin'}\r\n```\n\n---\n\nSorry I should have clarified, how do you hide them in the openapi spec? :)\n\n---\n\nI mean you could create two models, one internal and one external, but you have to be careful between converting between two models (performance v.s. validation).\n\n---\n\nYeah it doesn't seem like there is a good way to convert between two models without validation?\n\n---\n\n> Sorry I should have clarified, how do you hide them in the openapi spec? :)\r\n\r\nI did notice that Pydantic has a schema_extra function that you can provide but fast didn't seem to be picking it up when generating the openapi docs.", "source": "issue", "type": "qa_comprehensive", "issue_number": 74}
{"instruction": "Debug and solve this technical issue: How to hide certain fields in Pydantic models?", "input": "Example:\r\n\r\nI have created_at and updated_at fields that I want to auto populate on the model using default_factory, but I don't want the user to be able to set them via an endpoint. I thought this could be achieved by the read only Field arg but then I can never set it.\r\n\r\nWhat's the best way to go about this?", "output": "``` python\r\nfrom pydantic import BaseModel,Field\r\nfrom datetime import datetime\r\n\r\n\r\n\r\nclass User(BaseModel):\r\n    name:str\r\n    create_at: datetime = datetime.now()\r\n\r\nuser_in_system = User(name='includeamin')\r\nprint(user_in_system.dict(exclude={'create_at'}))\r\n# output: {'name': 'includeamin'}\r\n```", "source": "issue", "type": "qa_technical", "issue_number": 74}
{"instruction": "FastAPI gets terminated when child multiprocessing process terminated\n\nDetails:\n### Describe the bug\r\n\r\nMake a multiprocessing Process and start it.\r\nRight after terminate the process, fastapi itself(parent) terminated.\r\n\r\n### To Reproduce\r\n\r\nStart command: /usr/local/bin/uvicorn worker.stts_api:app --host 127.0.0.1 --port 8445\r\n\r\n1. Create a file with:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post('/task/run')\r\ndef task_run(task_config: TaskOptionBody):\r\n    proc = multiprocessing.Process(\r\n        target=task.run,\r\n        args=(xxxx,))\r\n    proc.start()\r\n    return task_id\r\n\r\n@app.get('/task/abort')\r\ndef task_abort(task_id: str):\r\n    proc.terminate()\r\n    return result_OK\r\n```\r\n\r\n3. Run task_run and while the process alive, trigger task_abort\r\n4. After child process terminated then parent(fastApi) terminated as well.\r\n\r\n### Expected behavior\r\n\r\nParent process should not be terminated after child terminated.\r\n\r\n### Environment\r\n\r\n- OS: Linux\r\n- FastAPI Version 0.54.1\r\n- Python version 3.8.2\r\n\r\n\r\n### Additional context\r\n\r\nI tried same code with Flask with gunicorn, it never terminated.", "input": "Repository: FastAPI\nLabels: ", "output": "Hi @jongwon-yi, \r\nJust wanted to ask what 'TaskOptionBody' is referring to in the definition of task_run", "source": "issue", "type": "qa_best_answer", "issue_number": 73}
{"instruction": "Provide a comprehensive answer to this question: FastAPI gets terminated when child multiprocessing process terminated", "input": "### Describe the bug\r\n\r\nMake a multiprocessing Process and start it.\r\nRight after terminate the process, fastapi itself(parent) terminated.\r\n\r\n### To Reproduce\r\n\r\nStart command: /usr/local/bin/uvicorn worker.stts_api:app --host 127.0.0.1 --port 8445\r\n\r\n1. Create a file with:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post('/task/run')\r\ndef task_run(task_config: TaskOptionBody):\r\n    proc = multiprocessing.Process(\r\n        target=task.run,\r\n        args=(xxxx,))\r\n    proc.start()\r\n    return task_id\r\n\r\n@app.get('/task/abort')\r\ndef task_abort(task_id: str):\r\n    proc.terminate()\r\n    return result_OK\r\n```\r\n\r\n3. Run task_run and while the process alive, trigger task_abort\r\n4. After child process terminated then parent(fastApi) terminated as well.\r\n\r\n### Expected behavior\r\n\r\nParent process should not be terminated after child terminated.\r\n\r\n### Environment\r\n\r\n- OS: Linux\r\n- FastAPI Version 0.54.1\r\n- Python version 3.8.2\r\n\r\n\r\n### Additional context\r\n\r\nI tried same code with Flask with gunicorn, it never terminated.", "output": "Hi @jongwon-yi, \r\nJust wanted to ask what 'TaskOptionBody' is referring to in the definition of task_run\n\n---\n\n> Hi @jongwon-yi,\r\n> Just wanted to ask what 'TaskOptionBody' is referring to in the definition of task_run\r\n\r\n`\r\nclass TaskOptionBody(BaseModel):\r\n    owner: str\r\n    description: str\r\n    subscribers: str\r\n    devices: list\r\n    options: dict\r\n    protocol: int\r\n`\r\n\r\nThis behavior doesn't related to request headers or payloads. You can simply reproduce this by\r\n> run fastapi with uvicorn\r\n> start default(fork) multiprocessing Process and save the proc somewhere\r\n> terminate child with saved proc (proc.terminate())\n\n---\n\n@Kludex May I work on this?\n\n---\n\n@victorphoenix3 I'm not in charge of anything hahaha If I were you, I'd wait for someone else to confirm the bug (you can confirm by yourself), then if it's really a problem, you can work on it. There are no PRs related to this issue. :)\n\n---\n\n@tiangolo  @Kludex I did not find this issue on my system. Terminating the child process did not terminate the parent. Can you please re-confirm?\r\nThis is the code I used:\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\nimport multiprocessing\r\nimport os, signal\r\nimport psutil\r\n\r\napp = FastAPI()\r\n\r\nclass TaskOptionBody(BaseModel): \r\n    owner: str \r\n    description: str \r\n    subscribers: str \r\n    devices: list \r\n    options: dict \r\n    protocol: int\r\n\r\ndef task(pid :int):\r\n    print(f\"{pid} {os.getpid()}\")\r\n\r\n@app.post('/task/run')\r\ndef task_run(task_config: TaskOptionBody, pid: int):\r\n    proc = multiprocessing.Process(\r\n        target=task,\r\n        args=(pid,))\r\n    proc.start()\r\n    return os.getpid()\r\n\r\n@app.get('/task/abort')\r\ndef task_abort(pid: int):\r\n    proc = psutil.Process(pid)\r\n    proc.terminate()\r\n    return 0\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 73}
{"instruction": "How to achieve nested parameterized dependencies?\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n\r\n### Example\r\n\r\nGiven the follow minimal working example, where `Test1` and `Test2` are parameterized dependencies (as described in https://fastapi.tiangolo.com/advanced/advanced-dependencies/). One parameter of `Test2` should be forwarded to `Test1` which should be injected into `Test2`.:\r\n\r\n```Python\r\nimport uvicorn\r\nfrom fastapi import Depends, FastAPI\r\napp = FastAPI()\r\n\r\nclass Test1():\r\n\r\n    def __init__(self, t1) -> None:\r\n        self.t1 = t1\r\n\r\n    def __call__(self):\r\n        return self.t1\r\n\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n\r\n    def __call__(self):\r\n        return Depends(Test1(t1=self.t2))\r\n\r\n@app.get(\"/test/\")\r\ndef test_call(test: str = Depends(Test2(t2='test'))):\r\n    return test\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True, debug=True)\r\n```\r\n\r\n### Description\r\n\r\nIt is not possible to include `Test1` as dependency in the `call` parameters of `Test2` since there wouldn't be any access to the parameter of `Test1`.\r\nDirectly calling `Depends` as in the example above also does not work since there does not seem to be any dependency injection at this level.\r\n\r\nHow to achieve this kind of nesting? Is this simply not po", "input": "Repository: FastAPI\nLabels: ", "output": "you could add a `Test1` instance in `Test2.__init__`\r\nyou could get an instance as input like : `Depends(Test2(t2='test2', test1=Test1(t1='test1')))`\r\nor you can create one in `__init__` like:\r\n```\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n        self.test1=Test1(t1=t2)\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 72}
{"instruction": "Provide a comprehensive answer to this question: How to achieve nested parameterized dependencies?", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n\r\n### Example\r\n\r\nGiven the follow minimal working example, where `Test1` and `Test2` are parameterized dependencies (as described in https://fastapi.tiangolo.com/advanced/advanced-dependencies/). One parameter of `Test2` should be forwarded to `Test1` which should be injected into `Test2`.:\r\n\r\n```Python\r\nimport uvicorn\r\nfrom fastapi import Depends, FastAPI\r\napp = FastAPI()\r\n\r\nclass Test1():\r\n\r\n    def __init__(self, t1) -> None:\r\n        self.t1 = t1\r\n\r\n    def __call__(self):\r\n        return self.t1\r\n\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n\r\n    def __call__(self):\r\n        return Depends(Test1(t1=self.t2))\r\n\r\n@app.get(\"/test/\")\r\ndef test_call(test: str = Depends(Test2(t2='test'))):\r\n    return test\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True, debug=True)\r\n```\r\n\r\n### Description\r\n\r\nIt is not possible to include `Test1` as dependency in the `call` parameters of `Test2` since there wouldn't be any access to the parameter of `Test1`.\r\nDirectly calling `Depends` as in the example above also does not work since there does not seem to be any dependency injection at this level.\r\n\r\nHow to achieve this kind of nesting? Is this simply not po", "output": "you could add a `Test1` instance in `Test2.__init__`\r\nyou could get an instance as input like : `Depends(Test2(t2='test2', test1=Test1(t1='test1')))`\r\nor you can create one in `__init__` like:\r\n```\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n        self.test1=Test1(t1=t2)\r\n```\n\n---\n\n@ihakh This does not provide any dependency injection to the `__call__` method of `Test1`. Getting this to work with dependency injections is the point of this question / feature request.\n\n---\n\nHey @Spenhouet, thanks for the interest.\r\n\r\nI think I'm having a bit of trouble understanding the use case. I think I can imagine simple ways to solve it without requiring support for that, but I'm probably missing details of your use case.\r\n\r\nFor example, this seems to work:\r\n\r\n```Python\r\nimport uvicorn\r\nfrom fastapi import Depends, FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Test1:\r\n    def __init__(self, t1) -> None:\r\n        self.t1 = t1\r\n\r\n    def __call__(self):\r\n        return self.t1\r\n\r\n\r\nclass Test2:\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n\r\n    def __call__(self):\r\n        return Test1(t1=self.t2)()\r\n\r\n\r\n@app.get(\"/test/\")\r\ndef test_call(test: str = Depends(Test2(t2=\"test\"))):\r\n    return test\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True, debug=True)\r\n```\n\n---\n\nIt seems my issue left out a crucial detail which must have seemed obvious to me when I created that issue.\r\n\r\n`Test1` and `Test2` should be provided with dependency injection. `Test1` should not be a simple class as in your code example.\r\n\r\nThe crucial detail I missed to specifically mention is that I would like to have dependency injection available in the call method of `Test1` while also having it parameterized via `Test2`.\r\n\r\nFor example, the call method of `Test1` should have parameters like `request` available:\r\n\r\n```\r\nclass Test1():\r\n\r\n    def __init__(self, t1) -> None:\r\n        self.t1 = t1\r\n\r\n    def __call__(self, request: Request):\r\n        return self.t1\r\n```\r\n\r\nMy use case gets more clear when looking at the following syntactically wrong example of what I would have liked to do:\r\n\r\n```\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n\r\n    def __call__(self, test1 = Depends(Test1(t1=self.t2))):\r\n        return test1\r\n```\r\n\r\nBut this is not possible in python since `self` isn't available at this point.\r\n\r\nMy thought process was that I might be able to perform the dependency injection via the `Depends` wrapper outside the parameters directly in the code.\r\n\r\n```\r\ndef __call__(self):\r\n        test1 = Depends(Test1(t1=self.t2))\r\n        return test1\r\n```\r\n\r\nBut this does not execute as expected. This just returns an object but does not actually execute the `call` method of `Test1` like it is done when it is included as parameter.\n\n---\n\nCould you do something like this instead?\r\n\r\n```python\r\n\r\n    def __call__(self, test1 = Depends(Test1())):\r\n        test1.t1 = self.t2\r\n        return test1\r\n```\r\n\r\nWithout knowing your actual use case, it's difficult to suggest possible solutions", "source": "issue", "type": "qa_comprehensive", "issue_number": 72}
{"instruction": "Question. SQL Alchemy and blocking calls\n\nDetails:\nin the documentation it is suggested to use sql alchemy as a orm, but isn't alchemy completely synchronous? wouldn't that way create blocking calls?", "input": "Repository: FastAPI\nLabels: ", "output": "I don't know at which point you've read. But there's also a section about **databases**, which is the asynchronous suggestion about the topic. \r\n\r\nI can't give you the references right now, but search for \"encode databases\" in Google or in the documentation and you'll find more information. \r\n\r\nAbout this topic, if someone is willing to open a PR about how to use FastAPI with Gino and/or Tortoise, I think it will be gladly accepted. Those are the most recommended async ORM solutions nowadays, even by @tiangolo himself  (based on last Friday YouTube presentation).\r\n\r\nJust remember that FastAPI is DB Independent. :)\r\n\r\nAbout what you probably saw in the documentation, you need to understand that SQLAlchemy is more than 10 years old, and the async ORM frameworks are still quite new. GINO (build on top of SQLAlchemy) was born February 2020 and Tortoise has more or less the same age as FastAPI (2 years old +). My point is that going for SQLAlchemy will avoid surprises in your development path.\r\n\r\nAnswering your question: yes, it will.\r\n\r\nLast curious points: \r\n- Tortoise ORM has a Pydantic feature which is quite nice for us. \r\n- @tiangolo is experimenting some nice stuff that will make you able to create a Pydantic and SQLAlchemy model at the same time (this is based on a single Twitter post). We don't have more information about it, but he said he was just experimenting. Hope he can achieve something nice and share with us :) \r\n\r\nP.S.: Sorry for the lack of links, I'm unable to add them now. \r\n\r\nEdit: references below:\r\n- [FastAPI docs about async SQL databases](https://fastapi.tiangolo.com/tutorial/sql-databases/) \r\n- [databases from encode](https://github.com/encode/databases)\r\n- [GINO](https://python-gino.org/)\r\n- [Template using GINO with FastAPI](https://github.com/leosussan/fastapi-gino-arq-uvicorn)\r\n- [Tortoise ORM - FastAPI example](https://tortoise-orm.readthedocs.io/en/latest/examples/fastapi.html)\r\n- [SebastiÃ¡n's YouTube talk about FastAPI from last Friday](https://www.youtube.com/watch?v=1zMQBe0l1bM)\r\n- [SebastiÃ¡n's tweet about Pydantic + SQLAlchemy models](https://twitter.com/tiangolo/status/1287679028036599809)", "source": "issue", "type": "qa_best_answer", "issue_number": 71}
{"instruction": "Provide a comprehensive answer to this question: Question. SQL Alchemy and blocking calls", "input": "in the documentation it is suggested to use sql alchemy as a orm, but isn't alchemy completely synchronous? wouldn't that way create blocking calls?", "output": "I don't know at which point you've read. But there's also a section about **databases**, which is the asynchronous suggestion about the topic. \r\n\r\nI can't give you the references right now, but search for \"encode databases\" in Google or in the documentation and you'll find more information. \r\n\r\nAbout this topic, if someone is willing to open a PR about how to use FastAPI with Gino and/or Tortoise, I think it will be gladly accepted. Those are the most recommended async ORM solutions nowadays, even by @tiangolo himself  (based on last Friday YouTube presentation).\r\n\r\nJust remember that FastAPI is DB Independent. :)\r\n\r\nAbout what you probably saw in the documentation, you need to understand that SQLAlchemy is more than 10 years old, and the async ORM frameworks are still quite new. GINO (build on top of SQLAlchemy) was born February 2020 and Tortoise has more or less the same age as FastAPI (2 years old +). My point is that going for SQLAlchemy will avoid surprises in your development path.\r\n\r\nAnswering your question: yes, it will.\r\n\r\nLast curious points: \r\n- Tortoise ORM has a Pydantic feature which is quite nice for us. \r\n- @tiangolo is experimenting some nice stuff that will make you able to create a Pydantic and SQLAlchemy model at the same time (this is based on a single Twitter post). We don't have more information about it, but he said he was just experimenting. Hope he can achieve something nice and share with us :) \r\n\r\nP.S.: Sorry for the lack of links, I'm unable to add them now. \r\n\r\nEdit: references below:\r\n- [FastAPI docs about async SQL databases](https://fastapi.tiangolo.com/tutorial/sql-databases/) \r\n- [databases from encode](https://github.com/encode/databases)\r\n- [GINO](https://python-gino.org/)\r\n- [Template using GINO with FastAPI](https://github.com/leosussan/fastapi-gino-arq-uvicorn)\r\n- [Tortoise ORM - FastAPI example](https://tortoise-orm.readthedocs.io/en/latest/examples/fastapi.html)\r\n- [SebastiÃ¡n's YouTube talk about FastAPI from last Friday](https://www.youtube.com/watch?v=1zMQBe0l1bM)\r\n- [SebastiÃ¡n's tweet about Pydantic + SQLAlchemy models](https://twitter.com/tiangolo/status/1287679028036599809)\n\n---\n\nI am using fastapi and tortoise orm in production and tortoise orm has problems with migrations. or rather, they are not at all out of the box. this creates the need for third-party solutions such as aerich, which in turn is poorly optimized for postgresql. The question arises - are there any plans to write a migration library for tortoise orm or support for aerich? or not? \r\nand what to do with migrations on fastapi if there is no normal, asynchronous orm? because in the current implementation it turns out that fastapi does not have a stable orm. its a serious problem\n\n---\n\n> The question arises - are there any plans to write a migration library for tortoise orm or support for aerich? or not?\r\n\r\nWe are talking in the FastAPI GitHub issues, if you want details about Tortoise, maybe you should ask on their issues... But anyway, using Tortoise search engine you can find their [roadmap](https://tortoise-orm.readthedocs.io/en/latest/roadmap.html?highlight=migrations#mid-term):\r\n![image](https://user-images.githubusercontent.com/7353520/89129014-f88a9b80-d4f9-11ea-8f83-02111ac3c1bb.png)\r\n\r\n> and what to do with migrations on fastapi if there is no normal, asynchronous orm? because in the current implementation it turns out that fastapi does not have a stable orm. its a serious problem\r\n\r\nPlease, do not make strong statements like \"its a serious problem\" without concrete arguments. I'll quote what I said in my last reply: \r\n> Just remember that FastAPI is DB Independent. :)\r\n\r\nNow, [aerich](https://github.com/long2ice/aerich) was created a few months ago (May 19) so it's expected to not be perfect. But be aware that SQLAlchemy's most common migration tool used is [Alembic](https://alembic.sqlalchemy.org/en/latest/) and GINO as well is using the same tool ([GINO's solution](https://gist.github.com/omarryhan/cb7bf6d7142c154496ba6623a56326c2#file-sanic-gino-alembic-migrations-setup)). So none of those ORMs have native migrations. \r\n\r\nAdditional comments:\r\n- Alembic was created by SQLAlchemy creator...\r\n- Django has native migrations on the Django ORM... If that's something that you really need...\n\n---\n\nUsing a basic wrk performance test with the exact tutorial about SQL Alchemy does indeed cause the server to crash.  See #1562.  My work around is to use encode databases for async.  Just note that encode database is only the query builder core of SQL Alchemy so if you want an ORM you will need to build that layer as I am...or looks like tomchristie from encode is working on one himself (https://github.com/encode/orm) though it resembles Django ORM which I am not fond of.\n\n---\n\n> Using a basic wrk performance test with the exact tutorial about SQL Alchemy does indeed cause the server to crash. See #1562. My work around is to use encode databases for async. Just note that encode database is only the query builder core of SQL Alchemy so if you want an ORM you will need to build that layer as I am...or looks like tomchristie from encode is working on one himself (https://github.com/encode/orm) though it resembles Django ORM which I am not fond of.\r\n\r\nhttps://github.com/encode/orm is too raw. it don't even have ManyToMany Field \r\n\r\nhttps://github.com/encode/orm/blob/master/orm/fields.py", "source": "issue", "type": "qa_comprehensive", "issue_number": 71}
{"instruction": "Using UploadFile and Pydantic model in one request\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Properties(BaseModel):\r\n    language: str = None\r\n    author: str = None\r\n\r\n\r\n@app.post(\"/uploadfile/\", status_code=201)\r\nasync def create_upload_file(properties: Properties, file: UploadFile = File(...)):\r\n    return {\"filename\": file.filename, 'properties': properties}\r\n```\r\n\r\n### Description\r\n\r\n* Open the browser `/docs` and call the endpoint `/uploadfile`.\r\n* It returns error 422 Validation Error.\r\n* But I expected it to return code 201.\r\n\r\n### Environment\r\n\r\n* OS: Linux (Fedora)\r\n* FastAPI Version: 0.61.1\r\n* Python version: 3.8.6\r\n\r\n### Additional context\r\nImmediately I apologize, m", "input": "Repository: FastAPI\nLabels: ", "output": "based on [docs](https://fastapi.tiangolo.com/tutorial/request-forms-and-files/#import-file-and-form)\r\n``` python\r\nfrom fastapi import FastAPI, File, UploadFile,Form\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Properties(BaseModel):\r\n    language: str = None\r\n    author: str = None\r\n\r\n\r\n@app.post(\"/uploadfile/\", status_code=201)\r\nasync def create_upload_file(language: str = Form(...),author: str = Form(...),file: UploadFile = File(...)):\r\n    return {\"filename\": file.filename, 'properties': Properties(language=language,author=author)}\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 70}
{"instruction": "Provide a comprehensive answer to this question: Using UploadFile and Pydantic model in one request", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Properties(BaseModel):\r\n    language: str = None\r\n    author: str = None\r\n\r\n\r\n@app.post(\"/uploadfile/\", status_code=201)\r\nasync def create_upload_file(properties: Properties, file: UploadFile = File(...)):\r\n    return {\"filename\": file.filename, 'properties': properties}\r\n```\r\n\r\n### Description\r\n\r\n* Open the browser `/docs` and call the endpoint `/uploadfile`.\r\n* It returns error 422 Validation Error.\r\n* But I expected it to return code 201.\r\n\r\n### Environment\r\n\r\n* OS: Linux (Fedora)\r\n* FastAPI Version: 0.61.1\r\n* Python version: 3.8.6\r\n\r\n### Additional context\r\nImmediately I apologize, m", "output": "based on [docs](https://fastapi.tiangolo.com/tutorial/request-forms-and-files/#import-file-and-form)\r\n``` python\r\nfrom fastapi import FastAPI, File, UploadFile,Form\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Properties(BaseModel):\r\n    language: str = None\r\n    author: str = None\r\n\r\n\r\n@app.post(\"/uploadfile/\", status_code=201)\r\nasync def create_upload_file(language: str = Form(...),author: str = Form(...),file: UploadFile = File(...)):\r\n    return {\"filename\": file.filename, 'properties': Properties(language=language,author=author)}\r\n```\n\n---\n\n> based on [docs](https://fastapi.tiangolo.com/tutorial/request-forms-and-files/#import-file-and-form)\n> ``` python\n> from fastapi import FastAPI, File, UploadFile,Form\n> from pydantic import BaseModel\n> \n> app = FastAPI()\n> \n> \n> class Properties(BaseModel):\n>     language: str = None\n>     author: str = None\n> \n> \n> @app.post(\"/uploadfile/\", status_code=201)\n> async def create_upload_file(language: str = Form(...),author: str = Form(...),file: UploadFile = File(...)):\n>     return {\"filename\": file.filename, 'properties': Properties(language=language,author=author)}\n> ```\n\nHello. This option does not suit me, since the model in my project has many fields and I do not want crutches in my project, because of this I released a patch so that you can transfer the Pydantic Model to FormData. But thanks for trying to help\n\n---\n\nThen you can try to use dependency injection. Just make class with required fields (better use dataclass). \r\nBut imo it's bad practice to upload file and body fields simultaneously\n\n---\n\n> Then you can try to use dependency injection. Just make class with required fields (better use dataclass).\r\n\r\nAgain, this will be a crutch, I already have a ready-made Pydantic model and a handler for it. Now I just want to add a picture to it. FastAPI does not support the Pydantic model through FormData. Why can't you just add support for this? I already solved this problem with 4 lines of code but they are ignored. But thanks for trying to help\n\n---\n\n> Again, this will be a crutch, I already have a ready-made Pydantic model and a handler for it. Now I just want to add a picture to it. FastAPI does not support the Pydantic model through FormData. Why can't you just add support for this? I already solved this problem with 4 lines of code but they are ignored. But thanks for trying to help\r\n\r\nIn fact, it's working with Pydantic model, I had such code snippet in my pet project:\r\n```python3\r\n@api.post('/')\r\ndef add_review(\r\n    body: Model = Body(...),\r\n    image_files: Optional[List[UploadFile]] = File(None, media_type='image/jpeg'),\r\n):\r\n    ...\r\n```\r\nBUT! when I tried to send such data I had to insert body json as string inside form-data (that's RFC limitations: https://tools.ietf.org/html/rfc1867)", "source": "issue", "type": "qa_comprehensive", "issue_number": 70}
{"instruction": "FastAPI always returns content, even if 204 no content status code is set.\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n### Example\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom starlette.status import HTTP_204_NO_CONTENT\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", status_code=HTTP_204_NO_CONTENT)\r\ndef read_root():\r\n    print(\"d\")\r\n```\r\n\r\n\r\n\r\n### Description\r\n\r\nSend a request with any HTTP Client, observe the traffic using tcpdump/wireshark - you'll see that you get null as a response (content-length will be 4). This is extremely notable as this caused this issue https://github.com/encode/httpx/issues/1474 (The client doesn't expect any data in that case)\r\nI would expect FastAPI to not return null when response is None.\r\n\r\n### Environment\r\n\r\n* OS: macOS\r\n* FastAPI Version [e.g. 0.3.0]: 0.63.0\r\n* Python version: 0.63.0", "input": "Repository: FastAPI\nLabels: ", "output": "Can you try to run with httptools instead of h11?", "source": "issue", "type": "qa_best_answer", "issue_number": 69}
{"instruction": "Provide a comprehensive answer to this question: FastAPI always returns content, even if 204 no content status code is set.", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n### Example\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom starlette.status import HTTP_204_NO_CONTENT\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", status_code=HTTP_204_NO_CONTENT)\r\ndef read_root():\r\n    print(\"d\")\r\n```\r\n\r\n\r\n\r\n### Description\r\n\r\nSend a request with any HTTP Client, observe the traffic using tcpdump/wireshark - you'll see that you get null as a response (content-length will be 4). This is extremely notable as this caused this issue https://github.com/encode/httpx/issues/1474 (The client doesn't expect any data in that case)\r\nI would expect FastAPI to not return null when response is None.\r\n\r\n### Environment\r\n\r\n* OS: macOS\r\n* FastAPI Version [e.g. 0.3.0]: 0.63.0\r\n* Python version: 0.63.0", "output": "Can you try to run with httptools instead of h11?\n\n---\n\n> Can you try to run with httptools instead of h11? \n\nClient or server ?\n\n---\n\nunicorn --http httptools\n\n---\n\n`httptools` will return `null` and `h11` will return empty but raises an exception if you don't explicitly return a Response but declare the status code to be `204`.\r\n\r\nyou have to explicitly return an empty Response instead of implicitly returning `None`, which is what happens when you don't return anything.\r\n\r\n```python\r\nreturn Response(status_code=HTTP_204_NO_CONTENT)\r\n```\r\n\r\nalso, see: https://github.com/tiangolo/fastapi/issues/2253\n\n---\n\nYou could instead set the response class for that path operator to be `Response` instead of the default `JSONResponse`.  Then it won't convert `None` into JSON.  So w/ your example above it would be:\r\n\r\n```python\r\n@app.get(\"/\", status_code=HTTP_204_NO_CONTENT, response_class=Response)\r\ndef read_root():\r\n    print(\"d\")\r\n```\r\n\r\nwhich correctly returns `b\"\"`.\r\n\r\nnote, if you are doing this on multiple endpoints, you can set the default response class on your router, or even your entire app. https://fastapi.tiangolo.com/advanced/custom-response/#default-response-class", "source": "issue", "type": "qa_comprehensive", "issue_number": 69}
{"instruction": "Using dependency injection to get SQLAlchemy session can lead to deadlock\n\nDetails:\n### First check\r\n\r\n- [x] I added a very descriptive title to this issue.\r\n- [x] I used the GitHub search to find a similar issue and didn't find it.\r\n- [x] I searched the FastAPI documentation, with the integrated search.\r\n- [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n- [x] After submitting this, I commit to one of:\r\n  - Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n  - I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n  - Implement a Pull Request for a confirmed bug.\r\n\r\nI've noticed that when using dependency injection with SQLAlchemy, a large number of concurrent requests can leave the app in a deadlocked state. This is especially noticeable with a small SQLAlchemy connection pool size (relative to the FastAPI thread pool size). Below is a self-contained example (you might have to tweak the pool size and the request body's sleep length but this should be a good starting point).\r\n\r\n<details>\r\n  <summary>View <code>app.py</code></summary>\r\n\r\n```python\r\n\"\"\"\r\nSetup: pip install fastapi sqlalchemy uvicorn\r\nRun: python app.py\r\n\"\"\"\r\nimport time\r\nimport uvicorn\r\n\r\nfrom fastapi import Depends, FastAPI, Request\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import Session, sessionmaker\r\nfrom sqlalchemy.pool import QueuePool\r\n\r\n\r\n# SQLAlchemy setup\r\nengine = create_engine(\r\n    'sqlite:///test.db',\r\n    connect_args={'check_s", "input": "Repository: FastAPI\nLabels: ", "output": "I faced this problem. In 100% of cases, requests are blocked. Regardless of the frequency of requests, after about 7-10 requests, each time, requests are blocked. And so every time until you reboot. Tried it both in IDE on win10 and in Docker. On versions python 3.8 and 3.9 - nothing changes.", "source": "issue", "type": "qa_best_answer", "issue_number": 68}
{"instruction": "Provide a comprehensive answer to this question: Using dependency injection to get SQLAlchemy session can lead to deadlock", "input": "### First check\r\n\r\n- [x] I added a very descriptive title to this issue.\r\n- [x] I used the GitHub search to find a similar issue and didn't find it.\r\n- [x] I searched the FastAPI documentation, with the integrated search.\r\n- [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n- [x] After submitting this, I commit to one of:\r\n  - Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n  - I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n  - Implement a Pull Request for a confirmed bug.\r\n\r\nI've noticed that when using dependency injection with SQLAlchemy, a large number of concurrent requests can leave the app in a deadlocked state. This is especially noticeable with a small SQLAlchemy connection pool size (relative to the FastAPI thread pool size). Below is a self-contained example (you might have to tweak the pool size and the request body's sleep length but this should be a good starting point).\r\n\r\n<details>\r\n  <summary>View <code>app.py</code></summary>\r\n\r\n```python\r\n\"\"\"\r\nSetup: pip install fastapi sqlalchemy uvicorn\r\nRun: python app.py\r\n\"\"\"\r\nimport time\r\nimport uvicorn\r\n\r\nfrom fastapi import Depends, FastAPI, Request\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import Session, sessionmaker\r\nfrom sqlalchemy.pool import QueuePool\r\n\r\n\r\n# SQLAlchemy setup\r\nengine = create_engine(\r\n    'sqlite:///test.db',\r\n    connect_args={'check_s", "output": "I faced this problem. In 100% of cases, requests are blocked. Regardless of the frequency of requests, after about 7-10 requests, each time, requests are blocked. And so every time until you reboot. Tried it both in IDE on win10 and in Docker. On versions python 3.8 and 3.9 - nothing changes.\n\n---\n\nI solved this problem by using this method - https://github.com/tiangolo/full-stack-fastapi-postgresql/issues/104#issuecomment-775858005.\n\n---\n\nI'm not sure how background tasks are scheduled, but it doesn't look like that would always prevent the above situation. For example, running the above app using that solution still leads to deadlock with 100 concurrent users.\r\n\r\nAnother possible solution is to keep `get_db()` as-is, and change all endpoints to something like:\r\n\r\n```python\r\n@app.get('/')\r\ndef index(db: Session = Depends(get_db)):\r\n    with close_at_end(db) as db:\r\n        data = db.query(...)...\r\n        return {\"data\": data}\r\n```\r\n\r\nwhere `close_at_end` is a simple context manager that yields `db` and closes it after. This doesn't account for sub-dependencies and is a little tedious, but it can work as a temporary workaround.\r\n\r\nIt seems like if you want to keep using dependencies, the real solution is to migrate to an async database library, and if you're already using SQLAlchemy the switch should be relatively easy with version 1.4.\n\n---\n\nHi everyone, \r\n\r\nDuring my locust test on my FastApi apis, I'm trying a 1000 users test with a 10 users spawn rate and after a moment, I have a QueuePool limit error. \r\nFirst I increase my create_engine configuration (my SQL Database allows 75 different connections) : \r\n`engine = create_engine(\r\n    SQLALCHEMY_DATABASE_URL,\r\n    pool_recycle=3600,\r\n    pool_size=16,\r\n    max_overflow=48\r\n)`\r\nBut the problem persists. After a lot of investigation, I find this topic : https://github.com/tiangolo/full-stack-fastapi-postgresql/issues/104#issuecomment-586466934 (the same as @Blue9 ). And I just remove the Depends as recommanded by the following Session Manager :\r\n\r\n```python \r\n@contextmanager\r\ndef get_db():\r\n    session = SessionLocal()\r\n     try:\r\n        yield session\r\n    finally:\r\n        session.close()\r\n\r\n@app.get(\"/users/get-mail/{mail}\", response_model=schemas.User)\r\n   def check_user_by_email(mail: str):\r\n     with get_db() as db:\r\n          db_user = crud.get_user_by_email(db, email=mail)\r\n          return db_user\r\n```\r\n\r\nI think there is a critical problem with Depends that @tiangolo needs to investigate because in their documentation, they advise to use Depends, but Depends is not ready for a production use ! Thanks to the community for the Session Manager solution that saves my production deployment !\n\n---\n\nWe're seeing this issue too.\r\n\r\nI'm working on going in and figuring out the bug, but @Blue9 seems to be correct in the problem stemming from the operation code being run in a different thread than the dependency seems to be the locus.\r\n\r\nTemporary work arounds are to use a context manager, or use an async function with `sqlalchemy.ext.asyncio`, both of which ensure it all happens in the same thread. But you *do not have to do both*.\r\n\r\nI would highly suggest to the FastAPI maintainers that they add a note in the documentation and on https://github.com/tiangolo/full-stack-fastapi-postgresql that there is a potential issue, as right now it is not production ready for a load greater than 30 or so concurrent users.", "source": "issue", "type": "qa_comprehensive", "issue_number": 68}
{"instruction": "Pydantic v2, dataclasses, UUID, and `__annotations__`\n\nDetails:\n### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe combination of using:\r\n\r\n* Pydantic v2\r\n* dataclasses (instead of Pydantic models)\r\n* UUIDs\r\n* `from future import __annotations__`\r\n\r\nseems to break in a strange way.\r\n\r\nThis was original reported in this discussion by @sanzoghenzo: https://github.com/tiangolo/fastapi/discussions/9709#discussioncomment-6449458\r\n\r\nIn particular the comment by @raddevon with the minimal example by @fantix:\r\n\r\n```Python\r\nfrom __future__ import annotations\r\n\r\nimport uuid\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Union\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\n@dataclass\r\nclass Item:\r\n    id: uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/items/next\", response_model=Item)\r\nasync def read_next_item():\r\n    return {\r\n        \"name\": \"Island In The Moon\",\r\n        \"price\": 12.99,\r\n        \"description\": \"A place to be be playin' and havin' fun\",\r\n        \"tags\": [\"breater\"],\r\n    }\r\n```\r\n\r\nStarting FastAPI with that breaks with an error of:\r\n\r\n<details>\r\n<summary>log</summary>\r\n\r\n```\r\nuvicorn main:app\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 165, in __init__\r\n    core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 97, in _getattr_no_parents\r\n    raise AttributeError(attribute)\r\nAttributeError: __pydantic_core_schema__\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/_internal/_generate_schema.py\", line 625, in _resolve_forward_ref\r\n    obj = _typin", "input": "Repository: FastAPI\nLabels: ", "output": "Maybe using an id of type str can solve the problem...\r\n\r\nclass Item:\r\n    id: str  # Using string instead of uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None", "source": "issue", "type": "qa_best_answer", "issue_number": 67}
{"instruction": "Provide a comprehensive answer to this question: Pydantic v2, dataclasses, UUID, and `__annotations__`", "input": "### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe combination of using:\r\n\r\n* Pydantic v2\r\n* dataclasses (instead of Pydantic models)\r\n* UUIDs\r\n* `from future import __annotations__`\r\n\r\nseems to break in a strange way.\r\n\r\nThis was original reported in this discussion by @sanzoghenzo: https://github.com/tiangolo/fastapi/discussions/9709#discussioncomment-6449458\r\n\r\nIn particular the comment by @raddevon with the minimal example by @fantix:\r\n\r\n```Python\r\nfrom __future__ import annotations\r\n\r\nimport uuid\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Union\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\n@dataclass\r\nclass Item:\r\n    id: uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/items/next\", response_model=Item)\r\nasync def read_next_item():\r\n    return {\r\n        \"name\": \"Island In The Moon\",\r\n        \"price\": 12.99,\r\n        \"description\": \"A place to be be playin' and havin' fun\",\r\n        \"tags\": [\"breater\"],\r\n    }\r\n```\r\n\r\nStarting FastAPI with that breaks with an error of:\r\n\r\n<details>\r\n<summary>log</summary>\r\n\r\n```\r\nuvicorn main:app\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 165, in __init__\r\n    core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 97, in _getattr_no_parents\r\n    raise AttributeError(attribute)\r\nAttributeError: __pydantic_core_schema__\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/_internal/_generate_schema.py\", line 625, in _resolve_forward_ref\r\n    obj = _typin", "output": "Maybe using an id of type str can solve the problem...\r\n\r\nclass Item:\r\n    id: str  # Using string instead of uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None\n\n---\n\nIt looks like forward references are resolved from namespaces built from the previous 2 frames\r\nhttps://github.com/pydantic/pydantic/blob/adc657a8b9f0b5191c180fc51005c0bf1fe529db/pydantic/type_adapter.py#L76\n\n---\n\nYou could use Pydantic's dataclass extension. It doesn't just give you the same data validation features but also fix your issue.\r\n\r\n```python\r\nfrom __future__ import annotations\r\n\r\nfrom typing import List, Union\r\nimport uuid\r\n\r\nfrom pydantic.dataclasses import dataclass, Field\r\n\r\n@dataclass\r\nclass Item:\r\n    id: uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = Field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None\r\n\r\nitem = Item(\r\n    id=uuid.uuid4(),\r\n    name=\"John\",\r\n    price=666.66,\r\n)\r\n\r\nprint(item)\r\n\r\n# Item(id=UUID('c399d5c9-c2bf-4e5f-94f9-21a7a5f78610'), name='John', price=666.66, tags=[], description=None, tax=None)\r\n```\n\n---\n\nThis would need to be handled on the Pydantic side (or at least require some input/changes from them). https://github.com/pydantic/pydantic/issues/7111\r\n\r\nAs @harunyasar mentions, there's a simple workaround, to use Pydantic's flavor of `dataclasses` instead of the standard library ones.\r\n\r\n```Python\r\nfrom pydantic.dataclasses import dataclass\r\n```\r\n\r\nI understand this is one of the things that begs for PEP 649 (Deferred Evaluation Of Annotations Using Descriptors) that will hopefully come to Python 3.13 ðŸŽ‰\n\n---\n\nI'm not sure if this is related, but I'm hitting:\r\n\r\n```consoel\r\n==================================== ERRORS ====================================\r\n______________________ ERROR collecting tests/test_api.py ______________________\r\nImportError while importing test module '/__w/flux-restful-api/flux-restful-api/tests/test_api.py'.\r\nHint: make sure your test modules/packages have valid Python names.\r\nTraceback:\r\n/usr/lib/python3.8/importlib/__init__.py:127: in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\ntests/test_api.py:6: in <module>\r\n    from fastapi.testclient import TestClient\r\n/usr/local/lib/python3.8/dist-packages/fastapi/__init__.py:7: in <module>\r\n    from .applications import FastAPI as FastAPI\r\n/usr/local/lib/python3.8/dist-packages/fastapi/applications.py:3: in <module>\r\n    from fastapi import routing\r\n/usr/local/lib/python3.8/dist-packages/fastapi/routing.py:20: in <module>\r\n    from fastapi import params\r\n/usr/local/lib/python3.8/dist-packages/fastapi/params.py:4: in <module>\r\n    from pydantic.fields import FieldInfo, Undefined\r\nE   ImportError: cannot import name 'Undefined' from 'pydantic.fields' (/usr/local/lib/python3.8/dist-packages/pydantic/fields.py)\r\n```\r\n\r\nI've installed the lastest fastapi and pydantic, so I suspect this is a new issue!  I think probably the only way to fix this now is to fall back to a much older pydantic. Also @tiangolo your use of emojis in commits is pure :fire: I love looking at your code!  :raised_hands:", "source": "issue", "type": "qa_comprehensive", "issue_number": 67}
{"instruction": "Debug and solve this technical issue: Pydantic v2, dataclasses, UUID, and `__annotations__`", "input": "### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe combination of using:\r\n\r\n* Pydantic v2\r\n* dataclasses (instead of Pydantic models)\r\n* UUIDs\r\n* `from future import __annotations__`\r\n\r\nseems to break in a strange way.\r\n\r\nThis was original reported in this discussion by @sanzoghenzo: https://github.com/tiangolo/fastapi/discussions/9709#discussioncomment-6449458\r\n\r\nIn particular the comment by @raddevon with the minimal example by @fantix:\r\n\r\n```Python\r\nfrom __future__ import annotations\r\n\r\nimport uuid\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Union\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\n@dataclass\r\nclass Item:\r\n    id: uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/items/next\", response_model=Item)\r\nasync def read_next_item():\r\n    return {\r\n        \"name\": \"Island In The Moon\",\r\n        \"price\": 12.99,\r\n        \"description\": \"A place to be be playin' and havin' fun\",\r\n        \"tags\": [\"breater\"],\r\n    }\r\n```\r\n\r\nStarting FastAPI with that breaks with an error of:\r\n\r\n<details>\r\n<summary>log</summary>\r\n\r\n```\r\nuvicorn main:app\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 165, in __init__\r\n    core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 97, in _getattr_no_parents\r\n    raise AttributeError(attribute)\r\nAttributeError: __pydantic_core_schema__\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/_internal/_generate_schema.py\", line 625, in _resolve_forward_ref\r\n    obj = _typing_extra.evaluate_fwd_ref(obj, globalns=self._types_namespace)\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/_internal/_typing_extra.py\", line 423, in evaluate_fwd_ref\r\n    return ref._evaluate(globalns=globalns, localns=localns, recursive_guard=frozenset())\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/typing.py\", line 694, in _evaluate\r\n    eval(self.__forward_code__, globalns, localns),\r\n  File \"<string>\", line 1, in <module>\r\nNameError: name 'uuid' is not defined\r\n\r\nThe above exception was the direct cause of the following exception:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/bin/uvicorn\", line 8, in <module>\r\n    sys.exit(main())\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/click/core.py\", line 1130, in __call__\r\n    return self.main(*args, **kwargs)\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/click/core.py\", line 1055, in main\r\n  ", "output": "Maybe using an id of type str can solve the problem...\r\n\r\nclass Item:\r\n    id: str  # Using string instead of uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None", "source": "issue", "type": "qa_technical", "issue_number": 67}
{"instruction": "Multiple regressions in the handling of forms & form validation\n\nDetails:\n### Issue Content\n\nWe have found at least 2 regression in the way forms are handled while trying to migrate to v0.115.11 from version v0.112.4. After investigation we were able to identify 2 commits that introduce 2 separate bugs that break the handling of default values in both `x-form-urlencoded` and `mutlipart` froms. Partial fixes have been proposed that also address a CVE, but the PR has been hanging since october 24.\n\n# Breaking in the handling of default value in `x-url-encoded` forms\n\nThis bug has been introduced in https://github.com/fastapi/fastapi/pull/12134.\n\nMRE:\n```python\napp = FastAPI()\n\n\n@app.post(\"/\")\ndef root(\n    name: Annotated[Optional[str], Form(embed=True)] = None,\n):\n    print(name)\n    return name\n```\n\nwith the following request:\n```\nâ¯ http post -v --form localhost:8888 name=\"\"\nPOST / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate, br, zstd\nConnection: keep-alive\nContent-Length: 5\nContent-Type: application/x-www-form-urlencoded\nHost: localhost:8888\nUser-Agent: xh/0.24.0\n\nname=\n\nHTTP/1.1 200 OK\nContent-Length: 2\nContent-Type: application/json\nDate: Sun, 23 Mar 2025 21:01:49 GMT\nServer: uvicorn\n\n\"\"\n```\nThe expected result is that `None` is printed, but instead `\"\"` is printed.\n\nthis is the offending bit from the linked PR:\n```\ndiff --git a/fastapi/dependencies/utils.py b/fastapi/dependencies/utils.py\nindex 6083b731..db7eedba 100644\n--- a/fastapi/dependencies/utils.py\n+++ b/fastapi/dependencies/utils.py\n@@ -789,9 +789,9 @@ async def _extract_form_body(\n             value = serialize_sequence_value(field=field, value=results)\n         if value is not None:\n             values[field.name] = value\n-    for key, value in received_body.items():\n-        if key not in values:\n-            values[key] = value\n+    # for key, value in received_body.items():\n+    #     if key not in values:\n+    #         values[key] = value\n     return values\n```\nThis patch solves the x-form-urlencoded  case. So we indeed have two different regressions.\nThis _get_", "input": "Repository: FastAPI\nLabels: ", "output": "@MarinPostma: You are not specifying the response model.", "source": "issue", "type": "qa_best_answer", "issue_number": 66}
{"instruction": "Provide a comprehensive answer to this question: Multiple regressions in the handling of forms & form validation", "input": "### Issue Content\n\nWe have found at least 2 regression in the way forms are handled while trying to migrate to v0.115.11 from version v0.112.4. After investigation we were able to identify 2 commits that introduce 2 separate bugs that break the handling of default values in both `x-form-urlencoded` and `mutlipart` froms. Partial fixes have been proposed that also address a CVE, but the PR has been hanging since october 24.\n\n# Breaking in the handling of default value in `x-url-encoded` forms\n\nThis bug has been introduced in https://github.com/fastapi/fastapi/pull/12134.\n\nMRE:\n```python\napp = FastAPI()\n\n\n@app.post(\"/\")\ndef root(\n    name: Annotated[Optional[str], Form(embed=True)] = None,\n):\n    print(name)\n    return name\n```\n\nwith the following request:\n```\nâ¯ http post -v --form localhost:8888 name=\"\"\nPOST / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate, br, zstd\nConnection: keep-alive\nContent-Length: 5\nContent-Type: application/x-www-form-urlencoded\nHost: localhost:8888\nUser-Agent: xh/0.24.0\n\nname=\n\nHTTP/1.1 200 OK\nContent-Length: 2\nContent-Type: application/json\nDate: Sun, 23 Mar 2025 21:01:49 GMT\nServer: uvicorn\n\n\"\"\n```\nThe expected result is that `None` is printed, but instead `\"\"` is printed.\n\nthis is the offending bit from the linked PR:\n```\ndiff --git a/fastapi/dependencies/utils.py b/fastapi/dependencies/utils.py\nindex 6083b731..db7eedba 100644\n--- a/fastapi/dependencies/utils.py\n+++ b/fastapi/dependencies/utils.py\n@@ -789,9 +789,9 @@ async def _extract_form_body(\n             value = serialize_sequence_value(field=field, value=results)\n         if value is not None:\n             values[field.name] = value\n-    for key, value in received_body.items():\n-        if key not in values:\n-            values[key] = value\n+    # for key, value in received_body.items():\n+    #     if key not in values:\n+    #         values[key] = value\n     return values\n```\nThis patch solves the x-form-urlencoded  case. So we indeed have two different regressions.\nThis _get_", "output": "@MarinPostma: You are not specifying the response model.\n\n---\n\nThe response model is inconsequential in this example. I am not interested in the output of the endpoint but in the prints\n\n---\n\nThe issue is with how the request model is being parsed, I have identified the sources of the regressions and have linked them. I am happy to submit a patch that resolves these bugs\n\n---\n\nRef.: Breaking in the handling of default value in x-url-encoded forms\n\n*test.py*\n\n```python\n\nfrom fastapi.testclient import TestClient\nfrom main import app\n\n\ndef test_root():\n    client = TestClient(app)\n    response = client.post(\"/\", data={}) # corrected\n    assert response.status_code == 200\n```\n\n```command-line\n\npytest test.py -svv\n```\n\nTest result:\n\n```command-line\n\ncollected 1 item                                                                                                                                                             \n\ntest.py::test_root None\nPASSED\n\n```\n\n\n@MarinPostma: Can you describe how do you pass the `name` value into the form? (I can't reproduce your result.)\n\n---\n\nName is passed as an empty field which is a behavior that we observed http clients to have. Inspecting the code we can see that this was handled before by fastapi which coerces empty string value in forms as the absence of the field, later on code was added that overridden this behavior (I linked to the code that does that in the report). From the or descriptions, it seems that this change is not intentional", "source": "issue", "type": "qa_comprehensive", "issue_number": 66}
{"instruction": "Debug and solve this technical issue: Multiple regressions in the handling of forms & form validation", "input": "### Issue Content\n\nWe have found at least 2 regression in the way forms are handled while trying to migrate to v0.115.11 from version v0.112.4. After investigation we were able to identify 2 commits that introduce 2 separate bugs that break the handling of default values in both `x-form-urlencoded` and `mutlipart` froms. Partial fixes have been proposed that also address a CVE, but the PR has been hanging since october 24.\n\n# Breaking in the handling of default value in `x-url-encoded` forms\n\nThis bug has been introduced in https://github.com/fastapi/fastapi/pull/12134.\n\nMRE:\n```python\napp = FastAPI()\n\n\n@app.post(\"/\")\ndef root(\n    name: Annotated[Optional[str], Form(embed=True)] = None,\n):\n    print(name)\n    return name\n```\n\nwith the following request:\n```\nâ¯ http post -v --form localhost:8888 name=\"\"\nPOST / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate, br, zstd\nConnection: keep-alive\nContent-Length: 5\nContent-Type: application/x-www-form-urlencoded\nHost: localhost:8888\nUser-Agent: xh/0.24.0\n\nname=\n\nHTTP/1.1 200 OK\nContent-Length: 2\nContent-Type: application/json\nDate: Sun, 23 Mar 2025 21:01:49 GMT\nServer: uvicorn\n\n\"\"\n```\nThe expected result is that `None` is printed, but instead `\"\"` is printed.\n\nthis is the offending bit from the linked PR:\n```\ndiff --git a/fastapi/dependencies/utils.py b/fastapi/dependencies/utils.py\nindex 6083b731..db7eedba 100644\n--- a/fastapi/dependencies/utils.py\n+++ b/fastapi/dependencies/utils.py\n@@ -789,9 +789,9 @@ async def _extract_form_body(\n             value = serialize_sequence_value(field=field, value=results)\n         if value is not None:\n             values[field.name] = value\n-    for key, value in received_body.items():\n-        if key not in values:\n-            values[key] = value\n+    # for key, value in received_body.items():\n+    #     if key not in values:\n+    #         values[key] = value\n     return values\n```\nThis patch solves the x-form-urlencoded  case. So we indeed have two different regressions.\nThis _get_multi_dict_value  gets called for all fields in the schema: https://github.com/fastapi/fastapi/blob/4633b1bca933e68dac5c3bcce797ff5963debe2a/fastapi/dependencies/utils.py#L765-L765\nwe see here the special case for empty fields: https://github.com/fastapi/fastapi/blob/4633b1bca933e68dac5c3bcce797ff5963debe2a/fastapi/dependencies/utils.py#L695-L700\nThis bit here just blindly re-adds all fields from the body:    https://github.com/fastapi/fastapi/blob/4633b1bca933e68dac5c3bcce797ff5963debe2a/fastapi/dependencies/utils.py#L794-L796\n\nThis would be partially fixed by https://github.com/fastapi/fastapi/pull/12502/files, but also requires that ignored fields are not re-added to the form.\n\n\n# Breaking in the handling of default value in `multipart` forms\n\nThe breaking of multipart form originates from https://github.com/fastapi/fastapi/pull/12117 where the check for empty field was dropped https://github.com/fastapi/fastapi/pull/12117/files#diff-aef3dac481b68359f4edd6974fa3a047cfde595254a4567a5", "output": "@MarinPostma: You are not specifying the response model.", "source": "issue", "type": "qa_technical", "issue_number": 66}
{"instruction": "Allow json/BaseModels in query parameters\n\nDetails:\n### Is your feature request related to a problem\r\n\r\nI have to support getting a structured json string as parameter:\r\n<img width=\"891\" alt=\"Screenshot 2020-01-17 at 22 08 55\" src=\"https://user-images.githubusercontent.com/2737108/72646249-f86be980-3975-11ea-9e3c-3ea7816fd1e1.png\">\r\n\r\n```url\r\nhttps://localhost:8080/test?moop={\"name\": \"something %26 something else\",\"description\": \"str\" ,\"price\": 0.2,\"tax\": 0.2}&foo=bar\r\n```\r\n\r\nI would like to have a easy validation for those fields as well, as this could be automatic\r\n\r\n### The solution you would like\r\n\r\n```python\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Json[Item] = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\n<details><summary>Initial version:</summary>\r\n\r\n\r\nThis was the initial thought, before I discovered the `Json` type.\r\n```python\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Item = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\n</details>\r\n\r\n### Bug you face\r\n\r\n```py\r\nAssertionError: Param: moop can only be a request body, using Body(...)\r\n```\r\n\r\n### Describe alternatives you've considered\r\n\r\n```py\r\n    moop: str\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "Funny, using `moop: Json` is working:     \r\n\r\n```py\r\nfrom pydantic.types import Json\r\n\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Json = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    moop = Item(moop)\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\nbut  `moop: Json[Item]` is not working:\r\n\r\n```py\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Json[Item] = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\nis failing with:\r\n```py\r\nFile \"/path/to/project/main.py\", line 482, in <module>\r\n  from .views.api.v4_5.sendable import routes as sendable_routes\r\nFile \"/path/to/project/views/api/v4_5/sendable.py\", line 85, in <module>\r\n  foo: str = Query(...),\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/routing.py\", line 487, in decorator\r\n  callbacks=callbacks,\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/routing.py\", line 431, in add_api_route\r\n  callbacks=callbacks,\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/routing.py\", line 334, in __init__\r\n  self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/dependencies/utils.py\", line 305, in get_dependant\r\n  ), f\"Param: {param_field.name} can only be a request body, using Body(...)\"\r\nAssertionError: Param: moop can only be a request body, using Body(...)\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 65}
{"instruction": "Provide a comprehensive answer to this question: Allow json/BaseModels in query parameters", "input": "### Is your feature request related to a problem\r\n\r\nI have to support getting a structured json string as parameter:\r\n<img width=\"891\" alt=\"Screenshot 2020-01-17 at 22 08 55\" src=\"https://user-images.githubusercontent.com/2737108/72646249-f86be980-3975-11ea-9e3c-3ea7816fd1e1.png\">\r\n\r\n```url\r\nhttps://localhost:8080/test?moop={\"name\": \"something %26 something else\",\"description\": \"str\" ,\"price\": 0.2,\"tax\": 0.2}&foo=bar\r\n```\r\n\r\nI would like to have a easy validation for those fields as well, as this could be automatic\r\n\r\n### The solution you would like\r\n\r\n```python\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Json[Item] = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\n<details><summary>Initial version:</summary>\r\n\r\n\r\nThis was the initial thought, before I discovered the `Json` type.\r\n```python\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Item = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\n</details>\r\n\r\n### Bug you face\r\n\r\n```py\r\nAssertionError: Param: moop can only be a request body, using Body(...)\r\n```\r\n\r\n### Describe alternatives you've considered\r\n\r\n```py\r\n    moop: str\r\n```", "output": "Funny, using `moop: Json` is working:     \r\n\r\n```py\r\nfrom pydantic.types import Json\r\n\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Json = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    moop = Item(moop)\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\nbut  `moop: Json[Item]` is not working:\r\n\r\n```py\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Json[Item] = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\nis failing with:\r\n```py\r\nFile \"/path/to/project/main.py\", line 482, in <module>\r\n  from .views.api.v4_5.sendable import routes as sendable_routes\r\nFile \"/path/to/project/views/api/v4_5/sendable.py\", line 85, in <module>\r\n  foo: str = Query(...),\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/routing.py\", line 487, in decorator\r\n  callbacks=callbacks,\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/routing.py\", line 431, in add_api_route\r\n  callbacks=callbacks,\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/routing.py\", line 334, in __init__\r\n  self.dependant = get_dependant(path=self.path_format, call=self.endpoint)\r\nFile \"/path/to/3.7.venv/lib/python3.7/site-packages/fastapi/dependencies/utils.py\", line 305, in get_dependant\r\n  ), f\"Param: {param_field.name} can only be a request body, using Body(...)\"\r\nAssertionError: Param: moop can only be a request body, using Body(...)\r\n```\n\n---\n\nI think what's happening here is that FastAPI tries to only allow certain types to be parsed automatically from query parameters (presumably to limit confusion where you are expecting it to parse that data from the *body*, rather than the query parameters; obviously not relevant in *this* case).\r\n\r\nWhen you pass `Json`, the implicit generic parameter is treated as `Any`, which is apparently being allowed. (My guess is this is somehow related to the fact that `Json[Any]` could be parsing a `str`, for example, which is allowed as a query parameter by FastAPI.)\r\n\r\nHowever, when you say `Json[Item]`, you are now making it clear you want to parse a dict out of the query parameters, but fastapi explicitly only allows parsing primitives or sequences of primitives, so that's why you are getting this error.\r\n\r\nIt's a little less ergonomic, but I would recommend creating a custom dependency that parses the query string into the type you want. Something like:\r\n\r\n```python\r\ndef get_moop(moop: Json[Any] = Query(..., description='Something something')) -> Item:\r\n    return Item.parse_obj(moop)\r\n\r\nasync def test(\r\n    moop: Item = Depends(get_moop),\r\n    foo: str = Query(...),\r\n):\r\n```\r\n\r\n------\r\n\r\nFrom what I gather, the [OpenAPI spec](https://swagger.io/docs/specification/describing-parameters/#query-parameters) *does* allow you to pass objects as query parameter values, so in theory I don't see why this shouldn't be supported. But as far as I can tell, it isn't supported right now.\r\n\r\nI'd be happy to review a PR if someone cared to put in the work to implement this. (Note: you might have to manually parse the raw query string, since I'm not sure if starlette will do that automatically for objects.)\n\n---\n\n@dmontagu  \r\nInterestingly, using `Json` as the type already converts the argument to a valid python objects, in this case a dict.\r\n\r\nSo basically all whats left is throwing tat json data already parsed as python primitives into the normal object loader if a square bracket thing is found.\r\n\r\nHowever, I don't really understand the current code which is raising an error, what I have to change there, and I also don't know what's the best place to add that transformation.\r\n**If I get some pointers there, I'd love to fix that**.\r\n\r\nFor example I have no clue what `get_dependant` and `is_scalar_field` does in the end.\n\n---\n\n@dmontagu Going back to the original post I now edited:\r\nI'm not sure which is better,\r\n- `variable: Json[SomeType] = Query(...)`\r\n- `variable: SomeType = Query(...)`.\r\n\r\nI believe the first step is to recognize that json should be allowed as `Query`.\r\nI don't know if that `Json` type is for cases in the body where there would be an actual json encoded string.\r\nSo the `\"real_json\"` key in the following example:\r\n```json\r\n{\r\n    \"real_json\": \"{\\\"sample_text\\\": \\\"foobar\\\"}\",\r\n    \"not_json\": {\"sample_text\": \"foobar\"}\r\n}\r\n```\r\nI wonder how extendable that is, because I imagine it could also contain XML or some other format as well. (I dunnow, can we parse XML by chance, or have other json-like formats?)\r\n\r\nAs starlette correctly parses `field: Json` to be a python dict/list/int/float/None object, I'd actually rather go with `Json`.\n\n---\n\nWith the previous comment in mind I see the following cases:\r\n\r\n1. `variable: SomeType`: Use the json body, and load the `\"variable\": {...}` part as `SomeType`.\r\n2. `variable: Json[SomeType]`: Use the json body, and decode the json encoded`\"variable\": \"{...}\"` and  then load the part as `SomeType`.\r\n3. `variable: SomeType = Query(...)`: \r\n  Should that be indeed an error?\r\n  Like maybe `AssertionError: Param: variable containing a model can only be a part of a request body, using the value Body(...) or of type Json or Json[...] using the value Query(...) or Path(...)`\r\n4. `variable: Json[SomeType] = Query(...)`: We specified we wanna use the query parameter as Json, and thus we do the same lo\r\n5. `variable: Json = Query(...)`: We specified we wanna use the query parameter as Json, but no model, so we keep parsing the json to python native types. This is how it already works.\r\n6. `variable: Json[SomeType] = Query(...)`: We specified we wanna use the query parameter as Json, and because we specified some type, that is validated and loaded in the typical Pydantic way.\r\n7. `variable: Json = Path(...)`: See `variable: Json = Query(...)`.\r\n8. `variable: Json[SomeType] = Path(...)`: See `variable: Json[SomeType] = Query(...)`.", "source": "issue", "type": "qa_comprehensive", "issue_number": 65}
{"instruction": "Automatically support HEAD method for all GET routes, as Starlette does\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nimport pytest\r\nfrom fastapi.testclient import TestClient\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n\r\nclient = TestClient(app)\r\n\r\ndef test_index_head():\r\n    response = client.head(\"/\")\r\n    assert response.status_code == 200\r\n```\r\n\r\n### Description\r\n\r\n* The above test fails because the HEAD request returns a 405.\r\n* This is counterintuitive.\r\n\r\n### The solution you would like\r\n\r\n* To better support the HTTP standard, all routes that handle GET methods should automatically handle HEAD methods, too.\r\n* This is similar to what Starlette's router already does: https://github.com/encode/starlette/issues/45\r\n* This should happen wi", "input": "Repository: FastAPI\nLabels: ", "output": "encode/starlette#45 is only about static FileResponse. I don't know how a default should be set for a dynamic API.", "source": "issue", "type": "qa_best_answer", "issue_number": 64}
{"instruction": "Provide a comprehensive answer to this question: Automatically support HEAD method for all GET routes, as Starlette does", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nimport pytest\r\nfrom fastapi.testclient import TestClient\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n\r\nclient = TestClient(app)\r\n\r\ndef test_index_head():\r\n    response = client.head(\"/\")\r\n    assert response.status_code == 200\r\n```\r\n\r\n### Description\r\n\r\n* The above test fails because the HEAD request returns a 405.\r\n* This is counterintuitive.\r\n\r\n### The solution you would like\r\n\r\n* To better support the HTTP standard, all routes that handle GET methods should automatically handle HEAD methods, too.\r\n* This is similar to what Starlette's router already does: https://github.com/encode/starlette/issues/45\r\n* This should happen wi", "output": "encode/starlette#45 is only about static FileResponse. I don't know how a default should be set for a dynamic API.\n\n---\n\nNot so, if you look at the related commit at https://github.com/encode/starlette/pull/132/files in `starlette/routing.py`, you can see Starlette adds `HEAD` methods automatically for every `Route` that supports `GET`, regardless of whether they are `FileResponse` or not.\r\n\r\nMany web frameworks do this by default too, e.g. Flask (https://flask.palletsprojects.com/en/1.1.x/quickstart/#http-methods) and Django. It makes sense to do that because a server should respond to an `HTTP HEAD` request as defined in the spec, see e.g.:\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD\r\n\r\n\"The HTTP HEAD method requests the headers that are returned if the specified resource would be requested with an HTTP GET method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.\"\r\n\r\nClients use this for cache invalidation. The server just needs to run the route method, respond with the headers but discard the response body. Ideally, FastAPI would automatically add an OPTIONS method handler, too. This would help make FastAPI a first class web framework.\r\n\r\nThis is safe even for a dynamic API, because to follow REST principles, HTTP GET routes should always be idempotent and have no side-effects (as should HEAD, PUT, DELETE, OPTIONS and TRACE). Only HTTP POSTs are allowed to have side effects (see https://tools.ietf.org/html/rfc7231#section-4.2.2).\r\n\r\nThis behavior could be controlled by a flag defaulting to true.\n\n---\n\nworking on this\n\n---\n\nThanks @matthewlloyd for the very clear argument and especially for the self-contained example, that helps a lot.\r\n\r\nIndeed, here in the spec: https://tools.ietf.org/html/rfc7231#section-4.3.2 it says:\r\n\r\n> The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET [...]\r\n\r\nAnd the OpenAPI spec doesn't say anything contradicting it, so FastAPI should support it.\r\n\r\nI think ideally, it should handle HEAD requests automatically for GET requests, without adding them to the OpenAPI schema. I think HEAD operations should be added to OpenAPI only when explicitly declared in the code (ideally).\r\n\r\n---\r\n\r\nThanks @victorphoenix3 for working on this! Let me know if you need any help with it.\n\n---\n\nAs a side note, today, when making a HEAD request, you get a 405 returned, which according to spec*, should include an \"Allow\" header. I'm not if this is FastAPI or an underlying library returning this 405 - but maybe it should be changed as well.\r\n\r\n* https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405", "source": "issue", "type": "qa_comprehensive", "issue_number": 64}
{"instruction": "Debug and solve this technical issue: Automatically support HEAD method for all GET routes, as Starlette does", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nimport pytest\r\nfrom fastapi.testclient import TestClient\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n\r\nclient = TestClient(app)\r\n\r\ndef test_index_head():\r\n    response = client.head(\"/\")\r\n    assert response.status_code == 200\r\n```\r\n\r\n### Description\r\n\r\n* The above test fails because the HEAD request returns a 405.\r\n* This is counterintuitive.\r\n\r\n### The solution you would like\r\n\r\n* To better support the HTTP standard, all routes that handle GET methods should automatically handle HEAD methods, too.\r\n* This is similar to what Starlette's router already does: https://github.com/encode/starlette/issues/45\r\n* This should happen without requiring the developer to do any additional work.\r\n\r\n### Describe alternatives you've considered\r\n\r\n* It's currently possible to do this manually by adding `@app.head` and a helper method for each route, but it's cumbersome:\r\n\r\n```\r\n@app.head(\"/\")\r\ndef read_root_head():\r\n    return Response()\r\n```\r\n\r\n* It could also be done using middleware, but that would incur a performance overhead.\r\n\r\n### Environment\r\n\r\n* OS: [e.g. Linux / Windows / macOS]: Linux\r\n* FastAPI Version [e.g. 0.3.0]: 0.60.1\r\n* Python version: 3.8.5", "output": "encode/starlette#45 is only about static FileResponse. I don't know how a default should be set for a dynamic API.", "source": "issue", "type": "qa_technical", "issue_number": 64}
{"instruction": "Multiple aliases for query parameters\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\nI would like to be able to do this:\r\n\r\n<!-- Replace the code below with your own self-contained, minimal, reproducible, example -->\r\n\r\n```Python\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef get(query: Optional[st", "input": "Repository: FastAPI\nLabels: ", "output": "It probably should accept a `str` as well or maybe an alternative solution could be a field `aliases`.", "source": "issue", "type": "qa_best_answer", "issue_number": 63}
{"instruction": "Provide a comprehensive answer to this question: Multiple aliases for query parameters", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\nI would like to be able to do this:\r\n\r\n<!-- Replace the code below with your own self-contained, minimal, reproducible, example -->\r\n\r\n```Python\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef get(query: Optional[st", "output": "It probably should accept a `str` as well or maybe an alternative solution could be a field `aliases`.\n\n---\n\n> It probably should accept a `str` as well or maybe an alternative solution could be a field `aliases`.\r\n\r\nYes, my intention was not to break compatibility and make it accept both an `str` and a `Iterable[str]`, I'll edit my issue to make it more clear\n\n---\n\n`alias` goes from pydantic so we can't make in on FastAPI layer (there is`__slots__` defined for base class) as I can se it for now\n\n---\n\n> `alias` goes from pydantic so we can't make in on FastAPI layer (there is`__slots__` defined for base class) as I can se it for now\n\nThat sucks.\nMaybe duplicate the query parameter object for each alias?\n\n---\n\nAt first I think you should look/open similar issue for Pydantic. Maybe there some workarounds or it's planned feature. Multiple params forone object seems wrong", "source": "issue", "type": "qa_comprehensive", "issue_number": 63}
{"instruction": "Making file field as Optional\n\nDetails:\nI've a form-data request for user signUp process. \r\nThe user can or can't upload it's picture it's optional. \r\nI've created a api, with field types as form and for image as Uploadfile everything works perfect but it is making the image field as required. \r\nIs it possible to make the file input as optional.. \r\nDo share any reference docs..", "input": "Repository: FastAPI\nLabels: ", "output": "Can you add a minimal reproducible example? It's hard to help.", "source": "issue", "type": "qa_best_answer", "issue_number": 62}
{"instruction": "Provide a comprehensive answer to this question: Making file field as Optional", "input": "I've a form-data request for user signUp process. \r\nThe user can or can't upload it's picture it's optional. \r\nI've created a api, with field types as form and for image as Uploadfile everything works perfect but it is making the image field as required. \r\nIs it possible to make the file input as optional.. \r\nDo share any reference docs..", "output": "Can you add a minimal reproducible example? It's hard to help.\n\n---\n\nyou could add like `file: bytes =File(None)` or `file: bytes = File(b'')` and check if its not none or empty like `if file is not None:` or `if file:`\n\n---\n\nwhen you add a default value it became optional\n\n---\n\n> Can you add a minimal reproducible example? It's hard to help.\r\n\r\nasync def send_mail(sender:EmailStr=Form(...), recipient:List[EmailStr]=Form(...),content:str=Form(...),attachments:List[UploadFile]= File(...)):\r\n\r\nI want to make attachments as optional\n\n---\n\n> you could add like `file: bytes =File(None)` or `file: bytes = File(b'')` and check if its not none or empty like `if file is not None:` or `if file:`\r\nasync def send_mail(sender:EmailStr=Form(...), recipient:List[EmailStr]=Form(...),content:str=Form(...),attachments:List[UploadFile]= File(...)):\r\nI need to use UploadFile as I've send it to attachments and when I replace it with  attachments:List[UploadFile]= File(None)\r\nand run function without selecting file It gives me below error \r\n{\r\n  \"detail\": [\r\n    {\r\n      \"loc\": [\r\n        \"body\",\r\n        \"attachments\",\r\n        0\r\n      ],\r\n      \"msg\": \"Expected UploadFile, received: <class 'str'>\",\r\n      \"type\": \"value_error\"\r\n    }\r\n  ]\r\n}", "source": "issue", "type": "qa_comprehensive", "issue_number": 62}
{"instruction": "Error loading ASGI app. Could not import module \"src.main\"\n\nDetails:\n### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nfrom fastapi import Depends, FastAPI, HTTPException, status\r\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\r\nfrom fastapi.security.oauth2 import OAuth2PasswordRequestForm\r\nfrom . import models\r\nfrom . import services\r\nfrom .database import engine, get_db\r\nfrom passlib.context import CryptContext\r\nfrom sqlalchemy.orm import Session\r\nfrom datetime import datetime, timedelta\r\n\r\napp = FastAPI()\r\n\r\noauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')\r\n\r\npwd_context = CryptContext(schemes=['bcrypt'], depracated='auto')\r\n\r\nmodels.Base.metadata.create_all(bind=engine)\r\n\r\nSECRET_KEY = '[SECRET KEY]'\r\nALGORITHM = 'HS256'\r\nACCESS_TOKEN_EXPIRE_MINUTES = 30\r\n\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\r\n    \r\n@app.get(\"/test/\")\r\nasync def test(token:str = Depends(oauth2_scheme)):\r\n    return {'token', token}\r\n\r\n@app.post('/login/{method}')\r\nasync def login(method: str, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db), ):\r\n    user = services.authenticate_user(form_data.username, form_data.password)\r\n    if not user:\r\n        raise HTTPException(\r\n            ", "input": "Repository: FastAPI\nLabels: ", "output": "Can you give us your directory structure and the directory you are in when you run your uvicorn command?\n\nYou should be in the same directory as your main file to run `uvicorn main:app` so it will go to the main.py file and find the app object", "source": "issue", "type": "qa_best_answer", "issue_number": 61}
{"instruction": "Provide a comprehensive answer to this question: Error loading ASGI app. Could not import module \"src.main\"", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nfrom fastapi import Depends, FastAPI, HTTPException, status\r\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\r\nfrom fastapi.security.oauth2 import OAuth2PasswordRequestForm\r\nfrom . import models\r\nfrom . import services\r\nfrom .database import engine, get_db\r\nfrom passlib.context import CryptContext\r\nfrom sqlalchemy.orm import Session\r\nfrom datetime import datetime, timedelta\r\n\r\napp = FastAPI()\r\n\r\noauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')\r\n\r\npwd_context = CryptContext(schemes=['bcrypt'], depracated='auto')\r\n\r\nmodels.Base.metadata.create_all(bind=engine)\r\n\r\nSECRET_KEY = '[SECRET KEY]'\r\nALGORITHM = 'HS256'\r\nACCESS_TOKEN_EXPIRE_MINUTES = 30\r\n\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\r\n    \r\n@app.get(\"/test/\")\r\nasync def test(token:str = Depends(oauth2_scheme)):\r\n    return {'token', token}\r\n\r\n@app.post('/login/{method}')\r\nasync def login(method: str, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db), ):\r\n    user = services.authenticate_user(form_data.username, form_data.password)\r\n    if not user:\r\n        raise HTTPException(\r\n            ", "output": "Can you give us your directory structure and the directory you are in when you run your uvicorn command?\n\nYou should be in the same directory as your main file to run `uvicorn main:app` so it will go to the main.py file and find the app object\n\n---\n\n> Can you give us your directory structure and the directory you are in when you run your uvicorn command?\r\n> \r\n> You should be in the same directory as your main file to run `uvicorn main:app` so it will go to the main.py file and find the app object\r\n\r\n![image](https://user-images.githubusercontent.com/25674730/135541526-2cd340c6-0073-447b-8e64-9dd77555a997.png)\n\n---\n\nWhere are you running your command from? what is the directory? Could you run `pwd` and an `ls`\n\n---\n\npwd:\r\n`/home/bilalharoon/Projects/Kalaam/kalaam-fastapi/src`\r\n\r\nls from inside src\r\n`__init__.py  __pycache__  database.py  main.py  models.py  schemas.py  services.py`\r\n\r\nls from outside src\r\n`alembic  kalaam.db  requirements.txt  src  venv`\n\n---\n\nand `uvicorn main:app --reload` isnt working? Can you share the console output?", "source": "issue", "type": "qa_comprehensive", "issue_number": 61}
{"instruction": "Debug and solve this technical issue: Error loading ASGI app. Could not import module \"src.main\"", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nfrom fastapi import Depends, FastAPI, HTTPException, status\r\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\r\nfrom fastapi.security.oauth2 import OAuth2PasswordRequestForm\r\nfrom . import models\r\nfrom . import services\r\nfrom .database import engine, get_db\r\nfrom passlib.context import CryptContext\r\nfrom sqlalchemy.orm import Session\r\nfrom datetime import datetime, timedelta\r\n\r\napp = FastAPI()\r\n\r\noauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')\r\n\r\npwd_context = CryptContext(schemes=['bcrypt'], depracated='auto')\r\n\r\nmodels.Base.metadata.create_all(bind=engine)\r\n\r\nSECRET_KEY = '[SECRET KEY]'\r\nALGORITHM = 'HS256'\r\nACCESS_TOKEN_EXPIRE_MINUTES = 30\r\n\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\r\n    \r\n@app.get(\"/test/\")\r\nasync def test(token:str = Depends(oauth2_scheme)):\r\n    return {'token', token}\r\n\r\n@app.post('/login/{method}')\r\nasync def login(method: str, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db), ):\r\n    user = services.authenticate_user(form_data.username, form_data.password)\r\n    if not user:\r\n        raise HTTPException(\r\n            status_code=status.HTTP_401_UNAUTHORIZED,\r\n            detail=\"Incorrect username or password\",\r\n            headers={\"WWW-Authenticate\": \"Bearer\"},\r\n        )\r\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\r\n    access_token = services.create_access_token(\r\n        data={\"username\": user.username, \"email\": user.email}, expires_delta=access_token_expires\r\n    )\r\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n```\n\n\n### Description\n\nI saw the solution is changing 'main' -> 'src.main' so I tried that, but the same problem is occuring Even if I use 'cd src' to move to src and run 'uvicorn main:app --reload', errors continue. What do I need?\n\n### Operating System\n\nLinux\n\n### Operating System Details\n\nWSL 2\n\n### FastAPI Version\n\n0.68.1\n\n### Python Version\n\n3.8.10\n\n### Additional Context\n\n_No response_", "output": "Can you give us your directory structure and the directory you are in when you run your uvicorn command?\n\nYou should be in the same directory as your main file to run `uvicorn main:app` so it will go to the main.py file and find the app object", "source": "issue", "type": "qa_technical", "issue_number": 61}
{"instruction": "Production configuration of gunicorn\n\nDetails:\nNOTE: I'm not sure whether i should be filing this here or upstream on starlette. Please let me know if Starlette developers are more knowledgeable about this. However, I'm using fastapi.\r\n\r\nWhat is a good configuration setting for gunicorn in production.\r\n\r\nOn reading documentation of gunicorn with uvicorn, there are lines like this \r\n\r\n> \"Gunicorn provides a different set of configuration options to Uvicorn, so some options such as --limit-concurrency are not yet supported when running with Gunicorn\"\r\n\r\nIs it possible for you to share a list of options that work well ? One of the biggest question is around threads - should we set the threads option?\r\nwhat about stuff like \"worker_connections\" , \"keepalive\" (especially in context of async code)", "input": "Repository: FastAPI\nLabels: ", "output": "This might be a reasonable starting point: https://github.com/tiangolo/uvicorn-gunicorn-docker/blob/master/python3.7/gunicorn_conf.py\r\n\r\nBut it doesn't go into much depth on the available options.\r\n\r\nThe starlette and uvicorn repos would also be good places to ask this question / search for related issues.", "source": "issue", "type": "qa_best_answer", "issue_number": 60}
{"instruction": "Provide a comprehensive answer to this question: Production configuration of gunicorn", "input": "NOTE: I'm not sure whether i should be filing this here or upstream on starlette. Please let me know if Starlette developers are more knowledgeable about this. However, I'm using fastapi.\r\n\r\nWhat is a good configuration setting for gunicorn in production.\r\n\r\nOn reading documentation of gunicorn with uvicorn, there are lines like this \r\n\r\n> \"Gunicorn provides a different set of configuration options to Uvicorn, so some options such as --limit-concurrency are not yet supported when running with Gunicorn\"\r\n\r\nIs it possible for you to share a list of options that work well ? One of the biggest question is around threads - should we set the threads option?\r\nwhat about stuff like \"worker_connections\" , \"keepalive\" (especially in context of async code)", "output": "This might be a reasonable starting point: https://github.com/tiangolo/uvicorn-gunicorn-docker/blob/master/python3.7/gunicorn_conf.py\r\n\r\nBut it doesn't go into much depth on the available options.\r\n\r\nThe starlette and uvicorn repos would also be good places to ask this question / search for related issues.\n\n---\n\nI started mine off from a gunicorn example https://github.com/benoitc/gunicorn/blob/master/examples/example_config.py\r\n\r\nThen set mine like this - https://github.com/devsetgo/test-api/blob/master/app/gunicorn_cfg.py\r\n\r\nFrom my experience, i have found that I really just need to set workers, bind, port, and for starlette/fastapi the worker class is what makes uvicorn work with gunicorn.\n\n---\n\nHi mike\nAre you setting threads in gunicorn ? Im not sure if the Uvicorn worker\nplays well with threads.\n\nWhat's the things you tune for in production?\n\nOn Sun, 22 Sep, 2019, 05:29 Mike Ryan, <notifications@github.com> wrote:\n\n> I started mine off from a gunicorn example\n> https://github.com/benoitc/gunicorn/blob/master/examples/example_config.py\n>\n> Then set mine like this -\n> https://github.com/devsetgo/test-api/blob/master/app/gunicorn_cfg.py\n>\n> From my experience, i have found that I really just need to set workers,\n> bind, port, and for starlette/fastapi the worker class is what makes\n> uvicorn work with gunicorn.\n>\n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/551?email_source=notifications&email_token=AAASYU2O5KBYPNMLAPO63UDQK2YONA5CNFSM4IYM5US2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7I3T4Q#issuecomment-533838322>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAASYU67APO7ZOC4ELT2LWDQK2YONANCNFSM4IYM5USQ>\n> .\n>\n\n---\n\nThe item I am most concerned with for **_my_** production use are the number of workers. For async I've tried a couple different worker classes, but didn't see much change. So I just use uvicorn.workers.UvicornWorker. I set the backlog of connections, but I haven't ever found it to be an issue.\r\n\r\nIn my opinion, I don't think threads will matter. Threads I presume will matter more if you are kicking on new threads using multi-threading. I've not tried threads with Gunicorn for sync or async, so that could be an incorrect assessment. \r\n\r\nI've done some testing of my test-api using WRK and connecting to my server 1000 miles away (1600 Km). So far with 9 workers running (4 cores x 2 + 1) I max out just below 6k requests per second. I find that Traefik and Let'sEncrypt drops that to 2k (research area). A single core (1 x 2 + 1) I can get around 2k requests per second (drops to 1k with Traefik/LetsEncrypt). I eventually plan to do more tests, but this is good enough for my use and horizontal scaling would increase this easily.\n\n---\n\nThanks for that info.\n\nWhat tuning are you doing for backlog? Would love to know learnings here.\n\nP.S. we are using haproxy - we find the config to be simpler and much\nhigher performance.\n\nOn Sun, 22 Sep, 2019, 23:04 Mike Ryan, <notifications@github.com> wrote:\n\n> The item I am most concerned with for *my* production use are the number\n> of workers. For async I've tried a couple different worker classes, but\n> didn't see much change. So I just use\n>\n> *uvicorn.workers.UvicornWorker*\n>\n> . I set the backlog of connections, but I haven't ever found it to be an\n> issue.\n>\n> In my opinion, I don't think threads will matter. Threads I presume will\n> matter more if you are kicking on new threads using multi-threading. I've\n> not tried threads with Gunicorn for sync or async, so that could be an\n> incorrect assessment.\n>\n> I've done some testing of my test-api using WRK and connecting to my\n> server 1000 miles away (1600 Km). So far with 9 workers running (4 cores x\n> 2 + 1) I max out just below 6k requests per second. I find that Traefik and\n> Let'sEncrypt drops that to 2k (research area). A single core (1 x 2 + 1) I\n> can get around 2k requests per second (drops to 1k with\n> Traefik/LetsEncrypt). I eventually plan to do more tests, but this is good\n> enough for my use and horizontal scaling would increase this easily.\n>\n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/551?email_source=notifications&email_token=AAASYU4BZE6RGPLLJIFBG43QK6UA3A5CNFSM4IYM5US2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD7JLAJA#issuecomment-533901348>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAASYUZLA7OCYKPTOCRBJBTQK6UA3ANCNFSM4IYM5USQ>\n> .\n>", "source": "issue", "type": "qa_comprehensive", "issue_number": 60}
{"instruction": "Dependency Models created from Form input data are loosing metadata(field set) and are enforcing validation on default values.\n\nDetails:\n### Discussed in https://github.com/fastapi/fastapi/discussions/13380\n\n<div type='discussions-op-text'>\n\n<sup>Originally posted by **sneakers-the-rat** February 16, 2025</sup>\n### First Check\n\n- [X] I added a very descriptive title here.\n- [X] I used the GitHub search to find a similar question and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n**Short version (UPD by @YuriiMotov):**\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Form\nfrom fastapi.testclient import TestClient\nfrom pydantic import BaseModel\n\nclass ExampleModel(BaseModel):\n    field_1: bool = True\n\napp = FastAPI()\n\n@app.post(\"/body\")\nasync def body_endpoint(model: ExampleModel):\n    return {\"fields_set\": list(model.model_fields_set)}\n\n@app.post(\"/form\")\nasync def form_endpoint(model: Annotated[ExampleModel, Form()]):\n    return {\"fields_set\": list(model.model_fields_set)}\n\nclient = TestClient(app)\n\ndef test_body():\n    resp = client.post(\"/body\", json={})\n    assert resp.status_code == 200, resp.text\n    fields_set = resp.json()[\"fields_set\"]\n    assert fields_set == []  # Ok\n\ndef test_form():\n    resp = client.post(\"/form\", data={})\n    assert resp.status_code == 200, resp.text\n    fields_set = resp.json()[\"fields_set\"]\n    assert fields_set == []  # AssertionError: assert ['field_1'] == []\n```\n\n**Original code (in details):**\n\n<details>\n\n", "input": "Repository: FastAPI\nLabels: ", "output": "I'd like to contribute to this - \n\nTrying to scope out what a fix might look like here: \n\nThe most minimal change might look something like just replacing these lines with just `return` : https://github.com/fastapi/fastapi/blob/f8878f3a98057c6ab6161d2577fab49087ba7015/fastapi/dependencies/utils.py#L733-L736\n\nThat would pass an explicit `None` that could be used in a `before` model validator to differentiate the form input case from the json input case, even if it is a bit implicit. \n\nThe second idea that would also fix my case, and might be nice to have in general, is an additional `@form_validator` decorator that someone can use to process values after they are extracted from the form but before the rest of the pydantic validation process. This would make a more explicit means of handling the quirks of form encoding.\n\nIt seems like there is a decent amount of additional logic in the input handling that might come from needing to maintain compatibility with old pydantic versions? In the most naÃ¯ve implementation, one might expect there to be no additional logic beyond (a) formencoded data -> dict, (b) instantiate model, (c) optionally report errors. So maybe the most complex fix would be to try and remove that handling when used with pydantic v2 and just use its error handling that includes locations? From my reading it looks like the code is already mostly ready for it, but to the degree that we can decouple form handling, we might be able to set us up for being able to handle multiple content types in the same endpoint. \n\nLet me know if you have a preferred form of the fix for this, otherwise I can get working on a fix that passes the above tests", "source": "issue", "type": "qa_best_answer", "issue_number": 59}
{"instruction": "Provide a comprehensive answer to this question: Dependency Models created from Form input data are loosing metadata(field set) and are enforcing validation on default values.", "input": "### Discussed in https://github.com/fastapi/fastapi/discussions/13380\n\n<div type='discussions-op-text'>\n\n<sup>Originally posted by **sneakers-the-rat** February 16, 2025</sup>\n### First Check\n\n- [X] I added a very descriptive title here.\n- [X] I used the GitHub search to find a similar question and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n**Short version (UPD by @YuriiMotov):**\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Form\nfrom fastapi.testclient import TestClient\nfrom pydantic import BaseModel\n\nclass ExampleModel(BaseModel):\n    field_1: bool = True\n\napp = FastAPI()\n\n@app.post(\"/body\")\nasync def body_endpoint(model: ExampleModel):\n    return {\"fields_set\": list(model.model_fields_set)}\n\n@app.post(\"/form\")\nasync def form_endpoint(model: Annotated[ExampleModel, Form()]):\n    return {\"fields_set\": list(model.model_fields_set)}\n\nclient = TestClient(app)\n\ndef test_body():\n    resp = client.post(\"/body\", json={})\n    assert resp.status_code == 200, resp.text\n    fields_set = resp.json()[\"fields_set\"]\n    assert fields_set == []  # Ok\n\ndef test_form():\n    resp = client.post(\"/form\", data={})\n    assert resp.status_code == 200, resp.text\n    fields_set = resp.json()[\"fields_set\"]\n    assert fields_set == []  # AssertionError: assert ['field_1'] == []\n```\n\n**Original code (in details):**\n\n<details>\n\n", "output": "I'd like to contribute to this - \n\nTrying to scope out what a fix might look like here: \n\nThe most minimal change might look something like just replacing these lines with just `return` : https://github.com/fastapi/fastapi/blob/f8878f3a98057c6ab6161d2577fab49087ba7015/fastapi/dependencies/utils.py#L733-L736\n\nThat would pass an explicit `None` that could be used in a `before` model validator to differentiate the form input case from the json input case, even if it is a bit implicit. \n\nThe second idea that would also fix my case, and might be nice to have in general, is an additional `@form_validator` decorator that someone can use to process values after they are extracted from the form but before the rest of the pydantic validation process. This would make a more explicit means of handling the quirks of form encoding.\n\nIt seems like there is a decent amount of additional logic in the input handling that might come from needing to maintain compatibility with old pydantic versions? In the most naÃ¯ve implementation, one might expect there to be no additional logic beyond (a) formencoded data -> dict, (b) instantiate model, (c) optionally report errors. So maybe the most complex fix would be to try and remove that handling when used with pydantic v2 and just use its error handling that includes locations? From my reading it looks like the code is already mostly ready for it, but to the degree that we can decouple form handling, we might be able to set us up for being able to handle multiple content types in the same endpoint. \n\nLet me know if you have a preferred form of the fix for this, otherwise I can get working on a fix that passes the above tests\n\n---\n\ni would like to take this, can some help me with starting things up\n\n---\n\nHello @Warlord-10  what do you need exactly?\n\n---\n\nreiterating my willingness to help as well :) some comment on desired approach, either among the options i described above or some different one, would be helpful <3\n\n---\n\nI noticed in case of **form handling**, `form` function is preloads the default values from the pydantic model and passes to the validator. As a result, the model's `model_fields_set` attribute includes all fields with default values, even if they were not explicitly set in the form submission. this makes it impossible to distinguish between fields that were explicitly set and fields that were simply assigned their defaults.\n\nWhile in **JSON Data Handling**, it does not preload the default values. The `model_fields_set` attribute only includes fields that were explicitly provided in the JSON payload.\n\n**Possible solution** could be to **create a custom function for form parsing** that will parse form data and only include fields that were explicitly provided during form submission.\n\n@luzzodev Let me know what you think about this.", "source": "issue", "type": "qa_comprehensive", "issue_number": 59}
{"instruction": "Debug and solve this technical issue: Dependency Models created from Form input data are loosing metadata(field set) and are enforcing validation on default values.", "input": "### Discussed in https://github.com/fastapi/fastapi/discussions/13380\n\n<div type='discussions-op-text'>\n\n<sup>Originally posted by **sneakers-the-rat** February 16, 2025</sup>\n### First Check\n\n- [X] I added a very descriptive title here.\n- [X] I used the GitHub search to find a similar question and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n**Short version (UPD by @YuriiMotov):**\n\n```python\nfrom typing import Annotated\n\nfrom fastapi import FastAPI, Form\nfrom fastapi.testclient import TestClient\nfrom pydantic import BaseModel\n\nclass ExampleModel(BaseModel):\n    field_1: bool = True\n\napp = FastAPI()\n\n@app.post(\"/body\")\nasync def body_endpoint(model: ExampleModel):\n    return {\"fields_set\": list(model.model_fields_set)}\n\n@app.post(\"/form\")\nasync def form_endpoint(model: Annotated[ExampleModel, Form()]):\n    return {\"fields_set\": list(model.model_fields_set)}\n\nclient = TestClient(app)\n\ndef test_body():\n    resp = client.post(\"/body\", json={})\n    assert resp.status_code == 200, resp.text\n    fields_set = resp.json()[\"fields_set\"]\n    assert fields_set == []  # Ok\n\ndef test_form():\n    resp = client.post(\"/form\", data={})\n    assert resp.status_code == 200, resp.text\n    fields_set = resp.json()[\"fields_set\"]\n    assert fields_set == []  # AssertionError: assert ['field_1'] == []\n```\n\n**Original code (in details):**\n\n<details>\n\nFile: fastapi_defaults_bug.py\n```python\nimport uvicorn\nfrom typing import Annotated\nfrom pydantic import BaseModel, Field\n\nfrom fastapi import FastAPI, Form\n\n\nclass ExampleJsonModel(BaseModel):\n    sample_field_1: Annotated[bool, Field(default=True)]\n    sample_field_2: Annotated[bool, Field(default=False)]\n    sample_field_3: Annotated[bool, Field(default=None)]\n    sample_field_4: Annotated[str, Field(default=0)] # This is dangerous but can be used with a validator\n\n\nclass ExampleFormModel(BaseModel):\n    sample_field_1: Annotated[bool, Form(default=True)]\n    sample_field_2: Annotated[bool, Form(default=False)]\n    sample_field_3: Annotated[bool, Form(default=None)]\n    sample_field_4: Annotated[str, Form(default=0)] # This is dangerous but can be used with a validator\n\n\nclass ResponseSampleModel(BaseModel):\n    fields_set: Annotated[list, Field(default_factory=list)]\n    dumped_fields_no_exclude: Annotated[dict, Field(default_factory=dict)]\n    dumped_fields_exclude_default: Annota", "output": "I'd like to contribute to this - \n\nTrying to scope out what a fix might look like here: \n\nThe most minimal change might look something like just replacing these lines with just `return` : https://github.com/fastapi/fastapi/blob/f8878f3a98057c6ab6161d2577fab49087ba7015/fastapi/dependencies/utils.py#L733-L736\n\nThat would pass an explicit `None` that could be used in a `before` model validator to differentiate the form input case from the json input case, even if it is a bit implicit. \n\nThe second idea that would also fix my case, and might be nice to have in general, is an additional `@form_validator` decorator that someone can use to process values after they are extracted from the form but before the rest of the pydantic validation process. This would make a more explicit means of handling the quirks of form encoding.\n\nIt seems like there is a decent amount of additional logic in the input handling that might come from needing to maintain compatibility with old pydantic versions? In the most naÃ¯ve implementation, one might expect there to be no additional logic beyond (a) formencoded data -> dict, (b) instantiate model, (c) optionally report errors. So maybe the most complex fix would be to try and remove that handling when used with pydantic v2 and just use its error handling that includes locations? From my reading it looks like the code is already mostly ready for it, but to the degree that we can decouple form handling, we might be able to set us up for being able to handle multiple content types in the same endpoint. \n\nLet me know if you have a preferred form of the fix for this, otherwise I can get working on a fix that passes the above tests", "source": "issue", "type": "qa_technical", "issue_number": 59}
{"instruction": "FastAPI keeps booting new workers when deploying\n\nDetails:\nHi there,\r\n\r\nI'm trying to run two different instances of FastAPI in the same Kubernetes pod (different Docker containers), but one of the two seems to keep booting up new workers. Therefor, the container uses a lot of CPU for nothing. It's also reporting that it's waiting for application startup constantly, but it is reachable (but slow).\r\n\r\nHere is the log that I keep getting:\r\n\r\n```\r\nChecking for script in /app/prestart.sh\r\nRunning script /app/prestart.sh\r\nRunning inside /app/prestart.sh, you could add migrations to this file, e.g.:\r\n #! /usr/bin/env bash\r\n # Let the DB start\r\nsleep 10;\r\n# Run migrations\r\nalembic upgrade head\r\n [2019-05-24 11:51:24 +0000] [1] [INFO] Starting gunicorn 19.9.0\r\n[2019-05-24 11:51:24 +0000] [1] [INFO] Listening at: http://0.0.0.0:8081 (1)\r\n[2019-05-24 11:51:24 +0000] [1] [INFO] Using worker: uvicorn.workers.UvicornWorker\r\n[2019-05-24 11:51:24 +0000] [8] [INFO] Booting worker with pid: 8\r\n[2019-05-24 11:51:24 +0000] [9] [INFO] Booting worker with pid: 9\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\n[2019-05-24 11:51:33 +0000] [9] [INFO] Started server process [9]\r\n[2019-05-24 11:51:33 +0000] [9] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:33 +0000] [8] [INFO] Started server process [8]\r\n[2019-05-24 11:51:33 +0000] [8] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:37 +0000] [18] [INFO] Booting worker with pid: 18\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\n[2019-05-24 11:51:44 +0000] [18] [INFO] Started server process [18]\r\n[2019-05-24 11:51:44 +0000] [18] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:45 +0000] [23] [INFO] Booting worker with pid: 23\r\nWARNING:root:email-validator not installed, email field", "input": "Repository: FastAPI\nLabels: ", "output": "Iirc there are no max workers set so I'd either tweak the gunicorn conf to\nset your number according to the server you deploy on, or set another env\nvar, can't remember on top of my head but it's in the docs I'm sure\n\nLe ven. 24 mai 2019 Ã  2:03 PM, SansDK <notifications@github.com> a Ã©crit :\n\n> Hi there,\n>\n> I'm trying to run two different instances of FastAPI in the same\n> Kubernetes pod (different Docker containers), but one of the two seems to\n> keep booting up new workers. Therefor, the container uses a lot of CPU for\n> nothing. It's also reporting that it's waiting for application startup\n> constantly, but it is reachable (but slow).\n>\n> Here is the log that I keep getting:\n>\n> Checking for script in /app/prestart.sh\n> Running script /app/prestart.sh\n> Running inside /app/prestart.sh, you could add migrations to this file, e.g.:\n>  #! /usr/bin/env bash\n>  # Let the DB start\n> sleep 10;\n> # Run migrations\n> alembic upgrade head\n>  [2019-05-24 11:51:24 +0000] [1] [INFO] Starting gunicorn 19.9.0\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Listening at: http://0.0.0.0:8081 (1)\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Using worker: uvicorn.workers.UvicornWorker\n> [2019-05-24 11:51:24 +0000] [8] [INFO] Booting worker with pid: 8\n> [2019-05-24 11:51:24 +0000] [9] [INFO] Booting worker with pid: 9\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:33 +0000] [9] [INFO] Started server process [9]\n> [2019-05-24 11:51:33 +0000] [9] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:33 +0000] [8] [INFO] Started server process [8]\n> [2019-05-24 11:51:33 +0000] [8] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:37 +0000] [18] [INFO] Booting worker with pid: 18\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:44 +0000] [18] [INFO] Started server process [18]\n> [2019-05-24 11:51:44 +0000] [18] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:45 +0000] [23] [INFO] Booting worker with pid: 23\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:53 +0000] [23] [INFO] Started server process [23]\n> [2019-05-24 11:51:53 +0000] [23] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:54 +0000] [28] [INFO] Booting worker with pid: 28\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:52:02 +0000] [28] [INFO] Started server process [28]\n> [2019-05-24 11:52:02 +0000] [28] [INFO] Waiting for application startup.\n>\n> This will continue untill I shut it down. This problem weirdly does not\n> happen when I run everything locally.\n>\n> A difference between local and remote deployment is probably only the port\n> that I set.\n> As you can see, I use port 8081:\n>\n> [INFO] Listening at: http://0.0.0.0:8081 (1)\n>\n> I set the port by specifying it in my Kubernetes yaml file, but I am\n> unsure if this has something to do with the problem.\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/253?email_source=notifications&email_token=AAINSPWLEJ53IUGIRMY2MDDPW7KQBA5CNFSM4HPO4Y32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVV7SAQ>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPTKBVSZMRPIDNLUCDTPW7KQBANCNFSM4HPO4Y3Q>\n> .\n>\n\nLe ven. 24 mai 2019 Ã  2:03 PM, SansDK <notifications@github.com> a Ã©crit :\n\n> Hi there,\n>\n> I'm trying to run two different instances of FastAPI in the same\n> Kubernetes pod (different Docker containers), but one of the two seems to\n> keep booting up new workers. Therefor, the container uses a lot of CPU for\n> nothing. It's also reporting that it's waiting for application startup\n> constantly, but it is reachable (but slow).\n>\n> Here is the log that I keep getting:\n>\n> Checking for script in /app/prestart.sh\n> Running script /app/prestart.sh\n> Running inside /app/prestart.sh, you could add migrations to this file, e.g.:\n>  #! /usr/bin/env bash\n>  # Let the DB start\n> sleep 10;\n> # Run migrations\n> alembic upgrade head\n>  [2019-05-24 11:51:24 +0000] [1] [INFO] Starting gunicorn 19.9.0\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Listening at: http://0.0.0.0:8081 (1)\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Using worker: uvicorn.workers.UvicornWorker\n> [2019-05-24 11:51:24 +0000] [8] [INFO] Booting worker with pid: 8\n> [2019-05-24 11:51:24 +0000] [9] [INFO] Booting worker with pid: 9\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> WARNING:root:emai", "source": "issue", "type": "qa_best_answer", "issue_number": 58}
{"instruction": "Provide a comprehensive answer to this question: FastAPI keeps booting new workers when deploying", "input": "Hi there,\r\n\r\nI'm trying to run two different instances of FastAPI in the same Kubernetes pod (different Docker containers), but one of the two seems to keep booting up new workers. Therefor, the container uses a lot of CPU for nothing. It's also reporting that it's waiting for application startup constantly, but it is reachable (but slow).\r\n\r\nHere is the log that I keep getting:\r\n\r\n```\r\nChecking for script in /app/prestart.sh\r\nRunning script /app/prestart.sh\r\nRunning inside /app/prestart.sh, you could add migrations to this file, e.g.:\r\n #! /usr/bin/env bash\r\n # Let the DB start\r\nsleep 10;\r\n# Run migrations\r\nalembic upgrade head\r\n [2019-05-24 11:51:24 +0000] [1] [INFO] Starting gunicorn 19.9.0\r\n[2019-05-24 11:51:24 +0000] [1] [INFO] Listening at: http://0.0.0.0:8081 (1)\r\n[2019-05-24 11:51:24 +0000] [1] [INFO] Using worker: uvicorn.workers.UvicornWorker\r\n[2019-05-24 11:51:24 +0000] [8] [INFO] Booting worker with pid: 8\r\n[2019-05-24 11:51:24 +0000] [9] [INFO] Booting worker with pid: 9\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\n[2019-05-24 11:51:33 +0000] [9] [INFO] Started server process [9]\r\n[2019-05-24 11:51:33 +0000] [9] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:33 +0000] [8] [INFO] Started server process [8]\r\n[2019-05-24 11:51:33 +0000] [8] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:37 +0000] [18] [INFO] Booting worker with pid: 18\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\n[2019-05-24 11:51:44 +0000] [18] [INFO] Started server process [18]\r\n[2019-05-24 11:51:44 +0000] [18] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:45 +0000] [23] [INFO] Booting worker with pid: 23\r\nWARNING:root:email-validator not installed, email field", "output": "Iirc there are no max workers set so I'd either tweak the gunicorn conf to\nset your number according to the server you deploy on, or set another env\nvar, can't remember on top of my head but it's in the docs I'm sure\n\nLe ven. 24 mai 2019 Ã  2:03 PM, SansDK <notifications@github.com> a Ã©crit :\n\n> Hi there,\n>\n> I'm trying to run two different instances of FastAPI in the same\n> Kubernetes pod (different Docker containers), but one of the two seems to\n> keep booting up new workers. Therefor, the container uses a lot of CPU for\n> nothing. It's also reporting that it's waiting for application startup\n> constantly, but it is reachable (but slow).\n>\n> Here is the log that I keep getting:\n>\n> Checking for script in /app/prestart.sh\n> Running script /app/prestart.sh\n> Running inside /app/prestart.sh, you could add migrations to this file, e.g.:\n>  #! /usr/bin/env bash\n>  # Let the DB start\n> sleep 10;\n> # Run migrations\n> alembic upgrade head\n>  [2019-05-24 11:51:24 +0000] [1] [INFO] Starting gunicorn 19.9.0\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Listening at: http://0.0.0.0:8081 (1)\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Using worker: uvicorn.workers.UvicornWorker\n> [2019-05-24 11:51:24 +0000] [8] [INFO] Booting worker with pid: 8\n> [2019-05-24 11:51:24 +0000] [9] [INFO] Booting worker with pid: 9\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:33 +0000] [9] [INFO] Started server process [9]\n> [2019-05-24 11:51:33 +0000] [9] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:33 +0000] [8] [INFO] Started server process [8]\n> [2019-05-24 11:51:33 +0000] [8] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:37 +0000] [18] [INFO] Booting worker with pid: 18\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:44 +0000] [18] [INFO] Started server process [18]\n> [2019-05-24 11:51:44 +0000] [18] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:45 +0000] [23] [INFO] Booting worker with pid: 23\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:53 +0000] [23] [INFO] Started server process [23]\n> [2019-05-24 11:51:53 +0000] [23] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:54 +0000] [28] [INFO] Booting worker with pid: 28\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:52:02 +0000] [28] [INFO] Started server process [28]\n> [2019-05-24 11:52:02 +0000] [28] [INFO] Waiting for application startup.\n>\n> This will continue untill I shut it down. This problem weirdly does not\n> happen when I run everything locally.\n>\n> A difference between local and remote deployment is probably only the port\n> that I set.\n> As you can see, I use port 8081:\n>\n> [INFO] Listening at: http://0.0.0.0:8081 (1)\n>\n> I set the port by specifying it in my Kubernetes yaml file, but I am\n> unsure if this has something to do with the problem.\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/253?email_source=notifications&email_token=AAINSPWLEJ53IUGIRMY2MDDPW7KQBA5CNFSM4HPO4Y32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVV7SAQ>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPTKBVSZMRPIDNLUCDTPW7KQBANCNFSM4HPO4Y3Q>\n> .\n>\n\nLe ven. 24 mai 2019 Ã  2:03 PM, SansDK <notifications@github.com> a Ã©crit :\n\n> Hi there,\n>\n> I'm trying to run two different instances of FastAPI in the same\n> Kubernetes pod (different Docker containers), but one of the two seems to\n> keep booting up new workers. Therefor, the container uses a lot of CPU for\n> nothing. It's also reporting that it's waiting for application startup\n> constantly, but it is reachable (but slow).\n>\n> Here is the log that I keep getting:\n>\n> Checking for script in /app/prestart.sh\n> Running script /app/prestart.sh\n> Running inside /app/prestart.sh, you could add migrations to this file, e.g.:\n>  #! /usr/bin/env bash\n>  # Let the DB start\n> sleep 10;\n> # Run migrations\n> alembic upgrade head\n>  [2019-05-24 11:51:24 +0000] [1] [INFO] Starting gunicorn 19.9.0\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Listening at: http://0.0.0.0:8081 (1)\n> [2019-05-24 11:51:24 +0000] [1] [INFO] Using worker: uvicorn.workers.UvicornWorker\n> [2019-05-24 11:51:24 +0000] [8] [INFO] Booting worker with pid: 8\n> [2019-05-24 11:51:24 +0000] [9] [INFO] Booting worker with pid: 9\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:33 +0000] [9] [INFO] Started server process [9]\n> [2019-05-24 11:51:33 +0000] [9] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:33 +0000] [8] [INFO] Started server process [8]\n> [2019-05-24 11:51:33 +0000] [8] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:37 +0000] [18] [INFO] Booting worker with pid: 18\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:44 +0000] [18] [INFO] Started server process [18]\n> [2019-05-24 11:51:44 +0000] [18] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:45 +0000] [23] [INFO] Booting worker with pid: 23\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:51:53 +0000] [23] [INFO] Started server process [23]\n> [2019-05-24 11:51:53 +0000] [23] [INFO] Waiting for application startup.\n> [2019-05-24 11:51:54 +0000] [28] [INFO] Booting worker with pid: 28\n> WARNING:root:email-validator not installed, email fields will be treated as str.\n> To install, run: pip install email-validator\n> [2019-05-24 11:52:02 +0000] [28] [INFO] Started server process [28]\n> [2019-05-24 11:52:02 +0000] [28] [INFO] Waiting for application startup.\n>\n> This will continue untill I shut it down. This problem weirdly does not\n> happen when I run everything locally.\n>\n> A difference between local and remote deployment is probably only the port\n> that I set.\n> As you can see, I use port 8081:\n>\n> [INFO] Listening at: http://0.0.0.0:8081 (1)\n>\n> I set the port by specifying it in my Kubernetes yaml file, but I am\n> unsure if this has something to do with the problem.\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/253?email_source=notifications&email_token=AAINSPWLEJ53IUGIRMY2MDDPW7KQBA5CNFSM4HPO4Y32YY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4GVV7SAQ>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPTKBVSZMRPIDNLUCDTPW7KQBANCNFSM4HPO4Y3Q>\n> .\n>\n\n---\n\nI'll have a look in the docs, but this isn't expected behavior.\r\nI've deployed FastAPI with uvicorn and gunicorn before, and I never had to worry about gunicorn settings. Now it's just creating 1000+ workers for no reason and without any load at all.\r\n\r\nFor now I'll just try to set the ```WORKERS_PER_CORE``` environment variable and see if that fixes the problem. I guess it will, but it's still weird behavior because the default ```WORKERS_PER_CORE``` is 1, and I'm fairly sure I don't have a 1000+ cpu cores on my server.\r\n\r\nAnyways, I'll report back if setting the variable fixes the problem. Thanks!\n\n---\n\nOkay, I set the ```WORKERS_PER_CORE``` to 1 to no avail.\r\nI struggle to understand how t", "source": "issue", "type": "qa_comprehensive", "issue_number": 58}
{"instruction": "File Upload Difficulties\n\nDetails:\nHello - I am not having any luck with file upload to FastAPI - I am trying to load JPEG images.  I have reviewed the other github, stackoverflow comments and none of the solutions work. \r\n\r\nI believe the issue is with the front-end - and I am able to get it to work with the swagger \\docs interface.  From my front-end I have tried submitting directly from a form as well as formData via XMLHttpRequest and fetch (would prefer either of the latter).  I am using plain javascript. \r\n\r\nI am sure I am doing something wrong - I just don't know what it is.  Any advice would be deeply appreciated - I am 20+hours deep into trying to solve this one.  **Thanks in advance!**\r\n\r\n**Here is the swagger curl:**\r\n``curl -X POST \"http://localhost:8000/staff/upload_image/\" -H  \"accept: application/json\" -H  \"Content-Type: multipart/form-data\" -F \"image=@_WGL1281.jpg;type=image/jpeg\"\r\n``\r\n\r\n**Server Reply:  POST http://localhost:8000/staff/upload_image/ 422 (Unprocessable Entity)**\r\n\r\n**Installed Versions:**\r\n```\r\nfastapi - 0.54.1\r\nstarlette - 0.13.2\r\npydantic - 1.5.1\r\npython - 3.832\r\npython-multipart - 0.0.5\r\n\r\n```\r\n**Server side code snippets:**\r\n\r\n```\r\nfrom fastapi import APIRouter, Request, Depends, File, UploadFile\r\n\r\n@router.post(\"/staff/upload_image/\")\r\nasync def upload_image(image: UploadFile = File(...)):\r\n\tprint(image.filename)\r\n\treturn {\"filename\": image.filename}\r\n\r\n```\r\n\r\n**client side:**\r\n```\r\nasync function imageupload(){\r\n            let imageinput = document.getElementById('testimage');\r\n            let formData = new FormData();\r\n            formData.append('imagefile', imageinput.files[0]);\r\n\r\n            let response = await fetch('/staff/upload_image/', {\r\n                method: 'POST',\r\n                body: formData\r\n            })\r\n\r\n            await console.log(response);\r\n\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "Can you try with the latest version of fastapi, and give us the error from the server logs?", "source": "issue", "type": "qa_best_answer", "issue_number": 57}
{"instruction": "Provide a comprehensive answer to this question: File Upload Difficulties", "input": "Hello - I am not having any luck with file upload to FastAPI - I am trying to load JPEG images.  I have reviewed the other github, stackoverflow comments and none of the solutions work. \r\n\r\nI believe the issue is with the front-end - and I am able to get it to work with the swagger \\docs interface.  From my front-end I have tried submitting directly from a form as well as formData via XMLHttpRequest and fetch (would prefer either of the latter).  I am using plain javascript. \r\n\r\nI am sure I am doing something wrong - I just don't know what it is.  Any advice would be deeply appreciated - I am 20+hours deep into trying to solve this one.  **Thanks in advance!**\r\n\r\n**Here is the swagger curl:**\r\n``curl -X POST \"http://localhost:8000/staff/upload_image/\" -H  \"accept: application/json\" -H  \"Content-Type: multipart/form-data\" -F \"image=@_WGL1281.jpg;type=image/jpeg\"\r\n``\r\n\r\n**Server Reply:  POST http://localhost:8000/staff/upload_image/ 422 (Unprocessable Entity)**\r\n\r\n**Installed Versions:**\r\n```\r\nfastapi - 0.54.1\r\nstarlette - 0.13.2\r\npydantic - 1.5.1\r\npython - 3.832\r\npython-multipart - 0.0.5\r\n\r\n```\r\n**Server side code snippets:**\r\n\r\n```\r\nfrom fastapi import APIRouter, Request, Depends, File, UploadFile\r\n\r\n@router.post(\"/staff/upload_image/\")\r\nasync def upload_image(image: UploadFile = File(...)):\r\n\tprint(image.filename)\r\n\treturn {\"filename\": image.filename}\r\n\r\n```\r\n\r\n**client side:**\r\n```\r\nasync function imageupload(){\r\n            let imageinput = document.getElementById('testimage');\r\n            let formData = new FormData();\r\n            formData.append('imagefile', imageinput.files[0]);\r\n\r\n            let response = await fetch('/staff/upload_image/', {\r\n                method: 'POST',\r\n                body: formData\r\n            })\r\n\r\n            await console.log(response);\r\n\r\n```", "output": "Can you try with the latest version of fastapi, and give us the error from the server logs?\n\n---\n\nI have updated FastAPI and dependencies to the following:\r\n```\r\nfastapi - 0.62.0\r\nstarlette - 0.13.6\r\n```\r\n\r\nServer log using my front end code:\r\n```\r\nâ†[32mINFOâ†[0m:     127.0.0.1:54609 - \"â†[1mGET /staff_main HTTP/1.1â†[0m\" â†[32m200 OKâ†[0m\r\nâ†[32mINFOâ†[0m:     127.0.0.1:54609 - \"â†[1mGET /favicon.ico HTTP/1.1â†[0m\" â†[31m404 Not Foundâ†[0m\r\nâ†[32mINFOâ†[0m:     127.0.0.1:54609 - \"â†[1mPOST /staff/upload_image/ HTTP/1.1â†[0m\" â†[31m422 Unprocessable Entityâ†[0m\r\n```\r\nAnd with the swagger docs interface:\r\n```\r\nâ†[32mINFOâ†[0m:     127.0.0.1:54610 - \"â†[1mGET /docs HTTP/1.1â†[0m\" â†[32m200 OKâ†[0m\r\nâ†[32mINFOâ†[0m:     127.0.0.1:54610 - \"â†[1mGET /openapi.json HTTP/1.1â†[0m\" â†[32m200 OKâ†[0m\r\n_WGL0071.jpg\r\nâ†[32mINFOâ†[0m:     127.0.0.1:54611 - \"â†[1mPOST /staff/upload_image/ HTTP/1.1â†[0m\" â†[32m200 OKâ†[0m\r\n```\r\nwhere the _WGL0071.jpg is a response to print the file name on the server.\n\n---\n\nSo the above results are using fetch.  When I switch to XMLHttpRequest - I get a different message in my console.log - in case this helps.  \r\n\r\n`{\"detail\":[{\"loc\":[\"body\",\"image\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}\r\n`\n\n---\n\nOne more thing - if this works in swagger \\docs - do we know how its front-end works?  I've tried to figure that out - but the code is not easy to examine.\n\n---\n\n@Bill-Lathrop have you tried setting a `Header`? \r\n\r\n\r\n```js\r\nasync function imageupload(){\r\n            let imageinput = document.getElementById('testimage');\r\n            let formData = new FormData();\r\n            formData.append('imagefile', imageinput.files[0]);\r\n\r\n            let response = await fetch('/staff/upload_image/', {\r\n                method: 'POST',\r\n                body: formData,\r\n                headers: {\"Content-Type\": \"image/jpeg\"}\r\n            })\r\n\r\n            await console.log(response);\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 57}
{"instruction": "FastAPI 0.65.2 POST request fails with \"value is not a valid dict\" when using the Requests library; 0.65.1 works (with a caveat)\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ ] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [ ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ ] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\nFirst off, thank you for creating this marvellous piece of software. It is a real life-changer.\r\n\r\nI hit a very odd bug while implementing some unit tests. Using FastAPI `0.65.2`, a POST request via the `requests` module (`requests.post`) consistently returns the following error:\r\n\r\n`{'detail': [{'loc': ['body'], 'msg': 'value is not a valid dict', 'type': 'type_error.dict'}]}`\r\n\r\nI created a reproducible example:\r\n\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\nimport uvicorn\r\n\r\napp = FastAPI()\r\n\r\nclass Data(BaseModel):\r\n    field: str\r\n\r\n\r\n@app.post(\"/test\")\r\ndef test_data(data: Data):\r\n    return \"Polo\"\r\n\r\nif __name__=='__main__':\r\n    uvicorn.run(app)\r\n```\r\n\r\nAnd the `requests` counterpart:\r\n\r\n```\r\nimport requests as rq\r\n\r\ndef test():\r\n    result = rq.post('http://127.0.0.1:8000/test', data={\"field\": \"Marco\"})\r\n    print(f\"==[ resul", "input": "Repository: FastAPI\nLabels: ", "output": "You probably meant to use the json parameter, not the data parameter. Data is for form data", "source": "issue", "type": "qa_best_answer", "issue_number": 56}
{"instruction": "Provide a comprehensive answer to this question: FastAPI 0.65.2 POST request fails with \"value is not a valid dict\" when using the Requests library; 0.65.1 works (with a caveat)", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ ] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [ ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ ] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\nFirst off, thank you for creating this marvellous piece of software. It is a real life-changer.\r\n\r\nI hit a very odd bug while implementing some unit tests. Using FastAPI `0.65.2`, a POST request via the `requests` module (`requests.post`) consistently returns the following error:\r\n\r\n`{'detail': [{'loc': ['body'], 'msg': 'value is not a valid dict', 'type': 'type_error.dict'}]}`\r\n\r\nI created a reproducible example:\r\n\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\nimport uvicorn\r\n\r\napp = FastAPI()\r\n\r\nclass Data(BaseModel):\r\n    field: str\r\n\r\n\r\n@app.post(\"/test\")\r\ndef test_data(data: Data):\r\n    return \"Polo\"\r\n\r\nif __name__=='__main__':\r\n    uvicorn.run(app)\r\n```\r\n\r\nAnd the `requests` counterpart:\r\n\r\n```\r\nimport requests as rq\r\n\r\ndef test():\r\n    result = rq.post('http://127.0.0.1:8000/test', data={\"field\": \"Marco\"})\r\n    print(f\"==[ resul", "output": "You probably meant to use the json parameter, not the data parameter. Data is for form data\n\n---\n\n@Mause  \r\n\r\nThank you for the quick reply. What you suggested indeed fixed the problem, so I will mark this as resolved, but I am still perplexed. I never knew that the `data` parameter was for form data - I have always used `data` until I encountered this issue.  This is from the `requests` [documentation](https://docs.python-requests.org/en/latest/user/quickstart/):\r\n\r\n> Requestsâ€™ simple API means that all forms of HTTP request are as obvious. For example, this is how you make an HTTP POST request:\r\n> `>>> r = requests.post('https://httpbin.org/post', data = {'key':'value'})`\r\n\r\nAlso, I'm not sure why downgrading FastAPI works (subject to the JSONification caveat above).\r\n\r\nStill, all is well that ends well. :) Thank you for your help!\n\n---\n\nThe reason the downgrade fixed it was due to the json post handling in the latest version - it was changed so it only tried to parse bodies with a valid Content-Type header as json, which the data parameter wouldn't set\n\n---\n\nAh-ha, that makes more sense, thank you for clarifying that point. I hope others will find this thread useful. Cheers!\n\n---\n\nIs there a way to force the post handling to parse the body as JSON even though the Content-Type header is text/plain?", "source": "issue", "type": "qa_comprehensive", "issue_number": 56}
{"instruction": "FastAPI with Pydantic v2\n\nDetails:\nIs FastAPI with support for Pydantic v2 working for you (`0.100.0-beta1`)?\r\n\r\n~Let me know **in this discussion** on the link: https://github.com/tiangolo/fastapi/discussions/9709~\r\n\r\n~(don't comment in this issue, please go to the discussions and follow the instructions there)~\r\n\r\nAs FastAPI now supports Pydantic v2, any problems are not about the beta (as it's already released ðŸ˜…), so let's keep the normal workflow.\r\n\r\nIf you are having problems, please create a new Discussion question following the template! ðŸ™  https://github.com/tiangolo/fastapi/discussions/new?category=questions", "input": "Repository: FastAPI\nLabels: ", "output": "Hi! I just updated my project to fastapi **v0.100.0-beta1** and pydantic **v2.0b2** and I'm getting the following error:\r\n\r\n```\r\npydantic.errors.PydanticImportError: pydantic:BaseSettings has been removed in V2.\r\n\r\nFor further information visit https://errors.pydantic.dev/2.0b2/u/import-error\r\n\r\n```\r\nIs there any official migration guide from pydantic v1 to pydantic v2?", "source": "issue", "type": "qa_best_answer", "issue_number": 55}
{"instruction": "Provide a comprehensive answer to this question: FastAPI with Pydantic v2", "input": "Is FastAPI with support for Pydantic v2 working for you (`0.100.0-beta1`)?\r\n\r\n~Let me know **in this discussion** on the link: https://github.com/tiangolo/fastapi/discussions/9709~\r\n\r\n~(don't comment in this issue, please go to the discussions and follow the instructions there)~\r\n\r\nAs FastAPI now supports Pydantic v2, any problems are not about the beta (as it's already released ðŸ˜…), so let's keep the normal workflow.\r\n\r\nIf you are having problems, please create a new Discussion question following the template! ðŸ™  https://github.com/tiangolo/fastapi/discussions/new?category=questions", "output": "Hi! I just updated my project to fastapi **v0.100.0-beta1** and pydantic **v2.0b2** and I'm getting the following error:\r\n\r\n```\r\npydantic.errors.PydanticImportError: pydantic:BaseSettings has been removed in V2.\r\n\r\nFor further information visit https://errors.pydantic.dev/2.0b2/u/import-error\r\n\r\n```\r\nIs there any official migration guide from pydantic v1 to pydantic v2?\n\n---\n\nYes. There is: https://docs.pydantic.dev/dev-v2/migration/\n\n---\n\nParsing of `Literal` types seems to be broken with Pydantic v2.\r\n\r\nTake this example:\r\n```python\r\nfrom typing import Literal\r\n\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass Health(BaseModel):\r\n    status: Literal[\"ok\", \"error\"]\r\n```\r\n\r\nDoing `print(Health.model_json_schema())` seems to return the right thing (`{'properties': {'status': {'enum': ['ok', 'error'], 'title': 'Status'}}, 'required': ['status'], 'title': 'Health', 'type': 'object'}`)\r\n\r\nHowever, if I use it as the return model for a path operation, the schema is broken in the swagger docs. Weirdly the examples do use one of the values.\r\n\r\n![image](https://github.com/tiangolo/fastapi/assets/47002300/c2c40fbb-33c5-46bc-868c-39cdcf0779c7)\r\n\r\n![image](https://github.com/tiangolo/fastapi/assets/47002300/d0cd0f95-fb7f-4484-842b-ef9ddc65f54e)\r\n\r\nHere is a pastebin with the generated openapi.json: https://pastebin.com/a95Tujah\n\n---\n\n@aradkdj please check the instructions on the discussion and comment there: https://github.com/tiangolo/fastapi/discussions/9709\n\n---\n\n@tiangolo this is not working with a basic setup:\r\n\r\n```\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return \"hello world\"\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import uvicorn\r\n\r\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\r\n```\r\n\r\n\r\n```\r\n(.venv) âžœ  fastapi_pydantic pdm run main.py\r\nTraceback (most recent call last):\r\n  File \"/Users/xxxdevelopment/fastapi_pydantic/main.py\", line 1, in <module>\r\n    from fastapi import FastAPI\r\n  File \"/Users/xxx/development/fastapi_pydantic/.venv/lib/python3.11/site-packages/fastapi/__init__.py\", line 7, in <module>\r\n    from .applications import FastAPI as FastAPI\r\n  File \"/Users/xxx/development/fastapi_pydantic/.venv/lib/python3.11/site-packages/fastapi/applications.py\", line 16, in <module>\r\n    from fastapi import routing\r\n  File \"/Users/xxx/development/fastapi_pydantic/.venv/lib/python3.11/site-packages/fastapi/routing.py\", line 22, in <module>\r\n    from fastapi import params\r\n  File \"/Users/xxx/development/fastapi_pydantic/.venv/lib/python3.11/site-packages/fastapi/params.py\", line 6, in <module>\r\n    from ._compat import PYDANTIC_V2, Undefined\r\n  File \"/Users/xxx/development/fastapi_pydantic/.venv/lib/python3.11/site-packages/fastapi/_compat.py\", line 50, in <module>\r\n    from pydantic._internal._fields import Undefined as Undefined\r\nImportError: cannot import name 'Undefined' from 'pydantic._internal._fields' (/Users/xxx/development/fastapi_pydantic/.venv/lib/python3.11/site-packages/pydantic/_internal/_fields.py)\r\n```\r\n\r\n\r\n```\r\ndependencies = [\r\n    \"fastapi==0.100.0-beta1\",\r\n    \"uvicorn\"\r\n]\r\n```\r\n\r\n**Just saw your v0.100.0-beta2 which seems to work now!**", "source": "issue", "type": "qa_comprehensive", "issue_number": 55}
{"instruction": "How to send 204 response?\n\nDetails:\nI tried to send 204 response in delete method\r\n\r\nExample handler\r\n```\r\n@router.delete('/{order_id}/', tags=['smart order'], status_code=204)\r\nasync def cancel_smart_order(\r\n        session: Session = Depends(get_session),\r\n        order_id: UUID = Path(...)\r\n):\r\n    order = await session.get(order_id)\r\n\r\n    if order.status != OrderStatus.open:\r\n        raise HTTPException(409, f'Order have status: {order.status}')\r\n\r\n    order.status = OrderStatus.canceled\r\n\r\n    await session.commit_only(order)\r\n```\r\n\r\nBut got error `h11._util.LocalProtocolError: Too much data for declared Content-Length`. Seems framefork convert None to null but set content length 0.", "input": "Repository: FastAPI\nLabels: ", "output": "Not sure why the content-length is wrong; that may be a bug. But if you want to return an actual empty response, just set `response_class=Response` in the route decorator (the default is `JSONResponse`, which converts `None` to `\"null\"` as you have noticed).", "source": "issue", "type": "qa_best_answer", "issue_number": 54}
{"instruction": "Provide a comprehensive answer to this question: How to send 204 response?", "input": "I tried to send 204 response in delete method\r\n\r\nExample handler\r\n```\r\n@router.delete('/{order_id}/', tags=['smart order'], status_code=204)\r\nasync def cancel_smart_order(\r\n        session: Session = Depends(get_session),\r\n        order_id: UUID = Path(...)\r\n):\r\n    order = await session.get(order_id)\r\n\r\n    if order.status != OrderStatus.open:\r\n        raise HTTPException(409, f'Order have status: {order.status}')\r\n\r\n    order.status = OrderStatus.canceled\r\n\r\n    await session.commit_only(order)\r\n```\r\n\r\nBut got error `h11._util.LocalProtocolError: Too much data for declared Content-Length`. Seems framefork convert None to null but set content length 0.", "output": "Not sure why the content-length is wrong; that may be a bug. But if you want to return an actual empty response, just set `response_class=Response` in the route decorator (the default is `JSONResponse`, which converts `None` to `\"null\"` as you have noticed).\n\n---\n\nIt is a bug. I found that if `(event.status_code in (204, or request_method == b\" or (request_method == b\" and 200 <= event.status_code < 300))` than content length set to 0, but by defualt if return None then framevork try to conver None to json and got (`null`(len 4)). Need to add check on status code and try to convert only if the expression above is False.\n\n---\n\n@heckad \r\nCould you share where this check is performed in the code?\r\n\r\nI don't *necessarily* think it's a bug for a `JSONResponse` to convert `None` to `\"null\"`, regardless of the status code you return; it's up to you to specify that the response class should be `Response` and not `JSONResponse`. But it definitely is a bug if it manually sets the content length to 0 even when that's not the case.\r\n\r\nI personally think the most consistent solution would be to drop the special case for the 204 status code (at least for `JSONResponse`).\r\n\r\nIt could make sense to display some kind of warning if using a 204 response code with a `JSONResponse` though?\n\n---\n\n> Could you share where this check is performed in the code?\r\n\r\n`_body_framing` method in `_connection` in `h11` file.\r\n\r\n> I don't _necessarily_ think it's a bug for a `JSONResponse` to convert `None` to `\"null\"`, regardless of the status code you return; it's up to you to specify that the response class should be `Response` and not `JSONResponse`. But it definitely is a bug if it manually sets the content length to 0 even when that's not the case.\r\n\r\nI wish he didn't put anything into the body. Add `JSONResponse` not remove the body and not solve the problem.\r\n\r\nI have poor English and I donâ€™t attack, I just speak briefly.\n\n---\n\nI meant this check:\r\n\r\n`(event.status_code in (204, or request_method == b\" or (request_method == b\" and 200 <= event.status_code < 300))` (which I assumed was in fastapi or starlette).\r\n\r\nIs that in `h11`?", "source": "issue", "type": "qa_comprehensive", "issue_number": 54}
{"instruction": "Using MQTT with FastAPI\n\nDetails:\n### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description: How can I receive MQTT with fastAPI?\r\n\r\nMQTT is used often in IoT. It is much lighter than HTTP and is build on top of TCP. It can also use a WebSocket transport layer.\r\n\r\nI can think of the following options and would be interested to hear what you think.\r\n\r\n#### 1. Use Flask middleware\r\n\r\nFlask has support for MQTT routes, so I could follow the instructions here to implement Flask middleware, https://fastapi.tiangolo.com/advanced/wsgi/#using-wsgimiddleware, however I don't know if this works in general for any protocol (HTTP, MQTT, WS etc.) of if it only routes HTTP.\r\n\r\n#### 2. Use RabbitMQ\r\n\r\n[RabbitMQ](https://www.rabbitmq.com/mqtt.html) has support for MQTT. But I'm unsure how I would integrate this with FastAPI. It would not be appropriate to use a background task, https://fastapi.tiangolo.com/tutorial/background-tasks/ because these are tasks that fired off after returning a response. Probably I would need to use an asyncio.Queue and call API methods manually when an event arrives.\r\n\r\n#### 3. Use MQTT over Websocket\r\n\r\n[paho-mqtt](https://www.eclipse.org/paho/clients/python/docs/) can use WebSocket transport. Again I'm unsure how to integrate this with FastAPI. Could I use the `@websocket` decorator. Probably not because that would just be the transport layer, not the protocol layer!\r\n\r\n```python\r\n@app.websocket(\"/sent_data\")  #  PUT called by external client to send data here\r\nasync def recieved_data_mqtt_over_ws():\r\n    pass\r\n```\r\n\r\n#### Would it be possible to ...?\r\n\r\nEventually something like this might be possible?\r\n\r\n```python\r\n@app.mqtt(\"/sent_data\")  #  PUT called by external client to send data here\r\nasync def recieved_data_mqtt_over_ws():\r\n    pass\r\n```\r\n\r\nI have not yet starte", "input": "Repository: FastAPI\nLabels: ", "output": "Great question\r\nAlso interested in the answer.", "source": "issue", "type": "qa_best_answer", "issue_number": 53}
{"instruction": "Provide a comprehensive answer to this question: Using MQTT with FastAPI", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description: How can I receive MQTT with fastAPI?\r\n\r\nMQTT is used often in IoT. It is much lighter than HTTP and is build on top of TCP. It can also use a WebSocket transport layer.\r\n\r\nI can think of the following options and would be interested to hear what you think.\r\n\r\n#### 1. Use Flask middleware\r\n\r\nFlask has support for MQTT routes, so I could follow the instructions here to implement Flask middleware, https://fastapi.tiangolo.com/advanced/wsgi/#using-wsgimiddleware, however I don't know if this works in general for any protocol (HTTP, MQTT, WS etc.) of if it only routes HTTP.\r\n\r\n#### 2. Use RabbitMQ\r\n\r\n[RabbitMQ](https://www.rabbitmq.com/mqtt.html) has support for MQTT. But I'm unsure how I would integrate this with FastAPI. It would not be appropriate to use a background task, https://fastapi.tiangolo.com/tutorial/background-tasks/ because these are tasks that fired off after returning a response. Probably I would need to use an asyncio.Queue and call API methods manually when an event arrives.\r\n\r\n#### 3. Use MQTT over Websocket\r\n\r\n[paho-mqtt](https://www.eclipse.org/paho/clients/python/docs/) can use WebSocket transport. Again I'm unsure how to integrate this with FastAPI. Could I use the `@websocket` decorator. Probably not because that would just be the transport layer, not the protocol layer!\r\n\r\n```python\r\n@app.websocket(\"/sent_data\")  #  PUT called by external client to send data here\r\nasync def recieved_data_mqtt_over_ws():\r\n    pass\r\n```\r\n\r\n#### Would it be possible to ...?\r\n\r\nEventually something like this might be possible?\r\n\r\n```python\r\n@app.mqtt(\"/sent_data\")  #  PUT called by external client to send data here\r\nasync def recieved_data_mqtt_over_ws():\r\n    pass\r\n```\r\n\r\nI have not yet starte", "output": "Great question\r\nAlso interested in the answer.\n\n---\n\nInteresting, I hadn't heard of it, I don't know how that protocol works but it seems it's more similar to WebSockets than to HTTP.\r\n\r\nThe solution would be quite involved, and actually would end up not related to FastAPI :shrug: but anyway, here are my ideas:\r\n\r\n* There would have to be an ASGI sub-specification for MQTT as there's one for HTTP and for WebSockets, I haven't seen one, but I see there are some packages that try to implement a layer for that (you can search \"asgi mqtt\").\r\n\r\n* But then you would need some type of server that supports that protocol, so, probably not Uvicorn, Hypercorn, etc. Maybe one of those packages directly.\r\n\r\n* Then there would be some code that handles that communication, maybe as part of one of those packages or independently.\r\n\r\nMost of those packages seem to target Django Channels, maybe using them would be the simplest approach to handle it.\r\n\r\nIf it was for WebSockets, you could probably mount Django Channels in a FastAPI app, as both are ASGI. But as you need a new, custom, protocol that is not supported by most ASGI servers, you would probably end up needing a custom solution.\n\n---\n\n@tiangolo thanks! I will think about this when I return to this topic in the future.\n\n---\n\n@danieljfarrell Sorry for posting into this closed issue. However some point to note w.r.t. **2. Use RabbitMQ**:\r\n\r\nRabbitMQ ATM does support [MQTT3.1.1](https://www.rabbitmq.com/mqtt.html) only. [mosquitto](https://mosquitto.org/) supports v5.0 as well. According to the GitHub stars and watches the user base of [rabbitmq-server (broker)](https://github.com/rabbitmq/rabbitmq-server) is probably smaller than the user base of e.g. [mosquitto](https://github.com/eclipse/mosquitto) which is backed by Eclipse which has a lot of [adopters of their IoT projects](https://iot.eclipse.org/adopters/) (not MQTT related, however to be considered w.r.t. integration).\r\n\r\nW.r.t. **3. Use MQTT over Websocket**: In my experience `paho-mqtt` works pretty well Django + channels + daphne ([under the hood: twisted, autobahn, asgiref](https://github.com/django/daphne/blob/master/setup.py#L25)).\n\n---\n\nHow is the situation here?  I want to connect MQTT with my FastAPI server.. Is this possible ?", "source": "issue", "type": "qa_comprehensive", "issue_number": 53}
{"instruction": "Italian translations\n\nDetails:\n### Italian translations tracking\r\nWe can use this Issue to track the progress of the Italian language translations. ðŸ‡®ðŸ‡¹ \r\n\r\nPlease post here what page you plan on translating so we can coordinate. ðŸš€\r\n\r\n**Tips**\r\n* Just like [we're doing with the Spanish translations](https://github.com/tiangolo/fastapi/issues/1218), let's use \"tu\" instead of the more formal \"lei\" or \"voi\".\r\n* If the term is a technical term, leave in English and add an explanation of the meaning of the word in Italian.", "input": "Repository: FastAPI\nLabels: ", "output": "For Portuguese there's a telegram channel, idk if you guys want to setup that as well... Is jfyk :)", "source": "issue", "type": "qa_best_answer", "issue_number": 52}
{"instruction": "Provide a comprehensive answer to this question: Italian translations", "input": "### Italian translations tracking\r\nWe can use this Issue to track the progress of the Italian language translations. ðŸ‡®ðŸ‡¹ \r\n\r\nPlease post here what page you plan on translating so we can coordinate. ðŸš€\r\n\r\n**Tips**\r\n* Just like [we're doing with the Spanish translations](https://github.com/tiangolo/fastapi/issues/1218), let's use \"tu\" instead of the more formal \"lei\" or \"voi\".\r\n* If the term is a technical term, leave in English and add an explanation of the meaning of the word in Italian.", "output": "For Portuguese there's a telegram channel, idk if you guys want to setup that as well... Is jfyk :)\n\n---\n\nCool, thanks for letting me know @Kludex. I've created a telegram group for the Italian translations https://t.me/fastapiita :)\n\n---\n\n~~I'm currently in the process of adding Italian as a new language and translating `index.md`~~\r\n\r\n`index.md` translation at PR #1576 [needing review]\n\n---\n\n~~Up next, I'll be translating `python-types.md`.~~\r\n\r\n`python-types.md` translation at PR #1580 [needing a review]\n\n---\n\n~~I'll be translating `index.md` and `first-steps.md` from the [Tutorial - User Guide](https://fastapi.tiangolo.com/tutorial/) next.~~\r\n\r\n`tutorial/index.md` and `tutorial/first-steps.md` have been translated at PR #1585! ðŸ¥³  [needing review].", "source": "issue", "type": "qa_comprehensive", "issue_number": 52}
{"instruction": "404 Error with OpenAPI\n\nDetails:\nHi all,\r\n\r\nNew to fastAPI, and coming from Flask, I'm very impressed by the solution.\r\nBut using the OpenAPI documentation/UI, I can see in the logs that I have the following issue each time I extend a resource/API :\r\n`INFO:     <IP>:57175 - \"GET /%5Bobject%20Module%5D HTTP/1.1\" 404 Not Found`\r\nThe API is working, but I get this error in the log.\r\n\r\nI'm using v0.63.0, on an ubuntu server (18.04)\r\n\r\nThanks a lot for your support.", "input": "Repository: FastAPI\nLabels: ", "output": "Hi, Welcome to FastAPI\r\n\r\nplease follow the [Issue instruction](https://github.com/tiangolo/fastapi/issues/new/choose).\r\nwe need more information to help you.\r\nthanks.", "source": "issue", "type": "qa_best_answer", "issue_number": 51}
{"instruction": "Provide a comprehensive answer to this question: 404 Error with OpenAPI", "input": "Hi all,\r\n\r\nNew to fastAPI, and coming from Flask, I'm very impressed by the solution.\r\nBut using the OpenAPI documentation/UI, I can see in the logs that I have the following issue each time I extend a resource/API :\r\n`INFO:     <IP>:57175 - \"GET /%5Bobject%20Module%5D HTTP/1.1\" 404 Not Found`\r\nThe API is working, but I get this error in the log.\r\n\r\nI'm using v0.63.0, on an ubuntu server (18.04)\r\n\r\nThanks a lot for your support.", "output": "Hi, Welcome to FastAPI\r\n\r\nplease follow the [Issue instruction](https://github.com/tiangolo/fastapi/issues/new/choose).\r\nwe need more information to help you.\r\nthanks.\n\n---\n\nHi,\r\n\r\nOK, here is what I can add :\r\n\r\nIt seems this issue appeared when I've implemented the following code (but not sure...) :\r\n```python\r\nclass device_import(BaseModel):\r\n    hostname: str\r\n    ipaddress: str\r\n    platform: str\r\n    description: Optional[str] = None\r\n......\r\n@app.post(\"/system/device\", summary=\"Create a new device in the system\", tags=[\"System\"])\r\nasync def post_device(device_info: device_import):\r\n........\r\n```\r\nAll other routes are using basic structure, with path parameters or Query.\r\n\r\nIn terms of imports : \r\n```python\r\nfrom typing import Optional, Dict\r\nfrom fastapi import FastAPI, Request, APIRouter, Form, Query, Body\r\nfrom pydantic import BaseModel, Field\r\n```\r\n\r\nThis issue appears each time I'm expanding a resource/API in the doc UI (Swagger UI).\r\nLet's say that I click on a GET or a POST object to expand, I will automatically get the following log : \r\n`\r\nINFO:     <IP>:49702 - \"GET /%5Bobject%20Module%5D HTTP/1.1\" 404 Not Found\r\n`\r\n\r\nAs explained, the engine works, and I can launch every request, but I get this error, and I really don't what could be the root cause...\r\n\r\nThanks again,\n\n---\n\nyour route is `POST` and it works fine.\r\n``` python\r\n......\r\n@app.post(\"/system/device\", summary=\"Create a new device in the system\", tags=[\"System\"])\r\nasync def post_device(device_info: device_import):\r\n........\r\n```\r\n\r\nbut your log is about `GET` request.\r\n`Request with GET/HEAD method cannot have body.` [check this out](https://github.com/swagger-api/swagger-ui/issues/2136#issuecomment-216881309)\r\n\r\n``` python\r\nfrom fastapi import Depends\r\n\r\n@app.get(\"/system/device\", summary=\"Create a new device in the system\", tags=[\"System\"])\r\nasync def post_device(device_info: device_import=Depends()):\r\n    return device_info\r\n\r\n```\n\n---\n\nThanks a lot,\r\n\r\nJust checked, and I've got the same issue even if I expand a GET, PUT or DELETE resource.\r\nLet say that I click on this item to expand it, I'll get the log : \r\n![image](https://user-images.githubusercontent.com/18547804/104301627-2a038c00-54c8-11eb-8fb4-2bd97854127b.png)\r\n\r\n`\r\nINFO:    <IP>:51426 - \"GET /%5Bobject%20Module%5D HTTP/1.1\" 404 Not Found\r\n`\r\n\r\nSame thing if I do it on a POST item : \r\n![image](https://user-images.githubusercontent.com/18547804/104301798-5a4b2a80-54c8-11eb-91bc-793242bdf856.png)\r\n\r\n`\r\nINFO:     <IP>:51504 - \"GET /%5Bobject%20Module%5D HTTP/1.1\" 404 Not Found\r\n`\r\n\r\nI have the issue whatever the route and associated method I expand.\r\nBut if it has been expanded/loaded 1 time, I will never get the issue for it if I collapse/expand it, until I refresh the page (Which is quite obvious as content as been loaded...)\n\n---\n\nI also get the samme INFO message in my log\r\n```\r\nTRACE:    127.0.0.1:44588 - ASGI [10] Started scope={'type': 'http', 'asgi': {'version': '3.0', 'spec_version': '2.1'}, 'http_version': '1.1', 'server': ('127.0.0.1', 8000), 'client': ('127.0.0.1', 44588), 'scheme': 'http', 'method': 'GET', 'root_path': '', 'path': '/[object Module]', 'raw_path': b'/[object%20Module]', 'query_string': b'', 'headers': '<...>'}\r\nTRACE:    127.0.0.1:44588 - ASGI [10] Send {'type': 'http.response.start', 'status': 404, 'headers': '<...>'}\r\nINFO:     127.0.0.1:44588 - \"GET /%5Bobject%20Module%5D HTTP/1.1\" 404 Not Found\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 51}
{"instruction": "FastAPI debugging\n\nDetails:\nHello\r\nI've seen on FastAPI documentation site, that it integrates nice with a VSCode. \r\nAny hint on debugging an FastAPI application in VSCode? There are some exaple configrations for python projects, but unfortunately I'm not able to utilize these for  FastAPI\r\n\r\nThanks\r\nOlegas", "input": "Repository: FastAPI\nLabels: ", "output": "What examples are you talking about ?\r\nWhat prevents you from using them ?\r\nIf you could be more specific that would help answering.\r\n\r\nDocs are very clear and progressive imho, using the parts provided should suffice, if not the tests folder is often a good source of inspiration.", "source": "issue", "type": "qa_best_answer", "issue_number": 50}
{"instruction": "Provide a comprehensive answer to this question: FastAPI debugging", "input": "Hello\r\nI've seen on FastAPI documentation site, that it integrates nice with a VSCode. \r\nAny hint on debugging an FastAPI application in VSCode? There are some exaple configrations for python projects, but unfortunately I'm not able to utilize these for  FastAPI\r\n\r\nThanks\r\nOlegas", "output": "What examples are you talking about ?\r\nWhat prevents you from using them ?\r\nIf you could be more specific that would help answering.\r\n\r\nDocs are very clear and progressive imho, using the parts provided should suffice, if not the tests folder is often a good source of inspiration.\n\n---\n\nYes, documentation is fine, thanks.\nWhat I mean are debug configurations, which allows you set breakpoints in\ncode. Not only on start, but also when performing api calls.\n\n\nOn Fri, 8 Feb 2019, 16:30 euri10 <notifications@github.com wrote:\n\n> What examples are you talking about ?\n> What prevents you from using them ?\n> If you could be more specific that would help answering.\n>\n> Docs are very clear and progressive imho, using the parts provided should\n> suffice, if not the tests folder is often a good source of inspiration.\n>\n> â€”\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/23#issuecomment-461820659>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AbQG4Zr5E20Mso5U4FUzHgEcVPqkbW0-ks5vLYoZgaJpZM4akpHM>\n> .\n>\n\n---\n\nnot sure how this is related to FastAPI, this seems more like a general question on how to use vscode.\nI'm using pycharm and in order to debug a route you'd simply put a breakpoint in it and call it either with your local browser, or curl, well anything you'd feel comfortable with.\nAs for vscode seems like debugging is described here: https://code.visualstudio.com/docs/python/debugging that may be a good start. \nYou could also use the cool pdb.\n\n---\n\nYes, it's more common question. thanks for tips tho.\r\n\r\nRegards\n\n---\n\nThanks for your help here @euri10 !\r\n\r\n@olegasdo, I hope you found what you needed in the VS Code docs.\r\n\r\n---\r\n\r\nHere's one option that might work for you:\r\n\r\nYou can import `uvicorn` in your file, instead of calling it directly from the command line, and run it inside (maybe just for development).\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nimport uvicorn\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    a = \"a\"\r\n    b = \"b\" + a\r\n    return {\"hello world\": b}\r\n\r\n\r\nif __name__ == '__main__':\r\n    uvicorn.run(app, host='0.0.0.0', port=8000)\r\n```\r\n\r\nThen you can use the default VS Code launcher, \"Python: Current File (Integrated Terminal)\".\r\n\r\nIt will then stop at your breakpoints, etc.\r\n\r\nHere's how it looks:\r\n\r\n![vscode-launch-debug-vscode](https://user-images.githubusercontent.com/1326112/52523080-dfa77e00-2ca6-11e9-8b4d-7c60d0cf4805.png)", "source": "issue", "type": "qa_comprehensive", "issue_number": 50}
{"instruction": "enhance serialization speed\n\nDetails:\n**Description**\r\n\r\nI have to return sometimes big objects, I'm constrained in the fact that chunking them is not an option\r\n\r\nAn example of such an object would be a dict `{\"key:: value}` where value is a list of list, 20 list of 10k elements.\r\n\r\nI wrote this simple [test case](https://github.com/euri10/fastapi/blob/slow_serial/tests/test_serial_speed.py) that shows quite clearly the massive hit in several scenarios (run with `pytest tests/test_serial_speed.py --log-cli-level=INFO`) \r\nHere's the output:\r\n```\r\n======================================================================================================================= 1 passed in 3.68 seconds =======================================================================================================================\r\n(fastapi) âžœ  fastapi git:(slow_serial) âœ— pytest tests/test_serial_speed.py --log-cli-level=INFO\r\n========================================================================================================================= test session starts ==========================================================================================================================\r\nplatform linux -- Python 3.6.8, pytest-5.0.0, py-1.8.0, pluggy-0.12.0\r\nrootdir: /home/lotso/PycharmProjects/fastapi\r\nplugins: cov-2.7.1\r\ncollected 1 item                                                                                                                                                                                                                                                       \r\n\r\ntests/test_serial_speed.py::test_routes \r\n---------------------------------------------------------------------------------------------------------------------------- live log call -----------------------------------------------------------------------------------------------------------------------------\r\nINFO     tests.test_serial_speed:test_serial_speed.py:39 route1: 0.05402565002441406\r\nINFO     tests.test_serial_speed:test_serial_speed.py:18 a", "input": "Repository: FastAPI\nLabels: ", "output": "Just to confirm, you do have `ujson` installed? What type of machine are you running this on?  \r\n\r\nRoute 1 is going to be fastest as it is just returning the JSONResponse directly. \r\n\r\nRoute 2 is taking the dict, running `field.validate`   and then dumping it back out as JSON, so will be slower than route 1. \r\n\r\n_I  could be wrong on this one, have never really looked at the response portion of the fastapi code, but from a quick glance_\r\nRoute 3 constructs the pydantic model (which validates it), then calls `field.validate` on it again  and then dumps it back out as json, making it the slowest.\r\n\r\n\r\nFWIW, with ujson on a MBP:\r\n```test_serial_speed.py::test_routes\r\n------------------------------------------------------------------------------------------------ live log call -------------------------------------------------------------------------------------------------\r\ntest_serial_speed.py        41 INFO     route1: 0.028443098068237305\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route1, 2.768159866333008, ['http_status:200', 'http_method:GET', 'time:wall']\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route1, 2.7664400000000002, ['http_status:200', 'http_method:GET', 'time:cpu']\r\ntest_serial_speed.py        53 INFO     route2: 0.02795100212097168\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route2, 3.3919589519500732, ['http_status:200', 'http_method:GET', 'time:wall']\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route2, 3.386338999999999, ['http_status:200', 'http_method:GET', 'time:cpu']\r\ntest_serial_speed.py        64 INFO     route3: 0.03644418716430664\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route3, 3.939689874649048, ['http_status:200', 'http_method:GET', 'time:wall']\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route3, 3.9318400000000002, ['http_status:200', 'http_method:GET', 'time:cpu']```", "source": "issue", "type": "qa_best_answer", "issue_number": 49}
{"instruction": "Provide a comprehensive answer to this question: enhance serialization speed", "input": "**Description**\r\n\r\nI have to return sometimes big objects, I'm constrained in the fact that chunking them is not an option\r\n\r\nAn example of such an object would be a dict `{\"key:: value}` where value is a list of list, 20 list of 10k elements.\r\n\r\nI wrote this simple [test case](https://github.com/euri10/fastapi/blob/slow_serial/tests/test_serial_speed.py) that shows quite clearly the massive hit in several scenarios (run with `pytest tests/test_serial_speed.py --log-cli-level=INFO`) \r\nHere's the output:\r\n```\r\n======================================================================================================================= 1 passed in 3.68 seconds =======================================================================================================================\r\n(fastapi) âžœ  fastapi git:(slow_serial) âœ— pytest tests/test_serial_speed.py --log-cli-level=INFO\r\n========================================================================================================================= test session starts ==========================================================================================================================\r\nplatform linux -- Python 3.6.8, pytest-5.0.0, py-1.8.0, pluggy-0.12.0\r\nrootdir: /home/lotso/PycharmProjects/fastapi\r\nplugins: cov-2.7.1\r\ncollected 1 item                                                                                                                                                                                                                                                       \r\n\r\ntests/test_serial_speed.py::test_routes \r\n---------------------------------------------------------------------------------------------------------------------------- live log call -----------------------------------------------------------------------------------------------------------------------------\r\nINFO     tests.test_serial_speed:test_serial_speed.py:39 route1: 0.05402565002441406\r\nINFO     tests.test_serial_speed:test_serial_speed.py:18 a", "output": "Just to confirm, you do have `ujson` installed? What type of machine are you running this on?  \r\n\r\nRoute 1 is going to be fastest as it is just returning the JSONResponse directly. \r\n\r\nRoute 2 is taking the dict, running `field.validate`   and then dumping it back out as JSON, so will be slower than route 1. \r\n\r\n_I  could be wrong on this one, have never really looked at the response portion of the fastapi code, but from a quick glance_\r\nRoute 3 constructs the pydantic model (which validates it), then calls `field.validate` on it again  and then dumps it back out as json, making it the slowest.\r\n\r\n\r\nFWIW, with ujson on a MBP:\r\n```test_serial_speed.py::test_routes\r\n------------------------------------------------------------------------------------------------ live log call -------------------------------------------------------------------------------------------------\r\ntest_serial_speed.py        41 INFO     route1: 0.028443098068237305\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route1, 2.768159866333008, ['http_status:200', 'http_method:GET', 'time:wall']\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route1, 2.7664400000000002, ['http_status:200', 'http_method:GET', 'time:cpu']\r\ntest_serial_speed.py        53 INFO     route2: 0.02795100212097168\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route2, 3.3919589519500732, ['http_status:200', 'http_method:GET', 'time:wall']\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route2, 3.386338999999999, ['http_status:200', 'http_method:GET', 'time:cpu']\r\ntest_serial_speed.py        64 INFO     route3: 0.03644418716430664\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route3, 3.939689874649048, ['http_status:200', 'http_method:GET', 'time:wall']\r\ntest_serial_speed.py        19 INFO     app.test_serial_speed.route3, 3.9318400000000002, ['http_status:200', 'http_method:GET', 'time:cpu']```\n\n---\n\nI don't have ujson installed and my machine was a dual i5-2697v2 (until today when it seems I fried my mb bios...) well.\nWill try ujson even if iirc it's kind of stalled project, isn't it?\n\n---\n\nI'm investigating it, a bit, with line_profiler.\r\n\r\nMaybe calling `fastapi.encoders.jsonable_encoder()` part is main factor?, and too many calling this function (recursively).\r\n\r\n```\r\nFile: /home/me/venvs/fastapi/lib/python3.7/site-packages/fastapi/encoders.py\r\nFunction: jsonable_encoder at line 8\r\n\r\nLine #      Hits         Time  Per Hit   % Time  Line Contents\r\n==============================================================\r\n     8                                           @profile\r\n     9                                           def jsonable_encoder(\r\n    10                                               obj: Any,\r\n    11                                               include: Set[str] = None,\r\n    12                                               exclude: Set[str] = set(),\r\n    13                                               by_alias: bool = True,\r\n    14                                               skip_defaults: bool = False,\r\n    15                                               include_none: bool = True,\r\n    16                                               custom_encoder: dict = {},\r\n    17                                               sqlalchemy_safe: bool = True,\r\n    18                                           ) -> Any:\r\n    19    130008      85523.0      0.7      3.5      if include is not None and not isinstance(include, set):\r\n    20                                                   include = set(include)\r\n    21    130008      97039.0      0.7      3.9      if exclude is not None and not isinstance(exclude, set):\r\n    22                                                   exclude = set(exclude)\r\n    23    130008     172094.0      1.3      6.9      if isinstance(obj, BaseModel):\r\n    24         1          2.0      2.0      0.0          encoder = getattr(obj.Config, \"json_encoders\", custom_encoder)\r\n    25         1          1.0      1.0      0.0          return jsonable_encoder(\r\n    26         1          1.0      1.0      0.0              obj.dict(\r\n    27         1          0.0      0.0      0.0                  include=include,\r\n    28         1          1.0      1.0      0.0                  exclude=exclude,\r\n    29         1          1.0      1.0      0.0                  by_alias=by_alias,\r\n    30         1      22756.0  22756.0      0.9                  skip_defaults=skip_defaults,\r\n    31                                                       ),\r\n    32         1          1.0      1.0      0.0              include_none=include_none,\r\n    33         1          1.0      1.0      0.0              custom_encoder=encoder,\r\n    34         1          6.0      6.0      0.0              sqlalchemy_safe=sqlalchemy_safe,\r\n    35                                                   )\r\n    36    130007     116806.0      0.9      4.7      if isinstance(obj, Enum):\r\n    37                                                   return obj.value\r\n    38    130007     136911.0      1.1      5.5      if isinstance(obj, (str, int, float, type(None))):\r\n    39     30001      18834.0      0.6      0.8          return obj\r\n    40    100006      76767.0      0.8      3.1      if isinstance(obj, dict):\r\n    41     50001      59332.0      1.2      2.4          encoded_dict = {}\r\n    42     70002      77972.0      1.1      3.1          for key, value in obj.items():\r\n    43                                                       if (\r\n    44                                                           (\r\n    45     20001      13416.0      0.7      0.5                      not sqlalchemy_safe\r\n    46     20001      15464.0      0.8      0.6                      or (not isinstance(key, str))\r\n    47     20001      18121.0      0.9      0.7                      or (not key.startswith(\"_sa\"))\r\n    48                                                           )\r\n    49     20001      13778.0      0.7      0.6                  and (value is not None or include_none)\r\n    50     20001      14021.0      0.7      0.6                  and ((include and key in include) or key not in exclude)\r\n    51                                                       ):\r\n    52     20001      13916.0      0.7      0.6                  encoded_key = jsonable_encoder(\r\n    53     20001      12987.0      0.6      0.5                      key,\r\n    54     20001      13242.0      0.7      0.5                      by_alias=by_alias,\r\n    55     20001      13011.0      0.7      0.5                      skip_defaults=skip_defaults,\r\n    56     20001      13224.0      0.7      0.5                      include_none=include_none,\r\n    57     20001      12971.0      0.6      0.5                      custom_encoder=custom_encoder,\r\n    58     20001      33429.0      1.7      1.3                      sqlalchemy_safe=sqlalchemy_safe,\r\n    59                                                           )\r\n    60     20001      14937.0      0.7      0.6                  encoded_value = jsonable_encoder(\r\n    61     20001      13204.0      0.7      0.5                      value,\r\n    62     20001      13382.0      0.7      0.5                      by_alias=by_alias,\r\n    63     20001      13164.0      0.7      0.5                      skip_defaults=skip_defaults,\r\n    64     20001      12975.0      0.6      0.5                      include_none=include_none,\r\n    65     20001      13333.0      0.7      0.5                      custom_encoder=custom_encoder,\r\n    66     20001      27140.0      1.4      1.1                      sqlalchemy_safe=sqlalchemy_safe,\r\n    67                                                           )\r\n    68     20001      15872.0      0.8      0.6                  encoded_dict[encoded_key] = encoded_value\r\n    69     50001      32725.0      0.7      1.3          return encoded_dict\r\n    70     50005      54024.0      1.1      2.2      if isinstance(obj, (list, set, frozenset, Generator", "source": "issue", "type": "qa_comprehensive", "issue_number": 49}
{"instruction": "How can I pass the configuration in the app?\n\nDetails:\nHow can I pass the configuration in the app? Can I do it in some way like it was in Flask with app.config, or this framework manages it differently?", "input": "Repository: FastAPI\nLabels: ", "output": "You will be able to pass anything you want to app.state I've starlette is\non 0.12.9\n\nLe jeu. 5 sept. 2019 Ã  5:14 PM, Artsiom Dolatau <notifications@github.com>\na Ã©crit :\n\n> How can I pass the configuration in the app? Can I do it in some simple\n> way like it was in Flask with app.config, or this framework doesn't support\n> even this?\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/508?email_source=notifications&email_token=AAINSPVIGGYSLBWKF7TYFOLQIEO3PA5CNFSM4IT7DHBKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HJSGYQA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPQ5XZ73CSBHDJMJSPTQIEO3PANCNFSM4IT7DHBA>\n> .\n>", "source": "issue", "type": "qa_best_answer", "issue_number": 48}
{"instruction": "Provide a comprehensive answer to this question: How can I pass the configuration in the app?", "input": "How can I pass the configuration in the app? Can I do it in some way like it was in Flask with app.config, or this framework manages it differently?", "output": "You will be able to pass anything you want to app.state I've starlette is\non 0.12.9\n\nLe jeu. 5 sept. 2019 Ã  5:14 PM, Artsiom Dolatau <notifications@github.com>\na Ã©crit :\n\n> How can I pass the configuration in the app? Can I do it in some simple\n> way like it was in Flask with app.config, or this framework doesn't support\n> even this?\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/508?email_source=notifications&email_token=AAINSPVIGGYSLBWKF7TYFOLQIEO3PA5CNFSM4IT7DHBKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HJSGYQA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPQ5XZ73CSBHDJMJSPTQIEO3PANCNFSM4IT7DHBA>\n> .\n>\n\n---\n\nI typically use a subclass of `pydantic.BaseSettings` so I can read config from the environment, then create an `lru_cache`d function that returns a config instance, then wherever I need access to a config setting I just call the `lru_cache`d function to get the config and read the setting off of it.\n\n---\n\ni have the same question here - what is the equivalent of app.config in flask ? https://flask.palletsprojects.com/en/1.1.x/config/\r\n\r\nto specific, are there any convenience functions similar to\r\n```\r\napp.config.from_object('yourapplication.default_settings')\r\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\r\n```\r\nwe need to load different configurations based on production or staging environment.\n\n---\n\nNo there are no convenience functions like that.\n\nLe mar. 17 sept. 2019 Ã  7:53 PM, Sandeep Srinivasa <notifications@github.com>\na Ã©crit :\n\n> i have the same question here - what is the equivalent of app.config in\n> flask ? https://flask.palletsprojects.com/en/1.1.x/config/\n>\n> to specific, are there any convenience functions similar to\n>\n> app.config.from_object('yourapplication.default_settings')\n> app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/508?email_source=notifications&email_token=AAINSPVXCBZNPHZZCCHLVVDQKEKQFA5CNFSM4IT7DHBKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD65LOMA#issuecomment-532330288>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPQKZC5QSJGFW5YRFKDQKEKQFANCNFSM4IT7DHBA>\n> .\n>\n\n---\n\n@sandys does pydantic `BaseSettings` not work for you? It allows you to pass values at instantiation time or via environment variable (and is type safe to boot!).\r\n\r\nA more complete example:\r\n```python\r\nfrom functools import lru_cache\r\nfrom typing import List\r\n\r\nfrom pydantic import BaseSettings\r\n\r\n\r\nclass APISettings(BaseSettings):\r\n    api_v1_route: str = \"/api/v1\"\r\n    openapi_route: str = \"/api/v1/openapi.json\"\r\n\r\n    backend_cors_origins_str: str = \"\"  # Should be a comma-separated list of origins\r\n\r\n    debug: bool = False\r\n    debug_exceptions: bool = False\r\n    disable_superuser_dependency: bool = False\r\n    include_admin_routes: bool = False\r\n\r\n    @property\r\n    def backend_cors_origins(self) -> List[str]:\r\n        return [x.strip() for x in self.backend_cors_origins_str.split(\",\") if x]\r\n\r\n    class Config:\r\n        env_prefix = \"\"\r\n\r\n\r\n@lru_cache()\r\ndef get_api_settings() -> APISettings:\r\n    return APISettings()  # reads variables from environment\r\n```\r\n\r\nIf you want something more fundamentally different as a function of the production vs. staging vs. testing environment (e.g., rather than setting each environment variable differently), you could just put some logic inside `get_api_settings` based on the environment variable value.\r\n\r\nAccessing the config in your app is then as simple as, for example, `debug = get_api_settings().debug`.", "source": "issue", "type": "qa_comprehensive", "issue_number": 48}
{"instruction": "Use UploadFile in Pydantic model\n\nDetails:\n**Description**\r\n\r\nIs it possible to use `UploadFile` in a Pydantic model? The FastAPI docs [say](https://fastapi.tiangolo.com/tutorial/request-files/) â€œFastAPI's UploadFile inherits directly from Starlette's UploadFile, but adds some necessary parts to make it compatible with Pydantic and the other parts of FastAPI.â€ \r\n\r\n```python3\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom pydantic import BaseModel\r\n\r\nclass PydanticFile(BaseModel):\r\n    file: UploadFile = File(...)\r\n\r\napp = FastAPI()\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(file: PydanticFile):\r\n    return {\"filename\": file.filename}\r\n```\r\n\r\nHowever, `UploadFile` does not seem to be compatible with Pydantic. The code above â€“ derived from the example in FastAPI's [Request Files tutorial](https://fastapi.tiangolo.com/tutorial/request-files/) â€“ raises a value error:\r\n\r\n```\r\nValueError: Value not declarable with JSON Schema, field: file type=UploadFile required\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "I'm a FastAPI/Starlette noob so take what I'm saying with a grain of salt, but I don't think what you are trying to do really makes sense.\r\n\r\nWhen you are specifying a UploadFile I believe you are telling FastAPI/Starlette that you will be providing data in a multipart form body.  Pydantic is for describing the expected JSON format body.  So trying to combine the two doesn't really make sense because you need to do one or the other.\r\n\r\nI could be off base though ... you can wait for someone else to chime in.", "source": "issue", "type": "qa_best_answer", "issue_number": 47}
{"instruction": "Provide a comprehensive answer to this question: Use UploadFile in Pydantic model", "input": "**Description**\r\n\r\nIs it possible to use `UploadFile` in a Pydantic model? The FastAPI docs [say](https://fastapi.tiangolo.com/tutorial/request-files/) â€œFastAPI's UploadFile inherits directly from Starlette's UploadFile, but adds some necessary parts to make it compatible with Pydantic and the other parts of FastAPI.â€ \r\n\r\n```python3\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom pydantic import BaseModel\r\n\r\nclass PydanticFile(BaseModel):\r\n    file: UploadFile = File(...)\r\n\r\napp = FastAPI()\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(file: PydanticFile):\r\n    return {\"filename\": file.filename}\r\n```\r\n\r\nHowever, `UploadFile` does not seem to be compatible with Pydantic. The code above â€“ derived from the example in FastAPI's [Request Files tutorial](https://fastapi.tiangolo.com/tutorial/request-files/) â€“ raises a value error:\r\n\r\n```\r\nValueError: Value not declarable with JSON Schema, field: file type=UploadFile required\r\n```", "output": "I'm a FastAPI/Starlette noob so take what I'm saying with a grain of salt, but I don't think what you are trying to do really makes sense.\r\n\r\nWhen you are specifying a UploadFile I believe you are telling FastAPI/Starlette that you will be providing data in a multipart form body.  Pydantic is for describing the expected JSON format body.  So trying to combine the two doesn't really make sense because you need to do one or the other.\r\n\r\nI could be off base though ... you can wait for someone else to chime in.\n\n---\n\nThanks a lot for your helpful comment. So I guess I'd have to explicitly separate the file from the [JSON part of the multipart form body](url), as in:\r\n\r\n```python3\r\nclass Properties(BaseModel):\r\n    language: str = None\r\n    author: str = None\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(file: UploadFile = File(...),\r\n                             properties: Properties):\r\n    return {\"filename\": file.filename}\r\n```\r\n\r\nThis seems to be working, and maybe query parameters would ultimately make more sense here.\n\n---\n\nWhen it says \"adds necessary parts to make it compatible with Pydantic\", it doesn't mean with pydantic BaseModel instances. FastAPI makes deep use of a lot of pydantic internals during the request-handling process, and I believe the modifications to the type are to make it compatible with that. In particular, it is used in a way that doesn't require it to be able to live as a field on a `BaseModel`.\r\n\r\nGenerally, you should only use `BaseModel` instances in FastAPI when you know you want to parse the model contents from the json body of the request.\r\n\r\nIf you want to make use of `UploadFile` as an attribute of a dependency class you can, it just can't be a pydantic model. (You can look at how the auth dependencies are implemented for an example along those lines.) A plain-old 3.7 dataclass would probably work for this.\n\n---\n\n> This seems to be working, and maybe query parameters would ultimately make more sense here.\r\n\r\nI would go the more RESTful approach and use /author/{author name or id}/language/{language name or id}/file.  Upload is kind of implied with the POST request.  With that said, this discussion is no long Fast API based so we should probably discontinue that discussion here.\r\n\r\nGood day and good luck ...\n\n---\n\nThanks a lot @michaelschmit and @dmontagu.", "source": "issue", "type": "qa_comprehensive", "issue_number": 47}
{"instruction": "ðŸŒ Translations coordination (list of translations)\n\nDetails:\nHere are the issues coordinating the translations to each language:\r\n\r\n* Portuguese: https://github.com/tiangolo/fastapi/issues/1211\r\n* Spanish: https://github.com/tiangolo/fastapi/issues/1218\r\n* Chinese: https://github.com/tiangolo/fastapi/issues/1228\r\n* Russian: https://github.com/tiangolo/fastapi/issues/1362\r\n* Italian: https://github.com/tiangolo/fastapi/issues/1556\r\n* Japanese: https://github.com/tiangolo/fastapi/issues/1572\r\n* Ukrainian: https://github.com/tiangolo/fastapi/issues/1748\r\n* Turkish: https://github.com/tiangolo/fastapi/issues/1892\r\n* French: https://github.com/tiangolo/fastapi/issues/1972\r\n* Korean: https://github.com/tiangolo/fastapi/issues/2017\r\n* Persian: https://github.com/tiangolo/fastapi/issues/2041\r\n* Polish: https://github.com/tiangolo/fastapi/issues/3169\r\n* German: https://github.com/tiangolo/fastapi/issues/3716\r\n* Indonesian: https://github.com/tiangolo/fastapi/issues/3717\r\n* Azerbaijani: https://github.com/tiangolo/fastapi/issues/3994\r\n* Dutch: https://github.com/tiangolo/fastapi/issues/4701\r\n* Uzbek: https://github.com/tiangolo/fastapi/issues/4883\r\n* Swedish: https://github.com/tiangolo/fastapi/issues/5146\r\n* Hebrew: https://github.com/tiangolo/fastapi/issues/5157\r\n* Tamil: https://github.com/tiangolo/fastapi/issues/5434\r\n* Arabic: https://github.com/tiangolo/fastapi/issues/3349\r\n---\r\n\r\nNote: this meta-issue is here because GitHub only allows a limited number of issues to be pinned, so I can't pin all of them. I'll update it here when there's a new language.", "input": "Repository: FastAPI\nLabels: ", "output": "Couldn't we just have a tag for translations instead?", "source": "issue", "type": "qa_best_answer", "issue_number": 46}
{"instruction": "Provide a comprehensive answer to this question: ðŸŒ Translations coordination (list of translations)", "input": "Here are the issues coordinating the translations to each language:\r\n\r\n* Portuguese: https://github.com/tiangolo/fastapi/issues/1211\r\n* Spanish: https://github.com/tiangolo/fastapi/issues/1218\r\n* Chinese: https://github.com/tiangolo/fastapi/issues/1228\r\n* Russian: https://github.com/tiangolo/fastapi/issues/1362\r\n* Italian: https://github.com/tiangolo/fastapi/issues/1556\r\n* Japanese: https://github.com/tiangolo/fastapi/issues/1572\r\n* Ukrainian: https://github.com/tiangolo/fastapi/issues/1748\r\n* Turkish: https://github.com/tiangolo/fastapi/issues/1892\r\n* French: https://github.com/tiangolo/fastapi/issues/1972\r\n* Korean: https://github.com/tiangolo/fastapi/issues/2017\r\n* Persian: https://github.com/tiangolo/fastapi/issues/2041\r\n* Polish: https://github.com/tiangolo/fastapi/issues/3169\r\n* German: https://github.com/tiangolo/fastapi/issues/3716\r\n* Indonesian: https://github.com/tiangolo/fastapi/issues/3717\r\n* Azerbaijani: https://github.com/tiangolo/fastapi/issues/3994\r\n* Dutch: https://github.com/tiangolo/fastapi/issues/4701\r\n* Uzbek: https://github.com/tiangolo/fastapi/issues/4883\r\n* Swedish: https://github.com/tiangolo/fastapi/issues/5146\r\n* Hebrew: https://github.com/tiangolo/fastapi/issues/5157\r\n* Tamil: https://github.com/tiangolo/fastapi/issues/5434\r\n* Arabic: https://github.com/tiangolo/fastapi/issues/3349\r\n---\r\n\r\nNote: this meta-issue is here because GitHub only allows a limited number of issues to be pinned, so I can't pin all of them. I'll update it here when there's a new language.", "output": "Couldn't we just have a tag for translations instead?\n\n---\n\nHaving a specific issue for translations of a specific language lets people coordinate which section each one is working on.\n\n---\n\nOh, sure, for individual languages, yeah, but I meant if it was necessary to have a meta-issue for those instead of just a 4th tag for translations?\n\n---\n\nI would imagine it would be easier for someone new trying to contribute translations to find the specific issue here directly than searching manually with labels.\n\n---\n\nI could help with some Italian translations. Is this something you may be interested in? I'm trying to understand if it would make sense to consider Italian as the userbase may not be as big as, say, Spanish or Portuguese.", "source": "issue", "type": "qa_comprehensive", "issue_number": 46}
{"instruction": "Typehints  instead of response_model\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\nNow:\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom typing import Dict, List\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=Dict[str, List[str]])\r\ndef read_root():\r\n    return {\"Hello\": [\"tom\", \"hesus\"]}\r\n```\r\n### The solution you would like\r\nI ", "input": "Repository: FastAPI\nLabels: ", "output": "**I don't know** if it was only a decision or if there's an issue on the suggested approach.\r\n\r\nMy input here will be related to MyPy:\r\n\r\n```python\r\nfrom typing import Dict, List\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\nclass Potato(BaseModel):\r\n    name: str\r\n    color: str\r\n\r\n@app.get(\"/\")\r\ndef get_potato() -> Potato:\r\n    return {\"name\": \"best potato\", \"color\": \"purple\"}\r\n```\r\n\r\nDoing as above, MyPy will get sad:\r\n```bash\r\ntest.py:14: error: Incompatible return value type (got \"Dict[str, str]\", expected \"Potato\")\r\nFound 1 error in 1 file (checked 1 source file)\r\n```\r\n\r\nMaybe a \"FastAPI MyPy plugin\" can be created to allow it (in case the suggestion is accepted and if is possible to create a plugin like that, I've never tried).", "source": "issue", "type": "qa_best_answer", "issue_number": 45}
{"instruction": "Provide a comprehensive answer to this question: Typehints  instead of response_model", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\nNow:\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom typing import Dict, List\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=Dict[str, List[str]])\r\ndef read_root():\r\n    return {\"Hello\": [\"tom\", \"hesus\"]}\r\n```\r\n### The solution you would like\r\nI ", "output": "**I don't know** if it was only a decision or if there's an issue on the suggested approach.\r\n\r\nMy input here will be related to MyPy:\r\n\r\n```python\r\nfrom typing import Dict, List\r\n\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\nclass Potato(BaseModel):\r\n    name: str\r\n    color: str\r\n\r\n@app.get(\"/\")\r\ndef get_potato() -> Potato:\r\n    return {\"name\": \"best potato\", \"color\": \"purple\"}\r\n```\r\n\r\nDoing as above, MyPy will get sad:\r\n```bash\r\ntest.py:14: error: Incompatible return value type (got \"Dict[str, str]\", expected \"Potato\")\r\nFound 1 error in 1 file (checked 1 source file)\r\n```\r\n\r\nMaybe a \"FastAPI MyPy plugin\" can be created to allow it (in case the suggestion is accepted and if is possible to create a plugin like that, I've never tried).\n\n---\n\nNo, i want use annotations instead of response_model. i want fastapi to understand typehints\n\n---\n\nI understand what you said... I want that too. :eyes:\n\n---\n\ni think to do something like this:\r\n```python\r\nfrom typing import get_type_hints\r\n\r\n@app.get(\"/\")\r\nasync def root() -> dict:\r\n    return {\"hello\": \"world\"}\r\n\r\nhints = get_type_hints(root)\r\nif \"return\" in hints:\r\n    response_model  = hints[\"return\"]\r\n\r\n# or\r\n# response_model = hints.get(\"return\")\r\n```\n\n---\n\nThere is already a library that allows you to do this:\n\nhttps://fastapi-utils.davidmontague.xyz/user-guide/inferring-router/", "source": "issue", "type": "qa_comprehensive", "issue_number": 45}
{"instruction": "Too many emojis in 'Concurrency and async / await' explanation\n\nDetails:\nThe explanation page for concurrency, and more specifically its example with burgers (https://fastapi.tiangolo.com/async/#concurrent-burgers) becomes hard to read for me because of its many emojis.\r\n\r\nAn excerpt:\r\n\r\n> You go with your crush ðŸ˜ to get fast food ðŸ”, you stand in line while the cashier ðŸ’ takes the orders from the people in front of you.\r\n> Then it's your turn, you place your order of 2 very fancy burgers ðŸ” for your crush ðŸ˜ and you.\r\n> You pay ðŸ’¸.\r\n> The cashier ðŸ’ says something to the guy in the kitchen ðŸ‘¨â€ðŸ³ so he knows he has to prepare your burgers ðŸ” (even though he is currently preparing the ones for the previous clients).\r\n> The cashier ðŸ’ gives you the number of your turn.\r\n> While you are waiting, you go with your crush ðŸ˜ and pick a table, you sit and talk with your crush ðŸ˜ for a long time (as your burgers are very fancy and take some time to prepare âœ¨ðŸ”âœ¨).\r\n> As you are sitting on the table with your crush ðŸ˜, while you wait for the burgers ðŸ”, you can spend that time admiring how awesome, cute and smart your crush is âœ¨ðŸ˜âœ¨.\r\n...\r\nBut as you go away from the counter and sit on the table with a number for your turn, you can switch ðŸ”€ your attention to your crush ðŸ˜, and \"work\" â¯ ðŸ¤“ on that. Then you are again doing something very \"productive\" ðŸ¤“, as is flirting with your crush ðŸ˜.\r\n\r\nIn my opinion, the many emojis don't add anything to the explanation and make it hard to read. **Every emoji breaks the flow when reading because my eyes are distracted by the emojis' size and colour.**\r\n\r\nIs the 'ðŸ˜' after every 'crush' necessary? Same with burger and ðŸ”, cashier and ðŸ’ and so on.\r\n\r\nI propose cutting down on or completely removing emojis from the documentation to help with readability.\r\n\r\nThe same issue, though less pronounced, is also apparent in the section 'Asynchronous Code' (https://fastapi.tiangolo.com/async/#asynchronous-code).\r\n\r\n***\r\n\r\n(If you want to know what it feels like to read the documentation, try reading this:)\r\n\r\nIn my ðŸ§‘opinion ðŸ¤”, the manyðŸ”¢ emojis", "input": "Repository: FastAPI\nLabels: ", "output": "Emojis are part of our culture. :sweat_smile:\r\n\r\n> (If you want to know what it feels like to read the documentation, try reading this:)\r\n\r\nI've read the documentation, and I don't feel the same as reading your example, as it's clearly ill-intentioned to prove your point. :kissing: \r\n\r\nThat being said, we can wait to see if people have the same opinion as you, and/or you can propose a PR changing that page, and @tiangolo you'll check it at some point.\r\n\r\nI don't think this change is needed, nor do I feel harmed by those emojis, sometimes I even get the opposite effect as the one you mentioned. Which I think is because humans tend to relate images better than letters. \r\n\r\nEDIT: Well... Months have passed, and my opinion has changed. I no longer have strong feelings about this. Although, I think the most important argument here is the one mentioned [here](https://github.com/tiangolo/fastapi/issues/3273#issuecomment-1018297338). :wave:", "source": "issue", "type": "qa_best_answer", "issue_number": 44}
{"instruction": "Provide a comprehensive answer to this question: Too many emojis in 'Concurrency and async / await' explanation", "input": "The explanation page for concurrency, and more specifically its example with burgers (https://fastapi.tiangolo.com/async/#concurrent-burgers) becomes hard to read for me because of its many emojis.\r\n\r\nAn excerpt:\r\n\r\n> You go with your crush ðŸ˜ to get fast food ðŸ”, you stand in line while the cashier ðŸ’ takes the orders from the people in front of you.\r\n> Then it's your turn, you place your order of 2 very fancy burgers ðŸ” for your crush ðŸ˜ and you.\r\n> You pay ðŸ’¸.\r\n> The cashier ðŸ’ says something to the guy in the kitchen ðŸ‘¨â€ðŸ³ so he knows he has to prepare your burgers ðŸ” (even though he is currently preparing the ones for the previous clients).\r\n> The cashier ðŸ’ gives you the number of your turn.\r\n> While you are waiting, you go with your crush ðŸ˜ and pick a table, you sit and talk with your crush ðŸ˜ for a long time (as your burgers are very fancy and take some time to prepare âœ¨ðŸ”âœ¨).\r\n> As you are sitting on the table with your crush ðŸ˜, while you wait for the burgers ðŸ”, you can spend that time admiring how awesome, cute and smart your crush is âœ¨ðŸ˜âœ¨.\r\n...\r\nBut as you go away from the counter and sit on the table with a number for your turn, you can switch ðŸ”€ your attention to your crush ðŸ˜, and \"work\" â¯ ðŸ¤“ on that. Then you are again doing something very \"productive\" ðŸ¤“, as is flirting with your crush ðŸ˜.\r\n\r\nIn my opinion, the many emojis don't add anything to the explanation and make it hard to read. **Every emoji breaks the flow when reading because my eyes are distracted by the emojis' size and colour.**\r\n\r\nIs the 'ðŸ˜' after every 'crush' necessary? Same with burger and ðŸ”, cashier and ðŸ’ and so on.\r\n\r\nI propose cutting down on or completely removing emojis from the documentation to help with readability.\r\n\r\nThe same issue, though less pronounced, is also apparent in the section 'Asynchronous Code' (https://fastapi.tiangolo.com/async/#asynchronous-code).\r\n\r\n***\r\n\r\n(If you want to know what it feels like to read the documentation, try reading this:)\r\n\r\nIn my ðŸ§‘opinion ðŸ¤”, the manyðŸ”¢ emojis", "output": "Emojis are part of our culture. :sweat_smile:\r\n\r\n> (If you want to know what it feels like to read the documentation, try reading this:)\r\n\r\nI've read the documentation, and I don't feel the same as reading your example, as it's clearly ill-intentioned to prove your point. :kissing: \r\n\r\nThat being said, we can wait to see if people have the same opinion as you, and/or you can propose a PR changing that page, and @tiangolo you'll check it at some point.\r\n\r\nI don't think this change is needed, nor do I feel harmed by those emojis, sometimes I even get the opposite effect as the one you mentioned. Which I think is because humans tend to relate images better than letters. \r\n\r\nEDIT: Well... Months have passed, and my opinion has changed. I no longer have strong feelings about this. Although, I think the most important argument here is the one mentioned [here](https://github.com/tiangolo/fastapi/issues/3273#issuecomment-1018297338). :wave:\n\n---\n\nyou can write non emojis one in your self page.\n\n---\n\nThat page was painful to read. Can the emojis be toned down please? \r\n\r\nFor a middle ground, perhaps introduce them in the opening sentence, and then stick to using them at the end of sentences, avoiding the temptation to use them mid-sentences outside their first occurrence.\n\n---\n\n\"we can wait to see if people have the same opinion as you\". It's been a few months, which seems like a reasonable time frame for waiting and seeing. The original post has 14 thumbs up and 2 thumbs down, so it seems like the community is in favor of it.\n\n---\n\nFound this post because I made a search on Google: \"why fastapi doc full of emojis\". I didn't understand why the words are not replaced by the emojis, but instead have the word and the emoji together. If want to keep the emojis, so remove the redundancy for better reading. (i.e. \"You go with your ðŸ˜ to get ðŸ”, you stand in line while the ðŸ’ takes the orders from the people in front of you.\")", "source": "issue", "type": "qa_comprehensive", "issue_number": 44}
{"instruction": "SQLAlchemy Dependency vs. Middleware vs. scoped_session\n\nDetails:\nThe SQLAlchemy library comes with a `scoped_session` object, which effectively allows for thread-safe database sessions. Is there a reason the docs recommend using the dependency method > middleware method > just a `scoped_session` global?", "input": "Repository: FastAPI\nLabels: ", "output": "I'm not sure about the reasoning behind the doc's reccomendations, but the reason why I'd personally advise against making `scoped_session` global is because it then forces you to also have a global `engine` to bind it to, and global variables in ASGI don't have a well-defined lifetime (see #617). There's also how using dependencies rather than globals mean that all the ressource needed by your route are passed as function parameters, which tends to make testing easier since you can just pass a fake DB session instead of the one you would normally use.\r\n\r\n[SQLAlchemy's own doc](https://docs.sqlalchemy.org/en/13/orm/contextual.html#unitofwork-contextual) says `scoped_session` are just one of many ways of handling sessions. From my understanding of how `scoped_session` and sessions work, thread-local sessions might not work that well with FastAPI since Python's coroutines don't have a 1:1 mapping with threads, so I suspect that this could cause some unexpected behavior (though I haven't tried this, I might be wrong).\r\n\r\nI personally prefer handling my connections this way:\r\n\r\n```py\r\nfrom typing import Optional, AsyncIterable\r\n\r\nfrom fastapi import Depends, FastAPI\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import Session\r\nfrom sqlalchemy.engine import Engine as Database\r\n\r\napp = FastAPI()\r\n\r\n_db_conn: Optional[Database]\r\n\r\n@app.on_event(\"startup\")\r\ndef open_database_connection_pools():\r\n    global _db_conn\r\n    _db_conn = create_engine(...)\r\n\r\n@app.on_event(\"shutdown\")\r\ndef close_database_connection_pools():\r\n    global _db_conn\r\n    if _db_conn: _db_conn.dispose()\r\n\r\nasync def get_db_conn() -> Database:\r\n    assert _db_conn is not None\r\n    return _db_conn\r\n\r\n# This is the part that replaces sessionmaker\r\nasync def get_db_sess(db_conn = Depends(get_db_conn)) -> AsyncIterable[Session]:\r\n    sess = Session(bind=db_conn)\r\n\r\n    try:\r\n        yield sess\r\n    finally:\r\n        sess.close()\r\n\r\n@app.get(\"/\")\r\ndef foo(db_sess: Session = Depends(get_db_sess)):\r\n    pass\r\n```\r\n\r\nThe benefits of this approach are:\r\n* You can connect to as many databases as needed, which was a problem for me with the middleware approach, especially when using Flask\r\n* Your DB connections are released at application shutdown instead of garbage collection, which means you won't run into issues if you use `uvicorn --reload`\r\n* Your DB sessions will automatically be closed when the route using as a dependency finishes, so any uncommited operations will be rolled back.\r\n* While testing you can just pass a different Session object so you can write to a test database instead\r\n* When calling that route as a regular function from a different thread (which is a niche case, but it happens), you can pass an existing database session object instead of having the route create a new one.", "source": "issue", "type": "qa_best_answer", "issue_number": 43}
{"instruction": "Provide a comprehensive answer to this question: SQLAlchemy Dependency vs. Middleware vs. scoped_session", "input": "The SQLAlchemy library comes with a `scoped_session` object, which effectively allows for thread-safe database sessions. Is there a reason the docs recommend using the dependency method > middleware method > just a `scoped_session` global?", "output": "I'm not sure about the reasoning behind the doc's reccomendations, but the reason why I'd personally advise against making `scoped_session` global is because it then forces you to also have a global `engine` to bind it to, and global variables in ASGI don't have a well-defined lifetime (see #617). There's also how using dependencies rather than globals mean that all the ressource needed by your route are passed as function parameters, which tends to make testing easier since you can just pass a fake DB session instead of the one you would normally use.\r\n\r\n[SQLAlchemy's own doc](https://docs.sqlalchemy.org/en/13/orm/contextual.html#unitofwork-contextual) says `scoped_session` are just one of many ways of handling sessions. From my understanding of how `scoped_session` and sessions work, thread-local sessions might not work that well with FastAPI since Python's coroutines don't have a 1:1 mapping with threads, so I suspect that this could cause some unexpected behavior (though I haven't tried this, I might be wrong).\r\n\r\nI personally prefer handling my connections this way:\r\n\r\n```py\r\nfrom typing import Optional, AsyncIterable\r\n\r\nfrom fastapi import Depends, FastAPI\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import Session\r\nfrom sqlalchemy.engine import Engine as Database\r\n\r\napp = FastAPI()\r\n\r\n_db_conn: Optional[Database]\r\n\r\n@app.on_event(\"startup\")\r\ndef open_database_connection_pools():\r\n    global _db_conn\r\n    _db_conn = create_engine(...)\r\n\r\n@app.on_event(\"shutdown\")\r\ndef close_database_connection_pools():\r\n    global _db_conn\r\n    if _db_conn: _db_conn.dispose()\r\n\r\nasync def get_db_conn() -> Database:\r\n    assert _db_conn is not None\r\n    return _db_conn\r\n\r\n# This is the part that replaces sessionmaker\r\nasync def get_db_sess(db_conn = Depends(get_db_conn)) -> AsyncIterable[Session]:\r\n    sess = Session(bind=db_conn)\r\n\r\n    try:\r\n        yield sess\r\n    finally:\r\n        sess.close()\r\n\r\n@app.get(\"/\")\r\ndef foo(db_sess: Session = Depends(get_db_sess)):\r\n    pass\r\n```\r\n\r\nThe benefits of this approach are:\r\n* You can connect to as many databases as needed, which was a problem for me with the middleware approach, especially when using Flask\r\n* Your DB connections are released at application shutdown instead of garbage collection, which means you won't run into issues if you use `uvicorn --reload`\r\n* Your DB sessions will automatically be closed when the route using as a dependency finishes, so any uncommited operations will be rolled back.\r\n* While testing you can just pass a different Session object so you can write to a test database instead\r\n* When calling that route as a regular function from a different thread (which is a niche case, but it happens), you can pass an existing database session object instead of having the route create a new one.\n\n---\n\nThanks for the in depth for response @sm-Fifteen! Those do seem like some good benefits over using `scoped_session`.\r\n\r\nOne clarification though: you initially mentioned how it's probably better not to have a global database connection, but then your solution is just passing around the connection as a global, no? You add a layer of indirection with the database connection dependency, but I'm not sure I see the benefit of that approach.\n\n---\n\n> One clarification though: you initially mentioned how it's probably better not to have a global database connection, but then your solution is just passing around the connection as a global, no? You add a layer of indirection with the database connection dependency, but I'm not sure I see the benefit of that approach.\r\n\r\nYeah, I should probably have explained that one a bit more. The important distinction is that while `_db_conn` *lives* in the global scope (mainly because there is nowhere else it could live), it's not *created* in the global scope, nor is it ever accessed directly from the global scope aside from the 3 functions that control it.\r\n\r\nTo go back to the example I was giving:\r\n\r\n```py\r\n_db_conn: Optional[Database]\r\n\r\ndef open_database_connection_pools():\r\n    global _db_conn\r\n    _db_conn = create_engine(...)\r\n\r\ndef close_database_connection_pools():\r\n    global _db_conn\r\n    if _db_conn: _db_conn.dispose()\r\n\r\nasync def get_db_conn() -> Database:\r\n    assert _db_conn is not None\r\n    return _db_conn\r\n```\r\n\r\n...these three functions should be the only places where `_db_conn` is ever used directly. If that seems like a convoluted way of doing the same thing as `_db_conn = create_engine(...)` in the global space and calling it a day, the key thing to understand here is that SQLAlchemy's automatic cleanup system works in a WSGI setting (such as when using Flask) because it it set to cleanup whenever the Python interpreter shuts down. Since ASGI is both event-based and async, though, doing it that way in FastAPI could cause you to run into a number of subtle issues (like the `--reload` problem I briefly mentionned where reloading your code would create a new connection engine without closing the first one, meaning any connection the old engine kept open could leak and stay open). This goes double for any sort of global dependency that isn't SQLAlchemy, because while SQLAlchemy's engines and connection wrappers do extremely smart things to ensure that they get cleaned up automatically without the user having to do anything, most objects will not.\r\n\r\nThis weird pattern with the `startup` and `shutdown` events combined with a global variable is an attempt at combining them into some kind of \"context manager\" to create dependencies with a setup and teardown phase (something like `get_db_sess`), but meant to last for the application's entire lifetime. Since that's not something FastAPI currently supports (see issue #617), for the time being, I need to use variables declared (not defined) in the global scope to store whatever is initialized by the `startup` event and finalized with the `shutdown` event.\r\n\r\nI should specify that in SQLAlchemy's case specifically, this is probably not needed (unless you want to make use of `--reload`), but leaving dependencies open in the global scope had me run into cleanup issues before (especially with async DB connections, which can't asynchoneously close with the Python interpreter because by then the asyncio event loop is most likely gone), so I figure it's a good pattern to use in general.\n\n---\n\nHow about this kind of pattern https://github.com/mfreeborn/fastapi-sqlalchemy similar to the way it works in flask?\n\n---\n\n> How about this kind of pattern https://github.com/mfreeborn/fastapi-sqlalchemy similar to the way it works in flask?\r\n\r\nIt's fine, I guess, but it limits you to a single database connection (I need to connect to at least 3 on one of the projects I'm developping) and it doesn't take advantage of dependency injection so you can't really make your routes or functions use a different DB object without modifying their code or the initialization sequence of your middleware.", "source": "issue", "type": "qa_comprehensive", "issue_number": 43}
{"instruction": "Update docs include syntax for source examples\n\nDetails:\n### Privileged issue\r\n\r\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\r\n\r\n### Issue Content\r\n\r\nThis is a good first contribution. :nerd_face: \r\n\r\nThe code examples shown in the docs are actual Python files. They are even tested in CI, that's why you can always copy paste an example and it will always work, the example is tested.\r\n\r\nThe way those examples are included in the docs used a specific format. But now there's a new format available that is much simpler and easier to use than the previous one, in particular in complex cases, for example when there are examples in multiple versions of Python.\r\n\r\nBut not all the docs have the new format yet. The docs should use the new format to include examples. That is the task. :nerd_face: \r\n\r\n**It should be done as one PR per page updated.**\r\n\r\n## Simple Example\r\n\r\nBefore, the format was like:\r\n\r\n````markdown\r\n```Python hl_lines=\"3\"\r\n{!../../docs_src/first_steps/tutorial001.py!}\r\n```\r\n````\r\n\r\nNow the new format looks like:\r\n\r\n````markdown\r\n{* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n````\r\n\r\n* Instead of `{!` and `!}` it uses `{*` and `*}`\r\n* It no longer has a line above with:\r\n\r\n````markdown\r\n```Python\r\n````\r\n\r\n* And it no longer has a line below with:\r\n\r\n````markdown\r\n```\r\n````\r\n\r\n* The highlight is no longer a line with e.g. `hl_lines=\"3\"` (to highlight line 3), but instead in the same line there's a `hl[3]`.\r\n\r\nAn example PR: https://github.com/fastapi/fastapi/pull/12552\r\n\r\n## Multiple Python Versions\r\n\r\nThere are some cases where there are variants of the same example for multiple versions of Python, or for using `Annotated` or not.\r\n\r\nIn those cases, the current include examples have syntax for tabs, and notes saying `Annotated` should be preferred. For example:\r\n\r\n````markdown\r\n//// tab | Python 3.9+\r\n\r\n```Python hl_lines=\"4  8  12\"\r\n{!> ../../docs_src/security/tutorial006_an_py39.py!}\r\n```\r\n\r\n////\r\n\r\n//// tab | Python 3.8+\r\n\r\n```Python hl_lines=\"2  7  11\"\r\n{!> ../../docs_src/securit", "input": "Repository: FastAPI\nLabels: ", "output": "Osis\r\n\r\nOn Sat, Oct 26, 2024, 6:37 PM SebastiÃ¡n RamÃ­rez ***@***.***>\r\nwrote:\r\n\r\n> Privileged issue\r\n>\r\n>    - I'm @tiangolo <https://github.com/tiangolo> or he asked me directly\r\n>    to create an issue here.\r\n>\r\n> Issue Content\r\n>\r\n> This is a good first contribution. ðŸ¤“\r\n>\r\n> The code examples shown in the docs are actual Python files. They are even\r\n> tested in CI, that's why you can always copy paste an example and it will\r\n> always work, the example is tested.\r\n>\r\n> The way those examples are included in the docs used a specific format.\r\n> But now there's a new format available that is much simpler and easier to\r\n> use than the previous one, in particular in complex cases, for example when\r\n> there are examples in multiple versions of Python.\r\n>\r\n> But not all the docs have the new format yet. The docs should use the new\r\n> format to include examples. That is the task. ðŸ¤“\r\n>\r\n> It should be done as one PR per page updated.\r\n> Simple Example\r\n>\r\n> Before, the format was like:\r\n>\r\n> ```Python hl_lines=\"3\"\r\n> {!../../docs_src/first_steps/tutorial001.py!}```\r\n>\r\n> Now the new format looks like:\r\n>\r\n> {* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n>\r\n>\r\n>    - Instead of {! and !} it uses {* and *}\r\n>    - It no longer has a line above with:\r\n>\r\n> ```Python\r\n>\r\n>\r\n>    - And it no longer has a line below with:\r\n>\r\n> ```\r\n>\r\n>\r\n>    - The highlight is no longer a line with e.g. hl_lines=\"3\" (to\r\n>    highlight line 3), but instead in the same line there's a hl[3].\r\n>\r\n> An example PR: #12552 <https://github.com/fastapi/fastapi/pull/12552>\r\n> Multiple Python Versions\r\n>\r\n> There are some cases where there are variants of the same example for\r\n> multiple versions of Python, or for using Annotated or not.\r\n>\r\n> In those cases, the current include examples have syntax for tabs, and\r\n> notes saying Annotated should be preferred. For example:\r\n>\r\n> //// tab | Python 3.9+\r\n> ```Python hl_lines=\"4  8  12\"\r\n> {!> ../../docs_src/security/tutorial006_an_py39.py!}```\r\n>\r\n> ////\r\n>\r\n> //// tab | Python 3.8+\r\n> ```Python hl_lines=\"2  7  11\"\r\n> {!> ../../docs_src/security/tutorial006_an.py!}```\r\n>\r\n> ////\r\n>\r\n> //// tab | Python 3.8+ non-Annotated\r\n>\r\n> /// tip\r\n>\r\n> Prefer to use the `Annotated` version if possible.\r\n>\r\n> ///\r\n> ```Python hl_lines=\"2  6  10\"\r\n> {!> ../../docs_src/security/tutorial006.py!}```\r\n>\r\n> ////\r\n>\r\n> In these cases, it should be updated to only include the first one (the\r\n> others will be included automatically ðŸ˜Ž ):\r\n>\r\n> {* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}\r\n>\r\n>\r\n>    - The syntax for tabs is also removed, all the other variants are\r\n>    included automatically.\r\n>    - The highlight lines are included for that same first file, the\r\n>    fragment with hl_lines=\"4 8 12\" is replaced with hl[4,8,12]\r\n>\r\n> An example PR: #12553 <https://github.com/fastapi/fastapi/pull/12553>\r\n>\r\n> â€”\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/fastapi/fastapi/issues/12554>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ABCOVL2FRNCDPALCW7LAZRLZ5OHY5AVCNFSM6AAAAABQUZLFL2VHI2DSMVQWIX3LMV43ASLTON2WKOZSGYYTKOBVGYYDINA>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>", "source": "issue", "type": "qa_best_answer", "issue_number": 42}
{"instruction": "Provide a comprehensive answer to this question: Update docs include syntax for source examples", "input": "### Privileged issue\r\n\r\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\r\n\r\n### Issue Content\r\n\r\nThis is a good first contribution. :nerd_face: \r\n\r\nThe code examples shown in the docs are actual Python files. They are even tested in CI, that's why you can always copy paste an example and it will always work, the example is tested.\r\n\r\nThe way those examples are included in the docs used a specific format. But now there's a new format available that is much simpler and easier to use than the previous one, in particular in complex cases, for example when there are examples in multiple versions of Python.\r\n\r\nBut not all the docs have the new format yet. The docs should use the new format to include examples. That is the task. :nerd_face: \r\n\r\n**It should be done as one PR per page updated.**\r\n\r\n## Simple Example\r\n\r\nBefore, the format was like:\r\n\r\n````markdown\r\n```Python hl_lines=\"3\"\r\n{!../../docs_src/first_steps/tutorial001.py!}\r\n```\r\n````\r\n\r\nNow the new format looks like:\r\n\r\n````markdown\r\n{* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n````\r\n\r\n* Instead of `{!` and `!}` it uses `{*` and `*}`\r\n* It no longer has a line above with:\r\n\r\n````markdown\r\n```Python\r\n````\r\n\r\n* And it no longer has a line below with:\r\n\r\n````markdown\r\n```\r\n````\r\n\r\n* The highlight is no longer a line with e.g. `hl_lines=\"3\"` (to highlight line 3), but instead in the same line there's a `hl[3]`.\r\n\r\nAn example PR: https://github.com/fastapi/fastapi/pull/12552\r\n\r\n## Multiple Python Versions\r\n\r\nThere are some cases where there are variants of the same example for multiple versions of Python, or for using `Annotated` or not.\r\n\r\nIn those cases, the current include examples have syntax for tabs, and notes saying `Annotated` should be preferred. For example:\r\n\r\n````markdown\r\n//// tab | Python 3.9+\r\n\r\n```Python hl_lines=\"4  8  12\"\r\n{!> ../../docs_src/security/tutorial006_an_py39.py!}\r\n```\r\n\r\n////\r\n\r\n//// tab | Python 3.8+\r\n\r\n```Python hl_lines=\"2  7  11\"\r\n{!> ../../docs_src/securit", "output": "Osis\r\n\r\nOn Sat, Oct 26, 2024, 6:37 PM SebastiÃ¡n RamÃ­rez ***@***.***>\r\nwrote:\r\n\r\n> Privileged issue\r\n>\r\n>    - I'm @tiangolo <https://github.com/tiangolo> or he asked me directly\r\n>    to create an issue here.\r\n>\r\n> Issue Content\r\n>\r\n> This is a good first contribution. ðŸ¤“\r\n>\r\n> The code examples shown in the docs are actual Python files. They are even\r\n> tested in CI, that's why you can always copy paste an example and it will\r\n> always work, the example is tested.\r\n>\r\n> The way those examples are included in the docs used a specific format.\r\n> But now there's a new format available that is much simpler and easier to\r\n> use than the previous one, in particular in complex cases, for example when\r\n> there are examples in multiple versions of Python.\r\n>\r\n> But not all the docs have the new format yet. The docs should use the new\r\n> format to include examples. That is the task. ðŸ¤“\r\n>\r\n> It should be done as one PR per page updated.\r\n> Simple Example\r\n>\r\n> Before, the format was like:\r\n>\r\n> ```Python hl_lines=\"3\"\r\n> {!../../docs_src/first_steps/tutorial001.py!}```\r\n>\r\n> Now the new format looks like:\r\n>\r\n> {* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n>\r\n>\r\n>    - Instead of {! and !} it uses {* and *}\r\n>    - It no longer has a line above with:\r\n>\r\n> ```Python\r\n>\r\n>\r\n>    - And it no longer has a line below with:\r\n>\r\n> ```\r\n>\r\n>\r\n>    - The highlight is no longer a line with e.g. hl_lines=\"3\" (to\r\n>    highlight line 3), but instead in the same line there's a hl[3].\r\n>\r\n> An example PR: #12552 <https://github.com/fastapi/fastapi/pull/12552>\r\n> Multiple Python Versions\r\n>\r\n> There are some cases where there are variants of the same example for\r\n> multiple versions of Python, or for using Annotated or not.\r\n>\r\n> In those cases, the current include examples have syntax for tabs, and\r\n> notes saying Annotated should be preferred. For example:\r\n>\r\n> //// tab | Python 3.9+\r\n> ```Python hl_lines=\"4  8  12\"\r\n> {!> ../../docs_src/security/tutorial006_an_py39.py!}```\r\n>\r\n> ////\r\n>\r\n> //// tab | Python 3.8+\r\n> ```Python hl_lines=\"2  7  11\"\r\n> {!> ../../docs_src/security/tutorial006_an.py!}```\r\n>\r\n> ////\r\n>\r\n> //// tab | Python 3.8+ non-Annotated\r\n>\r\n> /// tip\r\n>\r\n> Prefer to use the `Annotated` version if possible.\r\n>\r\n> ///\r\n> ```Python hl_lines=\"2  6  10\"\r\n> {!> ../../docs_src/security/tutorial006.py!}```\r\n>\r\n> ////\r\n>\r\n> In these cases, it should be updated to only include the first one (the\r\n> others will be included automatically ðŸ˜Ž ):\r\n>\r\n> {* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}\r\n>\r\n>\r\n>    - The syntax for tabs is also removed, all the other variants are\r\n>    included automatically.\r\n>    - The highlight lines are included for that same first file, the\r\n>    fragment with hl_lines=\"4 8 12\" is replaced with hl[4,8,12]\r\n>\r\n> An example PR: #12553 <https://github.com/fastapi/fastapi/pull/12553>\r\n>\r\n> â€”\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/fastapi/fastapi/issues/12554>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ABCOVL2FRNCDPALCW7LAZRLZ5OHY5AVCNFSM6AAAAABQUZLFL2VHI2DSMVQWIX3LMV43ASLTON2WKOZSGYYTKOBVGYYDINA>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\n\n---\n\nIeje\r\n\r\nOn Sat, Oct 26, 2024, 6:54 PM Rajendra Prasad K ***@***.***>\r\nwrote:\r\n\r\n> Osis\r\n>\r\n> On Sat, Oct 26, 2024, 6:37 PM SebastiÃ¡n RamÃ­rez ***@***.***>\r\n> wrote:\r\n>\r\n>> Privileged issue\r\n>>\r\n>>    - I'm @tiangolo <https://github.com/tiangolo> or he asked me directly\r\n>>    to create an issue here.\r\n>>\r\n>> Issue Content\r\n>>\r\n>> This is a good first contribution. ðŸ¤“\r\n>>\r\n>> The code examples shown in the docs are actual Python files. They are\r\n>> even tested in CI, that's why you can always copy paste an example and it\r\n>> will always work, the example is tested.\r\n>>\r\n>> The way those examples are included in the docs used a specific format.\r\n>> But now there's a new format available that is much simpler and easier to\r\n>> use than the previous one, in particular in complex cases, for example when\r\n>> there are examples in multiple versions of Python.\r\n>>\r\n>> But not all the docs have the new format yet. The docs should use the new\r\n>> format to include examples. That is the task. ðŸ¤“\r\n>>\r\n>> It should be done as one PR per page updated.\r\n>> Simple Example\r\n>>\r\n>> Before, the format was like:\r\n>>\r\n>> ```Python hl_lines=\"3\"\r\n>> {!../../docs_src/first_steps/tutorial001.py!}```\r\n>>\r\n>> Now the new format looks like:\r\n>>\r\n>> {* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n>>\r\n>>\r\n>>    - Instead of {! and !} it uses {* and *}\r\n>>    - It no longer has a line above with:\r\n>>\r\n>> ```Python\r\n>>\r\n>>\r\n>>    - And it no longer has a line below with:\r\n>>\r\n>> ```\r\n>>\r\n>>\r\n>>    - The highlight is no longer a line with e.g. hl_lines=\"3\" (to\r\n>>    highlight line 3), but instead in the same line there's a hl[3].\r\n>>\r\n>> An example PR: #12552 <https://github.com/fastapi/fastapi/pull/12552>\r\n>> Multiple Python Versions\r\n>>\r\n>> There are some cases where there are variants of the same example for\r\n>> multiple versions of Python, or for using Annotated or not.\r\n>>\r\n>> In those cases, the current include examples have syntax for tabs, and\r\n>> notes saying Annotated should be preferred. For example:\r\n>>\r\n>> //// tab | Python 3.9+\r\n>> ```Python hl_lines=\"4  8  12\"\r\n>> {!> ../../docs_src/security/tutorial006_an_py39.py!}```\r\n>>\r\n>> ////\r\n>>\r\n>> //// tab | Python 3.8+\r\n>> ```Python hl_lines=\"2  7  11\"\r\n>> {!> ../../docs_src/security/tutorial006_an.py!}```\r\n>>\r\n>> ////\r\n>>\r\n>> //// tab | Python 3.8+ non-Annotated\r\n>>\r\n>> /// tip\r\n>>\r\n>> Prefer to use the `Annotated` version if possible.\r\n>>\r\n>> ///\r\n>> ```Python hl_lines=\"2  6  10\"\r\n>> {!> ../../docs_src/security/tutorial006.py!}```\r\n>>\r\n>> ////\r\n>>\r\n>> In these cases, it should be updated to only include the first one (the\r\n>> others will be included automatically ðŸ˜Ž ):\r\n>>\r\n>> {* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}\r\n>>\r\n>>\r\n>>    - The syntax for tabs is also removed, all the other variants are\r\n>>    included automatically.\r\n>>    - The highlight lines are included for that same first file, the\r\n>>    fragment with hl_lines=\"4 8 12\" is replaced with hl[4,8,12]\r\n>>\r\n>> An example PR: #12553 <https://github.com/fastapi/fastapi/pull/12553>\r\n>>\r\n>> â€”\r\n>> Reply to this email directly, view it on GitHub\r\n>> <https://github.com/fastapi/fastapi/issues/12554>, or unsubscribe\r\n>> <https://github.com/notifications/unsubscribe-auth/ABCOVL2FRNCDPALCW7LAZRLZ5OHY5AVCNFSM6AAAAABQUZLFL2VHI2DSMVQWIX3LMV43ASLTON2WKOZSGYYTKOBVGYYDINA>\r\n>> .\r\n>> You are receiving this because you are subscribed to this thread.Message\r\n>> ID: ***@***.***>\r\n>>\r\n>\n\n---\n\ni want to contribute \r\nWill the issue be assigned?\n\n---\n\n@FarhanAliRaza the issue is not assigned, there are many PRs that would come out of this, one PR per page fixed, so, you can just take a page that has the old syntax, check there are no other PRs handling it, then update the syntax, and make a PR for it.\n\n---\n\n> @FarhanAliRaza the issue is not assigned, there are many PRs that would come out of this, one PR per page fixed, so, you can just take a page that has the old syntax, check there are no other PRs handling it, then update the syntax, and make a PR for it.\r\n\r\nthe game is kicked off ðŸ˜„", "source": "issue", "type": "qa_comprehensive", "issue_number": 42}
{"instruction": "about threads issue with fastapi.\n\nDetails:\nHi, I have a question about the threads issue with fastapi.\r\n\r\n\r\nWhen I run the example from tutorial `uvicorn main:app --reload --port 4681 --host 0.0.0.0` with the following `main.py`\r\n```python\r\nfrom fastapi import FastAPI\r\napp = FastAPI()\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n@app.get(\"/items/{item_id}\")\r\ndef read_item(item_id: int, q: str = None):\r\n    return {\"item_id\": item_id, \"q\": q}\r\n```\r\n\r\nand it show up the following information\r\n```\r\nINFO: Started server process [18983]\r\nINFO: Waiting for application startup.\r\nINFO: Uvicorn running on http://0.0.0.0:4681 (Press CTRL+C to quit)\r\n```\r\n\r\n__then I use `ps -o nlwp 18983` to see how many threads this process (18983) is using.__\r\n\r\nHowever, everytime when I send a request to this service, the number of threads increase without being closed. To be more specific, __when I send 1000 requests, this process ended up with 1000 threads running.__\r\n\r\nThis is problematic because I tried to serve another more complicated applications, allocating arbitrary number of threads would finally get my machine out of resources.\r\n\r\nIs there any thing I could have done wrong?\r\nThanks in advance!", "input": "Repository: FastAPI\nLabels: ", "output": "Interested also to this question. Run it also on my machine with multiple workers and observed similar behaviour for each one of them. Would like to know what's happening as we are thinking of using fastAPI for some production service that would be running long term.", "source": "issue", "type": "qa_best_answer", "issue_number": 41}
{"instruction": "Provide a comprehensive answer to this question: about threads issue with fastapi.", "input": "Hi, I have a question about the threads issue with fastapi.\r\n\r\n\r\nWhen I run the example from tutorial `uvicorn main:app --reload --port 4681 --host 0.0.0.0` with the following `main.py`\r\n```python\r\nfrom fastapi import FastAPI\r\napp = FastAPI()\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n@app.get(\"/items/{item_id}\")\r\ndef read_item(item_id: int, q: str = None):\r\n    return {\"item_id\": item_id, \"q\": q}\r\n```\r\n\r\nand it show up the following information\r\n```\r\nINFO: Started server process [18983]\r\nINFO: Waiting for application startup.\r\nINFO: Uvicorn running on http://0.0.0.0:4681 (Press CTRL+C to quit)\r\n```\r\n\r\n__then I use `ps -o nlwp 18983` to see how many threads this process (18983) is using.__\r\n\r\nHowever, everytime when I send a request to this service, the number of threads increase without being closed. To be more specific, __when I send 1000 requests, this process ended up with 1000 threads running.__\r\n\r\nThis is problematic because I tried to serve another more complicated applications, allocating arbitrary number of threads would finally get my machine out of resources.\r\n\r\nIs there any thing I could have done wrong?\r\nThanks in advance!", "output": "Interested also to this question. Run it also on my machine with multiple workers and observed similar behaviour for each one of them. Would like to know what's happening as we are thinking of using fastAPI for some production service that would be running long term.\n\n---\n\nCan you share your environment (starlette, fastapi, uvicorn, python, and operating system versions)?\r\n\r\nCan you check if you get the same behavior if you change the endpoints to be async def?\n\n---\n\nAlso can you check if you get the same behavior when running uvicorn without the â€”reload flag?\n\n---\n\nI get the same behavior with `--reload` flag.\r\nHowever interestingly, this is solved after I use async def ...\r\n\r\nMy environments:\r\nUbuntu 16.04.6 LTS\r\nPython 3.6.9 :: Anaconda, Inc.\r\nstarlette                 0.12.8\r\nfastapi                   0.38.1\r\nuvicorn                   0.9.0\n\n---\n\nI'm curious - does the same thing happen when using one of the docker images listed [here](https://fastapi.tiangolo.com/deployment/)?", "source": "issue", "type": "qa_comprehensive", "issue_number": 41}
{"instruction": "Are there any api developer docs?\n\nDetails:\n### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nWhat I mean by api developer docs are basically something like sphinx docs for function definitions. This is usually generated from function docstrings (which I didn't see any in my small amount of browsing the FastAPI codebase). For example, here are the docs for github3 https://github3py.readthedocs.io/en/master/api-reference/index.html. It is an easy way to click through the entire package and see class and function definitions.\r\n\r\nDoes FastAPI have these? The tutorial docs look pretty good, but sometimes I just want to know what all the function parameters are independent of the context in a tutorial.", "input": "Repository: FastAPI\nLabels: ", "output": "Not yet. I expect to use https://github.com/tomchristie/mkautodoc at some point.\r\n\r\nBut first I have to clean up some of the parameters, define a docstring style, and add docstrings everywhere.", "source": "issue", "type": "qa_best_answer", "issue_number": 40}
{"instruction": "Provide a comprehensive answer to this question: Are there any api developer docs?", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nWhat I mean by api developer docs are basically something like sphinx docs for function definitions. This is usually generated from function docstrings (which I didn't see any in my small amount of browsing the FastAPI codebase). For example, here are the docs for github3 https://github3py.readthedocs.io/en/master/api-reference/index.html. It is an easy way to click through the entire package and see class and function definitions.\r\n\r\nDoes FastAPI have these? The tutorial docs look pretty good, but sometimes I just want to know what all the function parameters are independent of the context in a tutorial.", "output": "Not yet. I expect to use https://github.com/tomchristie/mkautodoc at some point.\r\n\r\nBut first I have to clean up some of the parameters, define a docstring style, and add docstrings everywhere.\n\n---\n\n@tiangolo \r\nHi! Just out of interest, but what do you think about using [pawamoy/mkdocstrings](https://github.com/pawamoy/mkdocstrings)? I recently used this project and it worked without any problems.\n\n---\n\nI have used https://www.sphinx-doc.org/en/master/ before and they look pretty nice. Works very well for Python code in my opinion.\n\n---\n\n@tiangolo if you were able to define a docstring style I'd be happy to start contributing some notes.  I habitually check documentation in my IDE and would love to have some quick references available for FastAPI.\r\n\r\nAs far as picking a style, of course the mk tools want the docstrings to be in Markdown.  Unfortunately PyCharm won't render / extract any useful information from the docstrings unless they are in one of it's supported formats (e.g. reStructuredText, Epytext) none of which use Markdown to my knowledge.  Maybe that won't matter though because markdown is so easy to read unrendered.\n\n---\n\nI would also be happy to contribute once a style is finalized.  I believe this is also missing in starlette...", "source": "issue", "type": "qa_comprehensive", "issue_number": 40}
{"instruction": "Validation in the FastAPI response handler is a lot heavier than expected\n\nDetails:\n### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nSo I have built a Tortoise ORM to Pydantic adaptor, and it's about stable, so I started profiling and found some interesting.\r\n\r\nPydantic will validate the data I fetch from the DB, which seems redundant as the DB content is already validated. So we are doing double validation.\r\nFurther profiling I found that the majority of time is spent by FastAPI preparing the data for serialisation, and then validating it, and then actually serialising (This specific step is what https://github.com/tiangolo/fastapi/issues/1224#issuecomment-617243856 refers to)\r\n\r\nSo I am doing essentially triple validation...\r\n\r\nI then saw that there is the orjson integration, I tried that... and it made no difference that I could tell. (I'll get to this later)\r\n\r\nI did a few experiments (none of them properly tested, but just to get an idea) with a simple benchmark:\r\n(The database was populated with 200 junk user profiles generated by hypothesis, response is 45694 bytes)\r\n\r\nKey:\r\nR1 â†’ Using FastAPI to serialise a `List[User]` model automatically (where `User` is a Pydantic model)\r\nR2 â†’ Using FastAPI to serialise a `List[User]` model automatically, but disabled the validation step in `serialize_response`\r\nR3 â†’ Manually serialised the data using an `ORJSONResponse`\r\nR4 â†’ Using FastAPI to serialise a `List[User]` model automatically, bypassed the `jsonable_encoder` as I'm serialising with orjson\r\nR5 â†’ Using FastAPI to serialise a `List[User]` model automatically, bypassed both validation and `jsonable_encoder`\r\nC1 â†’ Use provided pydantic `from_orm` \r\nC2 â†’ Custom constructor that doesn't validate\r\n\r\nMy results are:\r\nR1 + C1 â†’ 42req/s\r\nR1 + C2 â†’ 43req/s  (Seems the 3 FastAPI steps overpower the validation overhead of `from_o", "input": "Repository: FastAPI\nLabels: ", "output": "Nice, thanks for confirming my suspicions and getting some actual performance measurements on that issue. Out of curiosity, do you benchmark requests per second sequentially or in parallel? Given how encoding is part of the critical path on the event loop, `jsonable_encoder` and the json renderer are expected to have the worst performance impact when attempting to handle multiple requests in parallel, since they both block the event loop for whatever amount of time they end up running ([since they are CPU-bound](https://docs.python.org/3/library/asyncio-dev.html#running-blocking-code)).", "source": "issue", "type": "qa_best_answer", "issue_number": 39}
{"instruction": "Provide a comprehensive answer to this question: Validation in the FastAPI response handler is a lot heavier than expected", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nSo I have built a Tortoise ORM to Pydantic adaptor, and it's about stable, so I started profiling and found some interesting.\r\n\r\nPydantic will validate the data I fetch from the DB, which seems redundant as the DB content is already validated. So we are doing double validation.\r\nFurther profiling I found that the majority of time is spent by FastAPI preparing the data for serialisation, and then validating it, and then actually serialising (This specific step is what https://github.com/tiangolo/fastapi/issues/1224#issuecomment-617243856 refers to)\r\n\r\nSo I am doing essentially triple validation...\r\n\r\nI then saw that there is the orjson integration, I tried that... and it made no difference that I could tell. (I'll get to this later)\r\n\r\nI did a few experiments (none of them properly tested, but just to get an idea) with a simple benchmark:\r\n(The database was populated with 200 junk user profiles generated by hypothesis, response is 45694 bytes)\r\n\r\nKey:\r\nR1 â†’ Using FastAPI to serialise a `List[User]` model automatically (where `User` is a Pydantic model)\r\nR2 â†’ Using FastAPI to serialise a `List[User]` model automatically, but disabled the validation step in `serialize_response`\r\nR3 â†’ Manually serialised the data using an `ORJSONResponse`\r\nR4 â†’ Using FastAPI to serialise a `List[User]` model automatically, bypassed the `jsonable_encoder` as I'm serialising with orjson\r\nR5 â†’ Using FastAPI to serialise a `List[User]` model automatically, bypassed both validation and `jsonable_encoder`\r\nC1 â†’ Use provided pydantic `from_orm` \r\nC2 â†’ Custom constructor that doesn't validate\r\n\r\nMy results are:\r\nR1 + C1 â†’ 42req/s\r\nR1 + C2 â†’ 43req/s  (Seems the 3 FastAPI steps overpower the validation overhead of `from_o", "output": "Nice, thanks for confirming my suspicions and getting some actual performance measurements on that issue. Out of curiosity, do you benchmark requests per second sequentially or in parallel? Given how encoding is part of the critical path on the event loop, `jsonable_encoder` and the json renderer are expected to have the worst performance impact when attempting to handle multiple requests in parallel, since they both block the event loop for whatever amount of time they end up running ([since they are CPU-bound](https://docs.python.org/3/library/asyncio-dev.html#running-blocking-code)).\n\n---\n\nI tested with a concurrency of 10, but making it single concurrency hardly affected the results, as it was using a sqlite db as a backend (which is also single concurrency).\r\n\r\nThe benchmarks was just to find bottlenecks, and not to be representative of \"real-world\" use cases.\r\n\r\nI think we should see if the default responder is orjson, and then skip `jsonable_encoder`. And do a full regression test with that config to find out if this is a valid use-case?\n\n---\n\n@grigi \r\n- Do you have numbers when using multiple workers?\r\n- Can you try it with postgres (may not help if you don't use something like asynvpg)\r\n\r\nI don' think there's anything fastapi can do about the speed of pydantic validation, by design that's how pydantic is setup to work so you can't populate invalid properties on its objects, there's no guarantee your database.\r\n\r\nI do agree however there are a good number of dependencies that could probably be improved with either faster or async aware alternatives, the less we block the better this will be, but also realizing there will always be blocking somewhere.\n\n---\n\nI expect it will scale nearly linearly, the DB is only 1.5% of the execution time...\r\n\r\nAlso, i'm very aware of how the event loop is susceptible to long-running sync code. This is an exercise in identifying bottlenecks, and then discussing the outcomes (as I'm not that familiar with fastapi internals at this stage)\r\n\r\nHere is a annotated flamegraph of the unmodified stack:\r\n![image](https://user-images.githubusercontent.com/1309160/80872295-47cdef80-8cb1-11ea-879a-0f35209a7931.png)\r\n\r\n1) When one builds a Pydantic object from an existing class-instance/dict, Pydantic will **always** validate, unless you completely bypass validation using `construct`. But when doing that, recursive models are not built properly, so ideally one would want to use the validation when building. Also bypassing validation in Pydantic comes with **BIG** warnings.\r\n\r\n   In the flamegraph (used vmprof) the exact same C function that does the Pydantic validation was run again part of `serialise_response`. This is not ideal as when building a Pydantic model off existing data, it already validates in the same way.\r\n\r\n   Possibly it is needed for the case where one returns a dict, but then the standard validation will happen in any case?\r\n\r\n2) Using a faster JSON serialiser is going to speed up the 2.8% portion of the runtine (hence my comment that using orjson does very little in this case), but orjson & Rapidjson could do much of what the `jsonable_encoder` is doing, and can possibly be skipped. That is now a 39.4% (36.6% + 2.8%) eligible runtime to speed up. Which is significant.\r\n\r\nMy comments was that ALWAYS forcing validation seems redundant to me, but I don't know all the use-cases. So am seeking advice on how to do this right in the future? Should the `serialise_response` be automatically selective when it does validation? Skip it altogether? Require manual notice that it's not required?\n\n---\n\nTo Victor (your message disappeared here?)\r\n\r\nI manually removed the validation code in FastAPI for this test purposes...\r\nIt does seem that we might want to consider forcing validation off on a per-route option?\r\n\r\nI can do some PR's for this, time is limited though. I am thinking of 2 different PR's:\r\n1. Skip `jsonable_encoder` if the Response has a `response_model_skip_jsonable_encoder` set. (Possibly we want to allow this to be manually set by the route?)\r\n2. Skip validation if when you specify a `response_model_skip_validation` option when setting up the route.", "source": "issue", "type": "qa_comprehensive", "issue_number": 39}
{"instruction": "how can i run scheduling tasks using fastapi's\n\nDetails:\n**Description**\r\n\r\nHow can I [...]?\r\n\r\nIs it possible to [...]?\r\n\r\n**Additional context**\r\nAdd any other context or screenshots about the feature request here.", "input": "Repository: FastAPI\nLabels: ", "output": "it's not strictly speaking a FastAPI question but here are some options, find what works best for you\r\n\r\nthe best without any doubt :grin: https://linux.die.net/man/5/crontab\r\n\r\nsome python tools > \r\nhttps://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html\r\nhttps://docs.python.org/3/library/sched.html\r\nhttps://github.com/dbader/schedule\r\nhttps://github.com/Bogdanp/dramatiq/tree/master/examples/scheduling", "source": "issue", "type": "qa_best_answer", "issue_number": 38}
{"instruction": "Provide a comprehensive answer to this question: how can i run scheduling tasks using fastapi's", "input": "**Description**\r\n\r\nHow can I [...]?\r\n\r\nIs it possible to [...]?\r\n\r\n**Additional context**\r\nAdd any other context or screenshots about the feature request here.", "output": "it's not strictly speaking a FastAPI question but here are some options, find what works best for you\r\n\r\nthe best without any doubt :grin: https://linux.die.net/man/5/crontab\r\n\r\nsome python tools > \r\nhttps://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html\r\nhttps://docs.python.org/3/library/sched.html\r\nhttps://github.com/dbader/schedule\r\nhttps://github.com/Bogdanp/dramatiq/tree/master/examples/scheduling\n\n---\n\nyes those methods I know but it is not working with an async function\n\n---\n\nhttps://github.com/aio-libs/aiojobs maybe ? never tried it\n\n---\n\nAPScheduler has an asyncio implementation https://apscheduler.readthedocs.io/en/latest/\r\n\r\nExample in their git https://github.com/agronholm/apscheduler/blob/master/examples/schedulers/asyncio_.py\n\n---\n\nhey I am able to run background task but my unicorn server has stopped..how can I run both servers simultaneously", "source": "issue", "type": "qa_comprehensive", "issue_number": 38}
{"instruction": "Will FastAPI support QUERY http method? \"app.query\"\n\nDetails:\n### Discussed in https://github.com/fastapi/fastapi/discussions/6049\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **FilipeMarch** December 16, 2022</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.query('/query/subjects')\r\ndef query_subjects(schema: ArbitrarySchema):\r\n    with Session(engine) as db:\r\n        subjects = db.query(Subject).all()\r\n        return schema(**subjects)\r\n\r\n# something like this\r\n```\r\n\r\n\r\n### Description\r\n\r\nThere is a new HTTP method called QUERY, I discovered it this week and it is super interesting!\r\n\r\nhttps://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html\r\n\r\nI was trying to make a GET route that would accept a request body, but started receiving an error on Swagger UI:\r\n\r\n[TypeError: Request has method 'GET' and cannot have a body](https://github.com/swagger-api/swagger-ui/issues/5891#issuecomment-1340591857)\r\n\r\nThe idea is that sometimes we need to make a big or complex query, and this is the scenario in which we can see the advantages of GraphQL, and although I have seen that [we can integrate FastAPI with GraphQL](https://fastapi.tiangol", "input": "Repository: FastAPI\nLabels: ", "output": "`httptools` supports the query method. FastAPI can support it now.", "source": "issue", "type": "qa_best_answer", "issue_number": 37}
{"instruction": "Provide a comprehensive answer to this question: Will FastAPI support QUERY http method? \"app.query\"", "input": "### Discussed in https://github.com/fastapi/fastapi/discussions/6049\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **FilipeMarch** December 16, 2022</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.query('/query/subjects')\r\ndef query_subjects(schema: ArbitrarySchema):\r\n    with Session(engine) as db:\r\n        subjects = db.query(Subject).all()\r\n        return schema(**subjects)\r\n\r\n# something like this\r\n```\r\n\r\n\r\n### Description\r\n\r\nThere is a new HTTP method called QUERY, I discovered it this week and it is super interesting!\r\n\r\nhttps://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html\r\n\r\nI was trying to make a GET route that would accept a request body, but started receiving an error on Swagger UI:\r\n\r\n[TypeError: Request has method 'GET' and cannot have a body](https://github.com/swagger-api/swagger-ui/issues/5891#issuecomment-1340591857)\r\n\r\nThe idea is that sometimes we need to make a big or complex query, and this is the scenario in which we can see the advantages of GraphQL, and although I have seen that [we can integrate FastAPI with GraphQL](https://fastapi.tiangol", "output": "`httptools` supports the query method. FastAPI can support it now.\n\n---\n\nI would like to attempt this one as a good first issue!\n\n---\n\nI'll give this an attempt and see where I can get\n\n---\n\n@alam-zishan: I have something [here](https://github.com/fastapi/fastapi/pull/12969), feel free to build on it! I got stuck on getting swagger docs for the new method to show up.\n\n---\n\n@alam-zishan are you still working on this? Can I make something for this?", "source": "issue", "type": "qa_comprehensive", "issue_number": 37}
{"instruction": "How to bridge Pydantic models with SQLAlchemy?\n\nDetails:\n**Description**\r\n\r\nUp until database interaction is introduced, the tutorial for FastAPI uses pydantic models for everything, such as this example in [the sextion on Extra Models](https://fastapi.tiangolo.com/tutorial/extra-models/) :\r\n\r\n```python\r\nclass UserOut(BaseModel):\r\n    username: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n\r\n\r\nclass UserInDB(BaseModel):\r\n    username: str\r\n    hashed_password: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n```\r\n\r\nThis alows for the \"database model\" to have private data which will not be exposed through the API. Later, in [the section on security](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/), a similar trick is used, but this time using inheritance to stack the two models (which I find makes the return-casting used by some functions better encoded in the type system).\r\n\r\n```py\r\nclass User(BaseModel):\r\n    username: str\r\n    email: str = None\r\n    full_name: str = None\r\n    disabled: bool = None\r\n\r\n\r\nclass UserInDB(User):\r\n    hashed_password: str\r\n```\r\n\r\n```py\r\ndef get_db_user() -> UserInDB:\r\n    return UserInDB(\r\n        username=\"johndoe\", full_name=\"John Doe\",\r\n        email=\"johndoe@example.com\",\r\n        hashed_password=\"fakehashedsecret\",\r\n        disabled=False\r\n    )\r\n\r\ndef get_user() -> User:\r\n    return get_db_user()\r\n```\r\n\r\nHowever, when [proper databases are introduced](https://fastapi.tiangolo.com/tutorial/sql-databases/), those Pydantic models are dropped in favor of a single SQLAlchemy ORM model, with no effort to bridge the two parts. And while one could see this as the SQLAlchemy models completely superseding the Pydantic models, [the fullstack demo app](https://github.com/tiangolo/full-stack-fastapi-postgresql) appears to [actually use both](https://github.com/tiangolo/full-stack-fastapi-postgresql/blob/ecd634e49715bb57fdfeb35b9dba21a6e94cf012/%7B%7Bcookiecutter.project_slug%7D%7D/backend/app/app/api/api_v1/endpoints/login.py#L13-L16), so there appears to be value in attempt", "input": "Repository: FastAPI\nLabels: ", "output": "From what I can tell, there is no problem using both pydantic models and SQLAlchemy models, and if you want to use sqlalchemy as your ORM you will *need* to use both.\r\n\r\nI've found this a little frustrating because, at least in my experience, it leads to lots of similarly-named objects and repetition of definitions, and frequent translation between the types depending on how you are using them. @tiangolo I would be interested if you have any suggestions for design patterns that would reduce the amount of \"translation\" code associated with having separate pydantic and sqlalchemy models.\r\n\r\nMore generally, I would be interested to hear if anyone has found a clean approach to bridging the gap between pydantic and a database, especially if it integrates nicely with an asynchronous database driver (I've been using ([encode/databases](https://github.com/encode/databases)), which only supports SQLAlchemy core,  not the ORM). In particular, it would be nice if I only had to create a single class for each conceptual model (I'd be okay with separate classes for pydantic and the orm as long as they could be derived from a common root).\r\n\r\nMy current approach has been to create a container class that holds references to the database table and the appropriate creation/in-db pydantic models (similar to UserCreate and UserInDB from the docs), and has a variety of generic classmethods for CRUD that make use of the creation/in-db types for input / return, but it still feels like a hack.", "source": "issue", "type": "qa_best_answer", "issue_number": 36}
{"instruction": "Provide a comprehensive answer to this question: How to bridge Pydantic models with SQLAlchemy?", "input": "**Description**\r\n\r\nUp until database interaction is introduced, the tutorial for FastAPI uses pydantic models for everything, such as this example in [the sextion on Extra Models](https://fastapi.tiangolo.com/tutorial/extra-models/) :\r\n\r\n```python\r\nclass UserOut(BaseModel):\r\n    username: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n\r\n\r\nclass UserInDB(BaseModel):\r\n    username: str\r\n    hashed_password: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n```\r\n\r\nThis alows for the \"database model\" to have private data which will not be exposed through the API. Later, in [the section on security](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/), a similar trick is used, but this time using inheritance to stack the two models (which I find makes the return-casting used by some functions better encoded in the type system).\r\n\r\n```py\r\nclass User(BaseModel):\r\n    username: str\r\n    email: str = None\r\n    full_name: str = None\r\n    disabled: bool = None\r\n\r\n\r\nclass UserInDB(User):\r\n    hashed_password: str\r\n```\r\n\r\n```py\r\ndef get_db_user() -> UserInDB:\r\n    return UserInDB(\r\n        username=\"johndoe\", full_name=\"John Doe\",\r\n        email=\"johndoe@example.com\",\r\n        hashed_password=\"fakehashedsecret\",\r\n        disabled=False\r\n    )\r\n\r\ndef get_user() -> User:\r\n    return get_db_user()\r\n```\r\n\r\nHowever, when [proper databases are introduced](https://fastapi.tiangolo.com/tutorial/sql-databases/), those Pydantic models are dropped in favor of a single SQLAlchemy ORM model, with no effort to bridge the two parts. And while one could see this as the SQLAlchemy models completely superseding the Pydantic models, [the fullstack demo app](https://github.com/tiangolo/full-stack-fastapi-postgresql) appears to [actually use both](https://github.com/tiangolo/full-stack-fastapi-postgresql/blob/ecd634e49715bb57fdfeb35b9dba21a6e94cf012/%7B%7Bcookiecutter.project_slug%7D%7D/backend/app/app/api/api_v1/endpoints/login.py#L13-L16), so there appears to be value in attempt", "output": "From what I can tell, there is no problem using both pydantic models and SQLAlchemy models, and if you want to use sqlalchemy as your ORM you will *need* to use both.\r\n\r\nI've found this a little frustrating because, at least in my experience, it leads to lots of similarly-named objects and repetition of definitions, and frequent translation between the types depending on how you are using them. @tiangolo I would be interested if you have any suggestions for design patterns that would reduce the amount of \"translation\" code associated with having separate pydantic and sqlalchemy models.\r\n\r\nMore generally, I would be interested to hear if anyone has found a clean approach to bridging the gap between pydantic and a database, especially if it integrates nicely with an asynchronous database driver (I've been using ([encode/databases](https://github.com/encode/databases)), which only supports SQLAlchemy core,  not the ORM). In particular, it would be nice if I only had to create a single class for each conceptual model (I'd be okay with separate classes for pydantic and the orm as long as they could be derived from a common root).\r\n\r\nMy current approach has been to create a container class that holds references to the database table and the appropriate creation/in-db pydantic models (similar to UserCreate and UserInDB from the docs), and has a variety of generic classmethods for CRUD that make use of the creation/in-db types for input / return, but it still feels like a hack.\n\n---\n\nHi @dmontagu , \r\n\r\nI am interested in your 'hack' ðŸ˜„ Could you share some code sample ?\r\n\r\nOn my side, I find it useful to split the models used for frontend interaction (Pydantic) from those used for the DB interaction and business logic (SQLAlchemy).\r\n\r\nI have therefore followed the scaffold from https://github.com/tiangolo/full-stack-fastapi-postgresql, with some repetition between models and db_models. But again, I am fine with it since it adresses different purpose. The point where repetition becomes to cumbersome is the crud layer, where you basically have to copy-paste again and again the same pieces of code. I have made a PR to try to reduce this friction: https://github.com/tiangolo/full-stack-fastapi-postgresql/pull/23\r\n\r\nI am curious to see how this goes along with @dmontagu approach...\r\n\r\nBy the way, fastapi takes care to translate SQLAlchemy models to pydantic ones on the api endpoint layer, with two limitations I have found so far on JSON fields (see https://github.com/tiangolo/fastapi/issues/211 for details) and Enum fields in a specific use case (see https://github.com/tiangolo/fastapi/issues/196)\n\n---\n\nSo, Pydantic and SQLAlchemy are separated. Pydantic is used for documentation, validation, and data serialization. SQLAlchemy for SQL ORM stuff.\r\n\r\nFastAPI is not coupled with any DB, so, SQLAlchemy is optional.\r\n\r\nIf you don't care about having documentation, validation, and serialization, you don't need to use Pydantic, you could return SQLAlchemy models directly. They would be converted to JSON in a \"best-effort\" way.\r\n\r\nIf you want both, for now, you have to write both.\r\n\r\nI agree I don't like the duplication of properties in classes. But there's still no way to automatically generate one from the other.\r\n\r\nThat's a good candidate for a third-party package, that generates Pydantic models from SQLAlchemy models (or other ORMs) automatically. But it doesn't exist yet. There are some attempts at doing [something similar](https://github.com/awesometoolbox/ormantic) but I don't know a complete solution yet. Hopefully, someone will build it (or I'll do it later).\r\n\r\n---\r\n\r\nFor now, I'll take it as a request to update the docs clarifying the use of both Pydantic and SQLAlchemy at the same time.\n\n---\n\nIf you want another inspiration there's also https://github.com/thomaxxl/safrs\n\n---\n\nThanks @euri10 .", "source": "issue", "type": "qa_comprehensive", "issue_number": 36}
{"instruction": "Suggest middlwares for oauth2 against external providers\n\nDetails:\n### Is your feature request related to a problem\r\n\r\nIs your feature request related to a problem? Yes\r\n\r\nIt is unclear how to integrate an external oauth provider such as Microsoft, Google, Auth0 with FastAPI.\r\n\r\n### The solution you would like\r\n\r\nA section on the documentation describing how to achieve this, or which libraries do we recommend to do so.\r\n\r\nTwo examples include [the client from authlib](https://docs.authlib.org/en/stable/client/starlette.html) and [starlette-oauth2-api](https://pypi.org/project/starlette-oauth2-api/).\r\n\r\n### Describe alternatives you've considered\r\n\r\nPR an implementation to FastAPI. The reason I avoided this is because OAuth is not a thing of FastAPI only, but of a web app in general.\r\n\r\n### Additional context\r\n\r\nI am the author of starlette-oauth2-api, which we have been using to secure an API of ours against access tokens signed by external providers (multi-tenancy).", "input": "Repository: FastAPI\nLabels: ", "output": "I personally would welcome a docs PR, and I think the discussion at the end of https://github.com/tiangolo/fastapi/pull/797 may be relevant. I think @tiangolo might already be cooking up something along these lines.", "source": "issue", "type": "qa_best_answer", "issue_number": 35}
{"instruction": "Provide a comprehensive answer to this question: Suggest middlwares for oauth2 against external providers", "input": "### Is your feature request related to a problem\r\n\r\nIs your feature request related to a problem? Yes\r\n\r\nIt is unclear how to integrate an external oauth provider such as Microsoft, Google, Auth0 with FastAPI.\r\n\r\n### The solution you would like\r\n\r\nA section on the documentation describing how to achieve this, or which libraries do we recommend to do so.\r\n\r\nTwo examples include [the client from authlib](https://docs.authlib.org/en/stable/client/starlette.html) and [starlette-oauth2-api](https://pypi.org/project/starlette-oauth2-api/).\r\n\r\n### Describe alternatives you've considered\r\n\r\nPR an implementation to FastAPI. The reason I avoided this is because OAuth is not a thing of FastAPI only, but of a web app in general.\r\n\r\n### Additional context\r\n\r\nI am the author of starlette-oauth2-api, which we have been using to secure an API of ours against access tokens signed by external providers (multi-tenancy).", "output": "I personally would welcome a docs PR, and I think the discussion at the end of https://github.com/tiangolo/fastapi/pull/797 may be relevant. I think @tiangolo might already be cooking up something along these lines.\n\n---\n\nHi All,\r\n\r\nI would need it too ;-)\r\nI found a good doc for flask here:\r\nhttps://realpython.com/flask-google-login/\r\n\r\nBR,\r\nGeorge\n\n---\n\nHow to add google auth is explained in this article: \r\nhttps://medium.com/data-rebels/fastapi-google-as-an-external-authentication-provider-3a527672cf33\n\n---\n\nDid not know if this helps but I think this code should run for auth0 + FastAPI (actually I am not able to test it, but i will do asap). I merged the suggestion by auth0 from this site https://auth0.com/docs/quickstart/backend/python/01-authorization#validate-scopes with my implementation from FastAPI that just checks a list of valid tokens. \r\n\r\nFirst I define all authentication stuff in one python script. Please note that I am just enabled query authentication. \r\n```\r\n\"\"\" functions to connect token validation with auth0 \"\"\"\r\nimport os\r\nimport json\r\nfrom urllib.request import urlopen\r\n\r\nfrom jose import jwt\r\nfrom typing import Dict\r\nfrom fastapi.security.api_key import APIKeyQuery\r\nfrom fastapi import Security\r\n\r\nAUTH0_DOMAIN = os.environ['AUTH0_DOMAIN']\r\nAPI_AUDIENCE = os.environ['API_AUDIENCE']\r\nALGORITHMS = [\"RS256\"]\r\n\r\nAPI_KEY_NAME = \"access_token\"\r\napi_key_query = APIKeyQuery(name=API_KEY_NAME, auto_error=False)\r\n\r\n\r\nclass AuthError(Exception):\r\n    \"\"\" Error handling object \"\"\"\r\n    def __init__(self, error: Dict[str, str], status_code: int):\r\n        self.error = error\r\n        self.status_code = status_code\r\n\r\n\r\ndef auth0_token_authentication(\r\n    token: str = Security(api_key_query)\r\n):\r\n    \"\"\" authenticates token parsed via query with auth0 API \"\"\"\r\n    jsonurl = urlopen(\"https://\" + AUTH0_DOMAIN + \"/.well-known/jwks.json\")\r\n    jwks = json.loads(jsonurl.read())\r\n    unverified_header = jwt.get_unverified_header(token)\r\n    rsa_key = {}\r\n    for key in jwks[\"keys\"]:\r\n        if key[\"kid\"] == unverified_header[\"kid\"]:\r\n            rsa_key = {\r\n                \"kty\": key[\"kty\"],\r\n                \"kid\": key[\"kid\"],\r\n                \"use\": key[\"use\"],\r\n                \"n\": key[\"n\"],\r\n                \"e\": key[\"e\"]\r\n            }\r\n    if rsa_key:\r\n        try:\r\n            payload = jwt.decode(\r\n                token,\r\n                rsa_key,\r\n                algorithms=ALGORITHMS,\r\n                audience=API_AUDIENCE,\r\n                issuer=\"https://\" + AUTH0_DOMAIN + \"/\"\r\n            )\r\n        except jwt.ExpiredSignatureError:\r\n            raise AuthError({\"code\": \"token_expired\",\r\n                             \"description\": \"token is expired\"}, 401)\r\n        except jwt.JWTClaimsError:\r\n            raise AuthError({\"code\": \"invalid_claims\",\r\n                             \"description\":\r\n                                 \"incorrect claims,\"\r\n                                 \"please check the audience and issuer\"}, 401)\r\n        except Exception:\r\n            raise AuthError({\"code\": \"invalid_header\",\r\n                             \"description\":\r\n                                 \"Unable to parse authentication\"\r\n                                 \" token.\"}, 401)\r\n\r\n\r\n        return payload\r\n    raise AuthError({\"code\": \"invalid_header\",\r\n                     \"description\": \"Unable to find appropriate key\"}, 401)\r\n```\r\nIn your app you have to declare an exception handler and add the well known `Depends` hint with the authentication function : \r\n\r\n```\r\n@app.exception_handler(AuthError)\r\nasync def unicorn_exception_handler(request: Request, exc: AuthError):\r\n    return JSONResponse(\r\n        status_code=exc.status_code,\r\n        content=exc.error,\r\n    ) \r\n\r\n@app.get(\"/documentation\", tags=[\"documentation\"])\r\nasync def get_documentation(api_key: APIKey = Depends(auth0_token_authentication)):\r\n    response = get_swagger_ui_html(openapi_url=\"/openapi.json\", title=\"docs\")\r\n    response.set_cookie(\r\n        API_KEY_NAME,\r\n        value=api_key,\r\n        domain=COOKIE_DOMAIN,\r\n        httponly=True,\r\n        max_age=1800,\r\n        expires=1800,\r\n    )\r\n    return response\r\n``` \r\n\r\nI hope this can help you.\n\n---\n\n@meteoDaniel Thanks for your post! It helped me a lot. And I actually iterated through it a little, making a dependency injection version, and gone a little further. Implemented a couple of automated tests on it. Unfortunately I have not found a way of testing it without hitting Auth0 API. If anyone would have some solution for that I would be pleased.\r\n\r\nHere follows my code:\r\n\r\n```\r\nimport json\r\nfrom urllib.request import urlopen\r\nfrom jose import jwt\r\nfrom typing import Dict\r\nfrom fastapi import Security\r\nfrom fastapi.security import OAuth2AuthorizationCodeBearer\r\nfrom typing import List\r\n\r\n\r\nclass AuthError(Exception):\r\n    \"\"\" Error handling object \"\"\"\r\n    def __init__(self, error: Dict[str, str], status_code: int):\r\n        self.error = error\r\n        self.status_code = status_code\r\n\r\n\r\ndef get_jwks(auth0_domain: str):\r\n    json_url = urlopen(f\"https://{auth0_domain}/.well-known/jwks.json\")\r\n    return json.loads(json_url.read())\r\n\r\n\r\ndef auth0_token_authenticator_builder(\r\n        oauth2_scheme: OAuth2AuthorizationCodeBearer,\r\n        auth0_domain: str,\r\n        api_audience: str,\r\n        algorithms: List[str],\r\n        jwks: dict\r\n):\r\n    def auth0_token_authentication(\r\n        token: str = Security(oauth2_scheme)\r\n    ):\r\n        unverified_header = jwt.get_unverified_header(token)\r\n        rsa_key = {}\r\n        for key in jwks[\"keys\"]:\r\n            if key[\"kid\"] == unverified_header[\"kid\"]:\r\n                rsa_key = {\r\n                    \"kty\": key[\"kty\"],\r\n                    \"kid\": key[\"kid\"],\r\n                    \"use\": key[\"use\"],\r\n                    \"n\": key[\"n\"],\r\n                    \"e\": key[\"e\"]\r\n                }\r\n        if rsa_key:\r\n            try:\r\n                payload = jwt.decode(\r\n                    token,\r\n                    rsa_key,\r\n                    algorithms=algorithms,\r\n                    audience=api_audience,\r\n                    issuer=f\"https://{auth0_domain}/\"\r\n                )\r\n            except jwt.ExpiredSignatureError:\r\n                raise AuthError({\"code\": \"token_expired\",\r\n                                 \"description\": \"token is expired\"}, 401)\r\n            except jwt.JWTClaimsError:\r\n                raise AuthError({\"code\": \"invalid_claims\",\r\n                                 \"description\":\r\n                                     \"incorrect claims,\"\r\n                                     \"please check the audience and issuer\"}, 401)\r\n            except Exception:\r\n                raise AuthError({\"code\": \"invalid_header\",\r\n                                 \"description\":\r\n                                     \"Unable to parse authentication\"\r\n                                     \" token.\"}, 401)\r\n\r\n            return payload\r\n        raise AuthError({\"code\": \"invalid_header\",\r\n                         \"description\": \"Unable to find appropriate key\"}, 401)\r\n\r\n    return auth0_token_authentication\r\n\r\n\r\ndef scope_verifier_builder(oauth2_scheme: OAuth2AuthorizationCodeBearer, required_scope):\r\n    def scope_verifier(token: str = Security(oauth2_scheme)):\r\n        unverified_claims = jwt.get_unverified_claims(token)\r\n        if unverified_claims.get(\"scope\"):\r\n            token_scopes = unverified_claims[\"scope\"].split()\r\n            for token_scope in token_scopes:\r\n                if token_scope == required_scope:\r\n                    return True\r\n        raise AuthError({\r\n            \"code\": \"no_required_permissions\",\r\n            \"description\": \"user does not have the required permissions\"\r\n        }, 403)\r\n\r\n    return scope_verifier\r\n```\r\n\r\nhere follows the tests:\r\n\r\n```\r\nimport unittest\r\nfrom fastapi import FastAPI, Depends, status\r\nfrom fastapi.testclient import TestClient\r\nfrom fastapi.security import OAuth2AuthorizationCodeBearer\r\nfrom utils import authentication\r\n\r\n\r\nc", "source": "issue", "type": "qa_comprehensive", "issue_number": 35}
{"instruction": "Russian translation\n\nDetails:\n### ðŸ‡·ðŸ‡º Russian translation\r\n\r\nComrades from Russia need this :-)\r\nLet me know if you need a more precise plan for translating documentation into Russian. I created this issue to track and coordinate translation activities.\r\n\r\n_(in Soviet Russia documentation translates YOU)_", "input": "Repository: FastAPI\nLabels: ", "output": "See my review please https://github.com/tiangolo/fastapi/pull/1363#pullrequestreview-421383447", "source": "issue", "type": "qa_best_answer", "issue_number": 34}
{"instruction": "Provide a comprehensive answer to this question: Russian translation", "input": "### ðŸ‡·ðŸ‡º Russian translation\r\n\r\nComrades from Russia need this :-)\r\nLet me know if you need a more precise plan for translating documentation into Russian. I created this issue to track and coordinate translation activities.\r\n\r\n_(in Soviet Russia documentation translates YOU)_", "output": "See my review please https://github.com/tiangolo/fastapi/pull/1363#pullrequestreview-421383447\n\n---\n\nAwesome!\r\n\r\n> (in Soviet Russia documentation translates YOU)\r\n\r\nThis made me laugh :joy: \r\n\r\n---\r\n\r\nI just made a \"meta-issue\" with translations to pin that one and refer to each issue coordinating translations (including this one) from it.\n\n---\n\nHello, comrade @tiangolo !\r\nUnfortunately comrade @rezchikov hasn't been online for a month. I hope heâ€™s not in gulag ðŸ˜¢ \r\n\r\nI want to develop Russian translation, how is it better to do this? Create a new pull request?\n\n---\n\nHey @fojetin !\r\n\r\nI just added and merged a small PR with the basic setup for Russian translations. :heavy_check_mark: \r\n\r\nThat way you (and anyone else that wants to help) can take one page and start right away.\r\n\r\nThe `index.md` is still not translated, I guess we can wait a bit for @rezchikov's PR.\r\n\r\nBut having the basic setup should allow you to take any other page and translate it :rocket: \r\n\r\nThanks for the help! :bow:  :tada:\n\n---\n\n@tiangolo I made my review for @rezchikov PR and want to contribute for FastAPI too, starting with translation as boost start for now :) \r\n@fojetin we can split documentation for now so we won't translate same things simultaneously", "source": "issue", "type": "qa_comprehensive", "issue_number": 34}
{"instruction": "FastApi & MongoDB - the full guide\n\nDetails:\n### Description\r\n\r\nIn this issue i'd like to gather all the information about the use of MongoDB, FastApi and Pydantic. At this point this is a \"rather complete\" solution, but i'd like to gather feedback and comments from the community to se how it can be improved.\r\n\r\nThe biggest pain point that started this and several other threads when trying to use FastAPI with mongo is the `_id` field. There are several issues here:\r\n1. Most known one - `_id` field being `ObjectId`, which is not very JSON-friendly\r\n2. `_id` field by it's naming is not very python-friendly (that is, written as is in Pydantic model, it would become a private field - many IDEs will point that)\r\n\r\nBelow i'll try to describe solutions i've found in different places and see what cases do the cover and what's left unsolved.\r\n\r\nLet's say, we have some Joe, who's a regular developer. Joe just discovered FastAPI and is familiar with mongo (to the extend that he can create and fetch documents from DB). Joe wants to build clean and fast api that would:\r\n\r\n1ï¸âƒ£ Be able to define mongo-compatible documents as regular Pydantic models (with all the proper validations in place):\r\n```python\r\nclass User(BaseModel):\r\n    id: ObjectId = Field(description=\"User id\")\r\n    name: str = Field()\r\n```\r\n2ï¸âƒ£ Write routes that would use native Pydantic models as usual:\r\n ```python\r\n@app.post('/me', response_model=User)\r\ndef save_me(body: User):\r\n    ...\r\n```\r\n3ï¸âƒ£ Have api to return json like `{\"id\": \"5ed8b7eaccda20c1d4e95bb0\", \"name\": \"Joe\"}` (it's quite expected in the \"outer world\" to have `id` field for the document rather than `_id`. And it just looks nicer.)\r\n4ï¸âƒ£ Have Swagger and ReDoc documentation to display fields `id` (str), `name` (str)\r\n5ï¸âƒ£ Be able to save Pydantic documents into Mongo with proper `id` field substitution:\r\n```python\r\nuser = User(id=ObjectId(), name='Joe')\r\ninserted = db.user.insert_one(user) # This should insert document as `{\"_id\": user.id, \"name\": \"Joe\"}`\r\nassert inserted.inserted_id == user.id\r\n", "input": "Repository: FastAPI\nLabels: ", "output": "Firstly, nice work! As you said, this is a fully working solution to using MongoDB with FastAPI that I'm sure will benefit people going forward.\r\n\r\nI would highly recommend that if this is to become the \"recommended\" way of working with MongoDB that we recommend an ODM (object-document-mapper) and show any potential issues with using those with Pydantic/FastAPI. The main reasons are:\r\n\r\n1. It would fall more in line with most of the examples in the docs (e.g. SQLAlchemy). Most FastAPI examples with response models show returning ORM-like objects. An ODM is the natural translation for Mongo.\r\n2. It resolves the 3 sub-optimal points you mentioned above.\r\n3. It encourages using objects instead of dicts for all code- which allows type annotations and editor completion.\r\n\r\nThe existing ODMs are not great. I don't think any of the major ones include type annotations or bulk write support. But they are fairly lightweight and get us most of the way there, and allow you to reach down into raw Mongo queries when you need to. I think if we're going to put some development effort into making Mongo easier to use with Pydantic/FastAPI, it would be best spent writing docs that are as accessible as possible and maybe contributing to existing ODMs to clear up any sticking points.\r\n\r\nObviously ODMs can be a contentious topic, but so can ORMs and FastAPI does not shy away from showing them as the easier way to get started. I think in an ideal world, we'd include the more straight forward \"here's an ODM, point and click\" approach first and the more advanced \"DIY\" approach after for people who want to wander into the deep end.", "source": "issue", "type": "qa_best_answer", "issue_number": 33}
{"instruction": "Provide a comprehensive answer to this question: FastApi & MongoDB - the full guide", "input": "### Description\r\n\r\nIn this issue i'd like to gather all the information about the use of MongoDB, FastApi and Pydantic. At this point this is a \"rather complete\" solution, but i'd like to gather feedback and comments from the community to se how it can be improved.\r\n\r\nThe biggest pain point that started this and several other threads when trying to use FastAPI with mongo is the `_id` field. There are several issues here:\r\n1. Most known one - `_id` field being `ObjectId`, which is not very JSON-friendly\r\n2. `_id` field by it's naming is not very python-friendly (that is, written as is in Pydantic model, it would become a private field - many IDEs will point that)\r\n\r\nBelow i'll try to describe solutions i've found in different places and see what cases do the cover and what's left unsolved.\r\n\r\nLet's say, we have some Joe, who's a regular developer. Joe just discovered FastAPI and is familiar with mongo (to the extend that he can create and fetch documents from DB). Joe wants to build clean and fast api that would:\r\n\r\n1ï¸âƒ£ Be able to define mongo-compatible documents as regular Pydantic models (with all the proper validations in place):\r\n```python\r\nclass User(BaseModel):\r\n    id: ObjectId = Field(description=\"User id\")\r\n    name: str = Field()\r\n```\r\n2ï¸âƒ£ Write routes that would use native Pydantic models as usual:\r\n ```python\r\n@app.post('/me', response_model=User)\r\ndef save_me(body: User):\r\n    ...\r\n```\r\n3ï¸âƒ£ Have api to return json like `{\"id\": \"5ed8b7eaccda20c1d4e95bb0\", \"name\": \"Joe\"}` (it's quite expected in the \"outer world\" to have `id` field for the document rather than `_id`. And it just looks nicer.)\r\n4ï¸âƒ£ Have Swagger and ReDoc documentation to display fields `id` (str), `name` (str)\r\n5ï¸âƒ£ Be able to save Pydantic documents into Mongo with proper `id` field substitution:\r\n```python\r\nuser = User(id=ObjectId(), name='Joe')\r\ninserted = db.user.insert_one(user) # This should insert document as `{\"_id\": user.id, \"name\": \"Joe\"}`\r\nassert inserted.inserted_id == user.id\r\n", "output": "Firstly, nice work! As you said, this is a fully working solution to using MongoDB with FastAPI that I'm sure will benefit people going forward.\r\n\r\nI would highly recommend that if this is to become the \"recommended\" way of working with MongoDB that we recommend an ODM (object-document-mapper) and show any potential issues with using those with Pydantic/FastAPI. The main reasons are:\r\n\r\n1. It would fall more in line with most of the examples in the docs (e.g. SQLAlchemy). Most FastAPI examples with response models show returning ORM-like objects. An ODM is the natural translation for Mongo.\r\n2. It resolves the 3 sub-optimal points you mentioned above.\r\n3. It encourages using objects instead of dicts for all code- which allows type annotations and editor completion.\r\n\r\nThe existing ODMs are not great. I don't think any of the major ones include type annotations or bulk write support. But they are fairly lightweight and get us most of the way there, and allow you to reach down into raw Mongo queries when you need to. I think if we're going to put some development effort into making Mongo easier to use with Pydantic/FastAPI, it would be best spent writing docs that are as accessible as possible and maybe contributing to existing ODMs to clear up any sticking points.\r\n\r\nObviously ODMs can be a contentious topic, but so can ORMs and FastAPI does not shy away from showing them as the easier way to get started. I think in an ideal world, we'd include the more straight forward \"here's an ODM, point and click\" approach first and the more advanced \"DIY\" approach after for people who want to wander into the deep end.\n\n---\n\nCorrect me if I'm wrong but isn't the real key missing part for all of this the serializers/deserializers/validators for all the Mongo/Bson datatypes in Pydantic. If Pydantic added support for all the extra datatypes then you could just return a MongoEngine instance directly no?\n\n---\n\nInterested to know how people are handling creation of indexes in mongo db . Does anyone know of suitable way to define index on a Pydantic model?\n\n---\n\nHere Comes!\r\n\r\nI gived up the json_encoder in the fastapi, and developed a more handy one, specialized for mongodb.\r\n\r\nKeep in mind that if you has one _id field in the document, the mongodb won't generate one ObjectID.\r\n\r\nSo it's better that we always generate our own _id.\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\n# -----------------------------------\r\n# @CreateTime   : 2020/7/25 0:27\r\n# @Author       : Mark Shawn\r\n# @Email        : shawninjuly@gmail.com\r\n# ------------------------------------\r\n\r\nimport json\r\nfrom datetime import datetime, date\r\nfrom uuid import UUID\r\nfrom bson import ObjectId\r\nfrom pydantic import BaseModel\r\n\r\n\r\ndef mongo_json_encoder(record: [dict, list, BaseModel]):\r\n    \"\"\"\r\n    This is a json_encoder designed specially for dump mongodb records.\r\n\r\n    It can deal with both record_item and record_list type queried from mongodb.\r\n\r\n    You can extend the encoder ability in the recursive function `convert_type`.\r\n\r\n    I just covered the following datatype: datetime, date, UUID, ObjectID.\r\n\r\n    Contact me if any further support needs.\r\n\r\n    Attention: it will change the raw record, so copy it before operating this function if necessary.\r\n\r\n    Parameters\r\n    ----------\r\n    **record**: a dict or a list, like the queried documents from mongodb.\r\n\r\n    Returns\r\n    -------\r\n    json formatted data.\r\n    \"\"\"\r\n\r\n    def convert_type(data):\r\n        if isinstance(data, (datetime, date)):\r\n            # ISO format: data.isoformat()\r\n            return str(data)\r\n        elif isinstance(data, (UUID, ObjectId)):\r\n            return str(data)\r\n        elif isinstance(data, list):\r\n            return list(map(convert_type, data))\r\n        elif isinstance(data, dict):\r\n            return mongo_json_encoder(data)\r\n        try:\r\n            json.dumps(data)\r\n            return data\r\n        except TypeError:\r\n            raise TypeError({\r\n                \"error_msg\": \"æš‚ä¸æ”¯æŒæ­¤ç±»åž‹åºåˆ—åŒ–\",\r\n                \"key\": key,\r\n                \"value\": value,\r\n                \"type\": type(value)\r\n            })\r\n\r\n    # add support for BaseModel\r\n    if isinstance(record, BaseModel):\r\n        return mongo_json_encoder(record.dict(by_alias=True))\r\n    elif isinstance(record, dict):\r\n        for key, value in record.items():\r\n            record[key] = convert_type(value)\r\n        return record\r\n    else:\r\n        return list(map(mongo_json_encoder, record))\r\n\r\n\r\ndef mongo_json_encoder_decorator(func):\r\n    \"\"\"\r\n    this is a decorator for converting the queried documents from mongodb\r\n    \r\n    Parameters\r\n    ----------\r\n    func\r\n\r\n    Returns\r\n    -------\r\n\r\n    \"\"\"\r\n    def wrapper(*args, **kwargs):\r\n        res = func(*args, **kwargs)\r\n        return mongo_json_encoder(res)\r\n    return wrapper\r\n```\r\n\r\n\r\nand the test script is passed as the following:\r\n```python\r\n# -*- coding: utf-8 -*-\r\n# -----------------------------------\r\n# @CreateTime   : 2020/7/25 0:47\r\n# @Author       : Mark Shawn\r\n# @Email        : shawninjuly@gmail.com\r\n# ------------------------------------\r\n\r\nimport uuid\r\nfrom uuid import UUID\r\nfrom bson import ObjectId\r\nfrom typing import  List, Union\r\nfrom pydantic import BaseModel, Field\r\nfrom utils.json import mongo_json_encoder\r\n\r\n\r\nclass FriendBase(BaseModel):\r\n    class Config:\r\n        arbitrary_types_allowed = True\r\n        allow_population_by_field_name = True\r\n\r\n    id: Union[str, UUID, ObjectId] = Field(alias='_id')\r\n    name: str\r\n\r\n\r\nclass Friend(FriendBase):\r\n    friends: List[FriendBase] = []\r\n\r\n\r\nf_1 = Friend(id='test', name='test')\r\nf_2 = Friend(id=uuid.uuid1(), name='test', friends=[f_1])\r\nf_3 = Friend(id=ObjectId(), name='test', friends=[f_1, f_2])\r\n\r\ni_1 = f_1.dict(by_alias=True)\r\ni_2 = f_2.dict(by_alias=True)\r\ni_3 = f_3.dict(by_alias=True)\r\n\r\nj_1 = mongo_json_encoder(i_1.copy())\r\nj_2 = mongo_json_encoder(i_2.copy())\r\nj_3 = mongo_json_encoder(i_3.copy())\r\nj_all = [f_1, f_2, f_3]\r\n\r\nassert i_1 == j_1\r\nassert i_2 == j_2, \"this should not pass\"\r\nassert i_3 == j_3, \"this should not pass\"\r\n```\r\n\r\nIt just runs well!\n\n---\n\nI hope @tiangolo would adapt FastAPI to have less boilerplate code when using MongoDB.. This would be fantastic.", "source": "issue", "type": "qa_comprehensive", "issue_number": 33}
{"instruction": "How to do flexibly use nested pydantic models for sqlalchemy ORM\n\nDetails:\n### First check\r\n\r\n* [x ] I added a very descriptive title to this issue.\r\n* [ x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [ x] I searched the FastAPI documentation, with the integrated search.\r\n* [x ] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [ x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [ x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, HTTPException, Body, Request\r\nfrom sqlalchemy import create_engine, Boolean, Column, ForeignKey, Integer, String\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchem", "input": "Repository: FastAPI\nLabels: ", "output": "Have you tried @tiangolo's [Pydantic SQLAlchemy](https://github.com/tiangolo/pydantic-sqlalchemy) ?", "source": "issue", "type": "qa_best_answer", "issue_number": 32}
{"instruction": "Provide a comprehensive answer to this question: How to do flexibly use nested pydantic models for sqlalchemy ORM", "input": "### First check\r\n\r\n* [x ] I added a very descriptive title to this issue.\r\n* [ x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [ x] I searched the FastAPI documentation, with the integrated search.\r\n* [x ] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [ x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [ x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, HTTPException, Body, Request\r\nfrom sqlalchemy import create_engine, Boolean, Column, ForeignKey, Integer, String\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchem", "output": "Have you tried @tiangolo's [Pydantic SQLAlchemy](https://github.com/tiangolo/pydantic-sqlalchemy) ?\n\n---\n\nThank you for the contribution, but your proposal is for converting sqlalchemy model to pydantic, I need a way to convert a nested model from pydantic to sqlalchemy.\n\n---\n\nI am thinking about a recursive function to do what I want. I currently need an external \"maping\" dict that translates the pydantic sub class to the related sqlalchemy class by their name. Would be helpful if someone could provide an example of a recursive function for two dicts. Added difficulty that sub model could be lists or direct keys.\n\n---\n\n@j-gimbel  I'll play with this more but this is what I came up with.\r\n\r\n```python\r\n# Too lazy to delete unused imports :( \r\nfrom typing import Optional, Union, List, Dict, Any, Mapping, Type, TypeVar, Generic\r\n\r\n\r\ndef pydantic_to_sqlalchemy(schema: pydantic.main.ModelMetaclass) -> Any:\r\n    __fields_dict__ = {}\r\n\r\n    def recurse(obj: pydantic.main.ModelMetaclass, temp_key: str = \"\") -> None:\r\n        if isinstance(obj, pydantic.main.ModelMetaclass):\r\n            for key, value in obj.schema().items():\r\n                recurse(obj=value, temp_key=temp_key + key if temp_key else key)\r\n\r\n        if isinstance(obj, dict):\r\n            for key, value in obj.items():\r\n                recurse(obj=value, temp_key=temp_key + key if temp_key else key)\r\n\r\n        if isinstance(obj, list):\r\n            for item in range(len(obj)):\r\n                recurse(\r\n                    obj=obj[item],\r\n                    temp_key=temp_key + str(item) if temp_key else str(item),\r\n                )\r\n        else:\r\n            __fields_dict__[temp_key] = obj\r\n\r\n    recurse(schema)\r\n    return __fields_dict__\r\n```\r\n\r\nNot sure how this would be helpful to you, maybe just for inspiration. But I'll keep playing with this.\r\n\r\n\r\n```python\r\nOut: {'': <class '__main__.SchemaRoot'>,\r\n 'definitions': {'SchemaSubBase': {'properties': {'someSubText': {'title': 'Somesubtext',\r\n                                                                  'type': 'string'}},\r\n                                   'required': ['someSubText'],\r\n                                   'title': 'SchemaSubBase',\r\n                                   'type': 'object'}},\r\n 'definitionsSchemaSubBase': {'properties': {'someSubText': {'title': 'Somesubtext',\r\n                                                             'type': 'string'}},\r\n                              'required': ['someSubText'],\r\n                              'title': 'SchemaSubBase',\r\n                              'type': 'object'},\r\n 'definitionsSchemaSubBaseproperties': {'someSubText': {'title': 'Somesubtext',\r\n                                                        'type': 'string'}},\r\n 'definitionsSchemaSubBasepropertiessomeSubText': {'title': 'Somesubtext',\r\n                                                   'type': 'string'},\r\n 'definitionsSchemaSubBasepropertiessomeSubTexttitle': 'Somesubtext',\r\n 'definitionsSchemaSubBasepropertiessomeSubTexttype': 'string',\r\n 'definitionsSchemaSubBaserequired0': 'someSubText',\r\n 'definitionsSchemaSubBasetitle': 'SchemaSubBase',\r\n 'definitionsSchemaSubBasetype': 'object',\r\n 'properties': {'id': {'title': 'Id', 'type': 'integer'},\r\n                'someRootText': {'title': 'Someroottext', 'type': 'string'},\r\n                'subData': {'default': [],\r\n                            'items': {'$ref': '#/definitions/SchemaSubBase'},\r\n                            'title': 'Subdata',\r\n                            'type': 'array'}},\r\n 'propertiesid': {'title': 'Id', 'type': 'integer'},\r\n 'propertiesidtitle': 'Id',\r\n 'propertiesidtype': 'integer',\r\n 'propertiessomeRootText': {'title': 'Someroottext', 'type': 'string'},\r\n 'propertiessomeRootTexttitle': 'Someroottext',\r\n 'propertiessomeRootTexttype': 'string',\r\n 'propertiessubData': {'default': [],\r\n                       'items': {'$ref': '#/definitions/SchemaSubBase'},\r\n                       'title': 'Subdata',\r\n                       'type': 'array'},\r\n 'propertiessubDataitems': {'$ref': '#/definitions/SchemaSubBase'},\r\n 'propertiessubDataitems$ref': '#/definitions/SchemaSubBase',\r\n 'propertiessubDatatitle': 'Subdata',\r\n 'propertiessubDatatype': 'array',\r\n 'required0': 'someRootText',\r\n 'required1': 'id',\r\n 'title': 'SchemaRoot',\r\n 'type': 'object'}\r\n```\n\n---\n\nTortoise has some stuff with pydantic conversion. \r\nLink: https://tortoise-orm.readthedocs.io/en/latest/examples/pydantic.html\r\nMay be helpful.", "source": "issue", "type": "qa_comprehensive", "issue_number": 32}
{"instruction": "No objects ever released by the GC, potential memory leak?\n\nDetails:\n### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\n# From the official documentation\r\n# Run with uvicorn main:app --reload\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nUse the minimal example provided in the documentation, call the API 1M times. You will see that the memory usage piles up and up but never goes down. The GC can't free any objects. It's very noticeable once you have a real use case like a file upload that DoS'es your service.\r\n\r\n\r\n![memory-profile](https://user-images.githubusercontent.com/4538351/156794820-5bad7c00-6e02-4e27-bac3-ab488baa0df4.png)\r\n\r\nHere some examples from a real service in k8s via lens metrics:\r\n\r\n<img width=\"677\" alt=\"Screenshot 2022-03-04 at 16 47 18\" src=\"https://user-images.githubusercontent.com/4538351/156794991-abe94e21-57f4-4d96-a347-35a96e72c0d3.png\">\r\n\r\n<img width=\"681\" alt=\"Screenshot 2022-03-03 at 20 19 22\" src=\"https://user-images.githubusercontent.com/4538351/156795013-0a9792c3-8948-4d62-93af-31c41626f1eb.png\">\n\n### Operating System\n\nLinux, macOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\n0.74.1\n\n### Python Version\n\nPy", "input": "Repository: FastAPI\nLabels: ", "output": "Are you using `--reload` as part of your entrypoint like the comment at the top of the code block indicates? What limits if any are you running with in Kube? Those graphs don't look like leaks, they look like constant memory usage to me so my interpretation of what might be happening is that upon application instance initialization some objects are being loaded into memory and those are never being released for whatever reason, likely they're being used by the application itself. These could be connections of various sorts, some data that is getting served, hard to say without seeing the actual production service. Memory leaks usually look like a somewhat constant increase in memory usage until a threshold is breached and then the service is OOM'd.", "source": "issue", "type": "qa_best_answer", "issue_number": 31}
{"instruction": "Provide a comprehensive answer to this question: No objects ever released by the GC, potential memory leak?", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\n# From the official documentation\r\n# Run with uvicorn main:app --reload\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nUse the minimal example provided in the documentation, call the API 1M times. You will see that the memory usage piles up and up but never goes down. The GC can't free any objects. It's very noticeable once you have a real use case like a file upload that DoS'es your service.\r\n\r\n\r\n![memory-profile](https://user-images.githubusercontent.com/4538351/156794820-5bad7c00-6e02-4e27-bac3-ab488baa0df4.png)\r\n\r\nHere some examples from a real service in k8s via lens metrics:\r\n\r\n<img width=\"677\" alt=\"Screenshot 2022-03-04 at 16 47 18\" src=\"https://user-images.githubusercontent.com/4538351/156794991-abe94e21-57f4-4d96-a347-35a96e72c0d3.png\">\r\n\r\n<img width=\"681\" alt=\"Screenshot 2022-03-03 at 20 19 22\" src=\"https://user-images.githubusercontent.com/4538351/156795013-0a9792c3-8948-4d62-93af-31c41626f1eb.png\">\n\n### Operating System\n\nLinux, macOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\n0.74.1\n\n### Python Version\n\nPy", "output": "Are you using `--reload` as part of your entrypoint like the comment at the top of the code block indicates? What limits if any are you running with in Kube? Those graphs don't look like leaks, they look like constant memory usage to me so my interpretation of what might be happening is that upon application instance initialization some objects are being loaded into memory and those are never being released for whatever reason, likely they're being used by the application itself. These could be connections of various sorts, some data that is getting served, hard to say without seeing the actual production service. Memory leaks usually look like a somewhat constant increase in memory usage until a threshold is breached and then the service is OOM'd.\n\n---\n\nWhat uvicorn version are you using?\r\n\r\nDo you have a health check that sends an TCP ping?\r\n\r\nIf answers above are: \"not the latest\" and \"yes\", then bump uvicorn to the latest one.\n\n---\n\nIs the application running in the docker container? In the container, python recognizes the memory and CPUs of the host, not the resources limited of the container, which may cause the GC not to be actually executed.\r\n\r\nSimilar problems have occurred in my application before. I solved them with reference to this issue: https://github.com/tiangolo/fastapi/issues/596#issuecomment-635184641\n\n---\n\nI have solved this issue with following settings:\r\n\r\n- python=3.8.9\r\n- fastapi=0.63.0\r\n- uvicorn=0.17.6\r\n- uvloop=0.16.0\n\n---\n\nI have no such problem on windows x64\r\n- python ~= 3.9.0\r\n- fastapi ~= 0.75.0\r\n- uvicorn ~= 0.17.0\r\n![image](https://user-images.githubusercontent.com/37829370/158726023-32a98989-f866-4287-a623-459f8daf1f07.png)", "source": "issue", "type": "qa_comprehensive", "issue_number": 31}
{"instruction": "Debug and solve this technical issue: No objects ever released by the GC, potential memory leak?", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\n# From the official documentation\r\n# Run with uvicorn main:app --reload\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nUse the minimal example provided in the documentation, call the API 1M times. You will see that the memory usage piles up and up but never goes down. The GC can't free any objects. It's very noticeable once you have a real use case like a file upload that DoS'es your service.\r\n\r\n\r\n![memory-profile](https://user-images.githubusercontent.com/4538351/156794820-5bad7c00-6e02-4e27-bac3-ab488baa0df4.png)\r\n\r\nHere some examples from a real service in k8s via lens metrics:\r\n\r\n<img width=\"677\" alt=\"Screenshot 2022-03-04 at 16 47 18\" src=\"https://user-images.githubusercontent.com/4538351/156794991-abe94e21-57f4-4d96-a347-35a96e72c0d3.png\">\r\n\r\n<img width=\"681\" alt=\"Screenshot 2022-03-03 at 20 19 22\" src=\"https://user-images.githubusercontent.com/4538351/156795013-0a9792c3-8948-4d62-93af-31c41626f1eb.png\">\n\n### Operating System\n\nLinux, macOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\n0.74.1\n\n### Python Version\n\nPython 3.10.1\n\n### Additional Context\n\n_No response_", "output": "Are you using `--reload` as part of your entrypoint like the comment at the top of the code block indicates? What limits if any are you running with in Kube? Those graphs don't look like leaks, they look like constant memory usage to me so my interpretation of what might be happening is that upon application instance initialization some objects are being loaded into memory and those are never being released for whatever reason, likely they're being used by the application itself. These could be connections of various sorts, some data that is getting served, hard to say without seeing the actual production service. Memory leaks usually look like a somewhat constant increase in memory usage until a threshold is breached and then the service is OOM'd.", "source": "issue", "type": "qa_technical", "issue_number": 31}
{"instruction": "Problems with await in async dependencies (when using dependencies and middleware simultaneously)\n\nDetails:\n### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport fastapi\r\nimport datetime as dt\r\nimport sqlalchemy as sa\r\n\r\nfrom sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession\r\nfrom sqlalchemy.ext.asyncio import create_async_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\n\r\n\r\nclass _Conn:\r\n    radius_engine: AsyncEngine\r\n    radius_session_maker: sessionmaker\r\n\r\n\r\ndef init_pg_connections() -> None:\r\n    _Conn.radius_engine = create_async_engine(\r\n        'postgresql+asyncpg://postgres:password@host:port/db_name',\r\n        connect_args={\r\n            'server_settings': {\r\n                'application_name': 'test_app'\r\n            }\r\n        },\r\n        pool_size=2, max_overflow=10\r\n    )\r\n    _Conn.radius_session_maker = sessionmaker(\r\n        bind=_Conn.radius_engine,\r\n        autoflush=False, autocommit=False,\r\n        expire_on_commit=False,\r\n        class_=AsyncSession\r\n    )\r\n\r\n\r\nasync def get_db():\r\n    db: AsyncSession = _Conn.radius_session_maker()\r\n    try:\r\n        yield db\r\n    finally:\r\n        print('finally get_db. Before close')\r\n        await db.close()\r\n        print('finally get_db. After close')\r\n\r\n\r\ndef get_app():\r\n    app = fastapi.FastAPI(\r\n        on_startup=[init_", "input": "Repository: FastAPI\nLabels: ", "output": "Yes, having the same problem with `get_db` dependency not closing connection and the same error message. And it started with 0.74 release https://github.com/tiangolo/fastapi/releases/tag/0.74.0\r\n\r\n```python\r\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\n\r\nfrom app.config import settings\r\n\r\n\r\nengine = create_async_engine(\r\n    settings.DB_DSN,\r\n    echo=settings.DB_ECHO,\r\n    pool_size=settings.DB_POOL_SIZE,\r\n    max_overflow=settings.DB_MAX_OVERFLOW,\r\n    future=True,\r\n)\r\nasync_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession, future=True, autoflush=False)\r\n\r\n\r\nasync def get_db():\r\n    db = async_session()\r\n    try:\r\n        yield db\r\n    finally:\r\n        await db.close()\r\n```\r\n\r\nAnd I have middlewares also", "source": "issue", "type": "qa_best_answer", "issue_number": 30}
{"instruction": "Provide a comprehensive answer to this question: Problems with await in async dependencies (when using dependencies and middleware simultaneously)", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport fastapi\r\nimport datetime as dt\r\nimport sqlalchemy as sa\r\n\r\nfrom sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession\r\nfrom sqlalchemy.ext.asyncio import create_async_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\n\r\n\r\nclass _Conn:\r\n    radius_engine: AsyncEngine\r\n    radius_session_maker: sessionmaker\r\n\r\n\r\ndef init_pg_connections() -> None:\r\n    _Conn.radius_engine = create_async_engine(\r\n        'postgresql+asyncpg://postgres:password@host:port/db_name',\r\n        connect_args={\r\n            'server_settings': {\r\n                'application_name': 'test_app'\r\n            }\r\n        },\r\n        pool_size=2, max_overflow=10\r\n    )\r\n    _Conn.radius_session_maker = sessionmaker(\r\n        bind=_Conn.radius_engine,\r\n        autoflush=False, autocommit=False,\r\n        expire_on_commit=False,\r\n        class_=AsyncSession\r\n    )\r\n\r\n\r\nasync def get_db():\r\n    db: AsyncSession = _Conn.radius_session_maker()\r\n    try:\r\n        yield db\r\n    finally:\r\n        print('finally get_db. Before close')\r\n        await db.close()\r\n        print('finally get_db. After close')\r\n\r\n\r\ndef get_app():\r\n    app = fastapi.FastAPI(\r\n        on_startup=[init_", "output": "Yes, having the same problem with `get_db` dependency not closing connection and the same error message. And it started with 0.74 release https://github.com/tiangolo/fastapi/releases/tag/0.74.0\r\n\r\n```python\r\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\n\r\nfrom app.config import settings\r\n\r\n\r\nengine = create_async_engine(\r\n    settings.DB_DSN,\r\n    echo=settings.DB_ECHO,\r\n    pool_size=settings.DB_POOL_SIZE,\r\n    max_overflow=settings.DB_MAX_OVERFLOW,\r\n    future=True,\r\n)\r\nasync_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession, future=True, autoflush=False)\r\n\r\n\r\nasync def get_db():\r\n    db = async_session()\r\n    try:\r\n        yield db\r\n    finally:\r\n        await db.close()\r\n```\r\n\r\nAnd I have middlewares also\n\n---\n\nSame here with `async_session` used inside a context manager, pinning fastapi to `0.73.0` fixes it. Using `asyncmy` as driver.\r\n\r\n```python\r\nasync def get_db_session(request: Request) -> AsyncGenerator[AsyncSession, None]:\r\n    async_sessionmaker = request.app.state.sessionmaker\r\n    session: AsyncSession\r\n    async with async_sessionmaker() as session:\r\n        try:\r\n            yield session\r\n        except SQLAlchemyError:\r\n            await shield(session.rollback())\r\n            logger = get_logger()\r\n            logger.exception(\"sqlalchemy_exception\")\r\n```\n\n---\n\nHave similar bug when update from 0.73.2 to 0.75.2.\r\n\r\nI have async connection to postgres DB and connection started to pile up until I reach DB max client limit.\r\n\r\nThis is screenshot from pgAdmin, from Dashboard and statistic tabs, as you can see connection stuck at ROLLBACK\r\n![image](https://user-images.githubusercontent.com/4011523/164030558-c9ec1899-2658-4f48-937c-c9a1cc976481.png)\r\n\r\nMy code for Dependency:\r\n```py\r\n# imports...\r\n\r\nengine = create_async_engine(DATABASE_URL, echo=DEBUG, future=True)\r\n\r\n# ....\r\n\r\nasync def get_session() -> AsyncGenerator[AsyncSession, None]:\r\n    async_session = sessionmaker(\r\n        engine,\r\n        class_=AsyncSession,  # type: ignore\r\n        expire_on_commit=False,\r\n    )\r\n\r\n    async with async_session() as session:\r\n        yield session\r\n        await session.close()\r\n```\r\n\r\nThen in code I use it like:\r\n```py\r\n@router.get(\"/count\", response_model=UserCount)\r\nasync def counts_users(session: AsyncSession = Depends(get_session), current_user: User = Depends(get_current_user)) -> UserCount:\r\n    # code ...\r\n    # in CRUD:\r\n    query = await session.execute(...)\r\n    return UserCount(users=query.scalar_one())\r\n```\n\n---\n\n> This is screenshot from pgAdmin, from Dashboard and statistic tabs, as you can see connection stuck at ROLLBACK\r\n\r\nSame problem here with `0.74.1`, but I don't think the connections are really stuck at ROLLBACK: they are idle and ROLLBACK is just the last query that was (successfully) executed. As reported above, `0.73.0` seems fine.\n\n---\n\nIt seems that the problem has to do with `Depends`. If I don't use FastAPI's dependency injection mechanism and create a session myself inside the router function, my problem is gone:\r\n```\r\nasync def foo_list(\r\n    # *,\r\n    # session: AsyncSession = Depends(get_session),\r\n):\r\n    async with Session() as session:\r\n        # Now it works\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 30}
{"instruction": "Debug and solve this technical issue: Problems with await in async dependencies (when using dependencies and middleware simultaneously)", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport fastapi\r\nimport datetime as dt\r\nimport sqlalchemy as sa\r\n\r\nfrom sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession\r\nfrom sqlalchemy.ext.asyncio import create_async_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\n\r\n\r\nclass _Conn:\r\n    radius_engine: AsyncEngine\r\n    radius_session_maker: sessionmaker\r\n\r\n\r\ndef init_pg_connections() -> None:\r\n    _Conn.radius_engine = create_async_engine(\r\n        'postgresql+asyncpg://postgres:password@host:port/db_name',\r\n        connect_args={\r\n            'server_settings': {\r\n                'application_name': 'test_app'\r\n            }\r\n        },\r\n        pool_size=2, max_overflow=10\r\n    )\r\n    _Conn.radius_session_maker = sessionmaker(\r\n        bind=_Conn.radius_engine,\r\n        autoflush=False, autocommit=False,\r\n        expire_on_commit=False,\r\n        class_=AsyncSession\r\n    )\r\n\r\n\r\nasync def get_db():\r\n    db: AsyncSession = _Conn.radius_session_maker()\r\n    try:\r\n        yield db\r\n    finally:\r\n        print('finally get_db. Before close')\r\n        await db.close()\r\n        print('finally get_db. After close')\r\n\r\n\r\ndef get_app():\r\n    app = fastapi.FastAPI(\r\n        on_startup=[init_pg_connections]\r\n    )\r\n\r\n    @app.middleware('http')\r\n    async def add_process_time_header(request: fastapi.Request, call_next):\r\n        start_time = dt.datetime.now()\r\n        response = await call_next(request)\r\n        process_time = (dt.datetime.now() - start_time).total_seconds()\r\n        response.headers[\"X-Process-Time\"] = str(process_time)\r\n        return response\r\n\r\n    @app.post('/test')\r\n    async def test(\r\n            data: int = fastapi.Body(5, embed=True),\r\n            db: AsyncSession = fastapi.Depends(get_db)\r\n    ):\r\n        res = (await db.execute(sa.text('Select * FROM radacct'))).scalars().all()\r\n        print('test', f'{data=} {res=}')\r\n        return 'OK'\r\n    return app\r\n\r\n\r\nif __name__ == '__main__':\r\n    import uvicorn\r\n    _app = get_app()\r\n    uvicorn.run(_app, host='10.10.10.98', port=7776)\n```\n\n\n### Description\n\nFastAPI version>=0.74 has a very strange problem with dependency (func get_db in example). \r\n\r\n1) If you run this code as it is and send reques", "output": "Yes, having the same problem with `get_db` dependency not closing connection and the same error message. And it started with 0.74 release https://github.com/tiangolo/fastapi/releases/tag/0.74.0\r\n\r\n```python\r\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\n\r\nfrom app.config import settings\r\n\r\n\r\nengine = create_async_engine(\r\n    settings.DB_DSN,\r\n    echo=settings.DB_ECHO,\r\n    pool_size=settings.DB_POOL_SIZE,\r\n    max_overflow=settings.DB_MAX_OVERFLOW,\r\n    future=True,\r\n)\r\nasync_session = sessionmaker(engine, expire_on_commit=False, class_=AsyncSession, future=True, autoflush=False)\r\n\r\n\r\nasync def get_db():\r\n    db = async_session()\r\n    try:\r\n        yield db\r\n    finally:\r\n        await db.close()\r\n```\r\n\r\nAnd I have middlewares also", "source": "issue", "type": "qa_technical", "issue_number": 30}
{"instruction": "fastapi dev runs stuck\n\nDetails:\n### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe first time I ran fastapi dev, there was no problem, but I encountered a code error. Then after I modified the code and saved it, a WARNING: WatchFiles detected changes in 'tool/index.py'. Reloading... then got stuck and could not exit.\r\n\r\n<img width=\"983\" alt=\"image\" src=\"https://github.com/tiangolo/fastapi/assets/29888469/f596a4fb-af29-4098-b489-3d9efee08f2c\">", "input": "Repository: FastAPI\nLabels: ", "output": "Any updates on this @kingcwt? facing the same issue!", "source": "issue", "type": "qa_best_answer", "issue_number": 29}
{"instruction": "Provide a comprehensive answer to this question: fastapi dev runs stuck", "input": "### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe first time I ran fastapi dev, there was no problem, but I encountered a code error. Then after I modified the code and saved it, a WARNING: WatchFiles detected changes in 'tool/index.py'. Reloading... then got stuck and could not exit.\r\n\r\n<img width=\"983\" alt=\"image\" src=\"https://github.com/tiangolo/fastapi/assets/29888469/f596a4fb-af29-4098-b489-3d9efee08f2c\">", "output": "Any updates on this @kingcwt? facing the same issue!\n\n---\n\nCould be related to: https://github.com/encode/uvicorn/issues/2000\n\n---\n\nI currently have a slightly different issue from yours @kingcwt but it's still an issue with fastapi cli (dev and run)\r\nThe Code \r\n![image](https://github.com/tiangolo/fastapi/assets/69792620/c51f8e7a-79ab-437c-883b-8357ae074b35)\r\n\r\n\r\nThe Error\r\n![image](https://github.com/tiangolo/fastapi/assets/69792620/82c3bbf7-903f-4c8c-b0f4-9b0caaba0c21)\r\n![image](https://github.com/tiangolo/fastapi/assets/69792620/0ef1037d-7e28-4bd0-ade1-56b7307871c7)\n\n---\n\ndo not use the fastapi dev to run your application just use uvicorn  instead, i do not face any issue with uvicorn\n\n---\n\nI tryied to reproduce it, but without success.\r\n\r\nBut sometimes I get the same problem running uvicorn with --reload in cmder/windows. I think it is related to uvicorn instead of fastapi", "source": "issue", "type": "qa_comprehensive", "issue_number": 29}
{"instruction": "Debug and solve this technical issue: fastapi dev runs stuck", "input": "### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe first time I ran fastapi dev, there was no problem, but I encountered a code error. Then after I modified the code and saved it, a WARNING: WatchFiles detected changes in 'tool/index.py'. Reloading... then got stuck and could not exit.\r\n\r\n<img width=\"983\" alt=\"image\" src=\"https://github.com/tiangolo/fastapi/assets/29888469/f596a4fb-af29-4098-b489-3d9efee08f2c\">", "output": "Any updates on this @kingcwt? facing the same issue!", "source": "issue", "type": "qa_technical", "issue_number": 29}
{"instruction": "First-class session support in FastAPI\n\nDetails:\n### Is your feature request related to a problem\r\n\r\nAll of the security schemas currently supported by FastAPI rely on some sort of \"client-server synergy\" , where, for instance, the client is expected to know and remember an OAuth token or the user credentials to be sent via headers. This works fairly well for single-page applications, but if you need to integrate authentication to an app that uses templates, keeping track of that authentication data becomes a challenge. Most applications would use server-side sessions to deal with this, but FastAPI doesn't really have a system to deal with sessions right now.\r\n\r\n### Describe alternatives you've considered\r\n\r\n#### Using Starlette's SessionMiddleware\r\n\r\nWhile Starlette's `SessionMiddleware` is mentionned a number of times in the FastAPI documentation, it does not integrate very well with the framework itself . What it does is that it adds a `request.session` dict on the `Request` object that lets the backend store and retreive information from it, and just before the response get sent, [that dict is serialized, combined to a timestamp, signed, converted into base 64 and appended as a cookie](https://github.com/encode/starlette/blob/b8bd1696492e501bd617bd151278999c68b30e2b/starlette/middleware/sessions.py#L52-L63). The client is then expected to send theat cookie back so that the server so that information can be decoded and used. This is what the Django doc describes as [the cookie-based approach](https://docs.djangoproject.com/en/2.2/topics/http/sessions/).\r\n\r\nThe problem with all this is that the entire process happens outside of what FastAPI can handle, and therefore does not appear in the generated OpenAPI documentation as an authentication schema.\r\n\r\nHaving read the source for that middleware and the documentation for itsdangerous, I also understand that this kind of \"session blob\" authentication method isn't really supported by OpenAPI, since all supported auth methods are expected to use constants to handle a", "input": "Repository: FastAPI\nLabels: ", "output": "Related to #212", "source": "issue", "type": "qa_best_answer", "issue_number": 28}
{"instruction": "Provide a comprehensive answer to this question: First-class session support in FastAPI", "input": "### Is your feature request related to a problem\r\n\r\nAll of the security schemas currently supported by FastAPI rely on some sort of \"client-server synergy\" , where, for instance, the client is expected to know and remember an OAuth token or the user credentials to be sent via headers. This works fairly well for single-page applications, but if you need to integrate authentication to an app that uses templates, keeping track of that authentication data becomes a challenge. Most applications would use server-side sessions to deal with this, but FastAPI doesn't really have a system to deal with sessions right now.\r\n\r\n### Describe alternatives you've considered\r\n\r\n#### Using Starlette's SessionMiddleware\r\n\r\nWhile Starlette's `SessionMiddleware` is mentionned a number of times in the FastAPI documentation, it does not integrate very well with the framework itself . What it does is that it adds a `request.session` dict on the `Request` object that lets the backend store and retreive information from it, and just before the response get sent, [that dict is serialized, combined to a timestamp, signed, converted into base 64 and appended as a cookie](https://github.com/encode/starlette/blob/b8bd1696492e501bd617bd151278999c68b30e2b/starlette/middleware/sessions.py#L52-L63). The client is then expected to send theat cookie back so that the server so that information can be decoded and used. This is what the Django doc describes as [the cookie-based approach](https://docs.djangoproject.com/en/2.2/topics/http/sessions/).\r\n\r\nThe problem with all this is that the entire process happens outside of what FastAPI can handle, and therefore does not appear in the generated OpenAPI documentation as an authentication schema.\r\n\r\nHaving read the source for that middleware and the documentation for itsdangerous, I also understand that this kind of \"session blob\" authentication method isn't really supported by OpenAPI, since all supported auth methods are expected to use constants to handle a", "output": "Related to #212\n\n---\n\nLooks good to me\n\n---\n\n@prostomarkeloff: I know this is off-topic, but I thought LGTM was what you're supposed to say when reviewing patches and pull requests? What would that mean in the context of a feature request?\n\n---\n\n@sm-Fifteen hmm. I wanted say that i am interested in this feature :)\n\n---\n\nIn general I like this idea, because I think a lot of issue have been raised by people looking for this feature, especially in the context of a basic browser-driven interface.\r\n\r\nThat said, for maintainability reasons, I would *much* prefer an implementation that was ultimately powered by features in Starlette, where FastAPI just provided a cleaner dependency injection API and OpenAPI integration, and possibly using generics like `SessionCookie` as you wrote it above to get more of a typed interface (possibly with validation).\r\n\r\nIn particular, I think it would be much preferable for FastAPI to essentially wrap the pluggable session backends that are a part of [this PR](https://github.com/encode/starlette/pull/499), assuming it is eventually merged.\r\n\r\n@sm-Fifteen thoughts?\r\n\r\n------\r\n\r\nSeparately, I think it would be great if we had (optional) support for generics in many places where Starlette has an untyped interface. In particular, in addition to the `SessionCookie` as you've described it, I really wish there was an easy way to generically specify the types of `request.state` and `request.app.state`. I have some hacks in my own code to accomplish this, but maybe there is a clean way to unify all of these...", "source": "issue", "type": "qa_comprehensive", "issue_number": 28}
{"instruction": "ðŸ™ Find maintainers for FastAPI\n\nDetails:\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n\r\n### Description\r\n\r\nAt the moment, all contributions to the FastAPI are made with @tiangolo (directly or through a PR review).  \r\n\r\n@tiangolo is doing a great job ðŸ’ª, but fast developing project with great community like FastAPI demand much more time.  \r\n(It can be seen by the number of open issues and pull request)\r\n\r\n### Wanted Solution\r\n\r\nSuggestion is to __find several active community members__ and add them to the __repository maintainers__, as other projects (e.g. Flask and Django) do. ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦\r\n\r\nThis will help the development of the project and make the atmosphere for third-party contributors much more pleasant. ðŸ‘¾\r\n\r\nHope @tiangolo will consider this possibility\r\n\r\nupd: discussion on this #3970\r\n\r\n### Wanted Code\r\n\r\n```python\r\nfrom fastapi.community import active_members  \r\n\r\nactive_members.make_maintainers()\r\n```", "input": "Repository: FastAPI\nLabels: ", "output": "100% this. To stay at the level of Flask and Django, there needs to be a team of core maintainers. We can't just rely on a single person. \r\n\r\nFastAPI being a single maintainer project is a big reason some companies don't want to start experimenting with it/using it.", "source": "issue", "type": "qa_best_answer", "issue_number": 27}
{"instruction": "Provide a comprehensive answer to this question: ðŸ™ Find maintainers for FastAPI", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n\r\n### Description\r\n\r\nAt the moment, all contributions to the FastAPI are made with @tiangolo (directly or through a PR review).  \r\n\r\n@tiangolo is doing a great job ðŸ’ª, but fast developing project with great community like FastAPI demand much more time.  \r\n(It can be seen by the number of open issues and pull request)\r\n\r\n### Wanted Solution\r\n\r\nSuggestion is to __find several active community members__ and add them to the __repository maintainers__, as other projects (e.g. Flask and Django) do. ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦\r\n\r\nThis will help the development of the project and make the atmosphere for third-party contributors much more pleasant. ðŸ‘¾\r\n\r\nHope @tiangolo will consider this possibility\r\n\r\nupd: discussion on this #3970\r\n\r\n### Wanted Code\r\n\r\n```python\r\nfrom fastapi.community import active_members  \r\n\r\nactive_members.make_maintainers()\r\n```", "output": "100% this. To stay at the level of Flask and Django, there needs to be a team of core maintainers. We can't just rely on a single person. \r\n\r\nFastAPI being a single maintainer project is a big reason some companies don't want to start experimenting with it/using it.\n\n---\n\nTotally! We have the same issue in our company  \r\nFastAPI is Great and we use it for demo and inner projects, however, for production we have to use something else. \r\n\r\nI really want it become only-option for python api. And we'll have `1.0.0` soon with a great maintainers team.\n\n---\n\n@k4black it's not clear if this is just something that you hope for, or if it's an initiative that you have @tiangolo's blessing to undertake. Can you clarify?\n\n---\n\n@benjamin-kirkbride No, it's an initiative. Sorry if I was vague.  \r\n\r\nThis is an `enhancement` issue, so it is call to the community in general and to @tiangolo in particular to consider this way of developing of the FastAPI.\n\n---\n\nSome past discussion has taken place here: https://github.com/tiangolo/fastapi/discussions/3970", "source": "issue", "type": "qa_comprehensive", "issue_number": 27}
{"instruction": "Websocket Routes Only Work on FastAPI, not APIRouter\n\nDetails:\n**Describe the bug**\r\nWebsocket routes appear to only work on the main FastAPI object, not on APIRouter objects.  When the same function is copied from a FastAPI object to an APIRouter object instead of working properly it just throws a 403.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. The following works as expected:\r\n```python\r\nfrom fastapi import FastAPI\r\napp = FastAPI()\r\n\r\n@app.websocket_route(\"/hello\")\r\nasync def hello(websocket):\r\n    await websocket.accept()\r\n    await websocket.send_text(\"Hello!\")\r\n    response = await websocket.receive_text()\r\n    print(response)\r\n    await websocket.close()\r\n    print(\"Closed\")\r\n```\r\n2. Moving `hello` to an APIRouter fails:\r\n```python\r\n# main.py\r\nfrom fastapi import FastAPI\r\nimport other\r\napp = FastAPI()\r\napp.include_router(other.router)\r\n```\r\n\r\n```python\r\n# other.py\r\nfrom fastapi import APIRouter\r\nrouter = APIRouter()\r\n\r\n@router.websocket_route(\"/routerhello\")\r\nasync def hello(websocket):\r\n    await websocket.accept()\r\n    await websocket.send_text(\"Router Hello!\")\r\n    response = await websocket.receive_text()\r\n    print(response)\r\n    await websocket.close()\r\n    print(\"Router Closed\")\r\n```\r\n**Expected behavior**\r\nI expect a websocket route to work on both a FastAPI and APIRouter object.\r\n\r\n**Screenshots**\r\nNot applicable.\r\n\r\n**Environment:**\r\n - OS: macOS 10.14.3\r\n - FastAPI Version: 0.9.0\r\n\r\n- Python version, get it with: 3.7.2\r\n\r\n**Additional context**\r\nTesting websocket client side with `websocat`.", "input": "Repository: FastAPI\nLabels: ", "output": "Thanks for the report!\r\n\r\nIt was fixed by @euri10 in PR https://github.com/tiangolo/fastapi/pull/100.\r\n\r\nIt is available in FastAPI verson `0.10.0`. :tada: :rocket:", "source": "issue", "type": "qa_best_answer", "issue_number": 26}
{"instruction": "Provide a comprehensive answer to this question: Websocket Routes Only Work on FastAPI, not APIRouter", "input": "**Describe the bug**\r\nWebsocket routes appear to only work on the main FastAPI object, not on APIRouter objects.  When the same function is copied from a FastAPI object to an APIRouter object instead of working properly it just throws a 403.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. The following works as expected:\r\n```python\r\nfrom fastapi import FastAPI\r\napp = FastAPI()\r\n\r\n@app.websocket_route(\"/hello\")\r\nasync def hello(websocket):\r\n    await websocket.accept()\r\n    await websocket.send_text(\"Hello!\")\r\n    response = await websocket.receive_text()\r\n    print(response)\r\n    await websocket.close()\r\n    print(\"Closed\")\r\n```\r\n2. Moving `hello` to an APIRouter fails:\r\n```python\r\n# main.py\r\nfrom fastapi import FastAPI\r\nimport other\r\napp = FastAPI()\r\napp.include_router(other.router)\r\n```\r\n\r\n```python\r\n# other.py\r\nfrom fastapi import APIRouter\r\nrouter = APIRouter()\r\n\r\n@router.websocket_route(\"/routerhello\")\r\nasync def hello(websocket):\r\n    await websocket.accept()\r\n    await websocket.send_text(\"Router Hello!\")\r\n    response = await websocket.receive_text()\r\n    print(response)\r\n    await websocket.close()\r\n    print(\"Router Closed\")\r\n```\r\n**Expected behavior**\r\nI expect a websocket route to work on both a FastAPI and APIRouter object.\r\n\r\n**Screenshots**\r\nNot applicable.\r\n\r\n**Environment:**\r\n - OS: macOS 10.14.3\r\n - FastAPI Version: 0.9.0\r\n\r\n- Python version, get it with: 3.7.2\r\n\r\n**Additional context**\r\nTesting websocket client side with `websocat`.", "output": "Thanks for the report!\r\n\r\nIt was fixed by @euri10 in PR https://github.com/tiangolo/fastapi/pull/100.\r\n\r\nIt is available in FastAPI verson `0.10.0`. :tada: :rocket:\n\n---\n\nJust tested it out!  I'm impressed at how quickly that was fixed, thanks!\n\n---\n\nAwesome! Kudos to @euri10 for his work ðŸ˜€ðŸ°ðŸŒ®\r\n\r\nThanks @iwoloschin for reporting back and closing the issue.\n\n---\n\nIs there a chance that something brought this issue back? Or it might be related to Python 3.6.8?\r\n\r\nI find the same bug in this minimal example where only the second websocket fails:\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastapi.testclient import TestClient\r\nfrom fastapi.websockets import WebSocket\r\nfrom fastapi import APIRouter \r\n\r\napp = FastAPI()\r\nrouter = APIRouter(prefix=\"/test\")\r\napp.include_router(router)\r\n\r\n\r\n@app.websocket_route(\"/ws\")\r\nasync def websocket(websocket: WebSocket):\r\n    await websocket.accept()\r\n    await websocket.send_json({\"msg\": \"Hello WebSocket\"})\r\n    await websocket.close()\r\n\r\n\r\n@router.websocket_route(\"/ws\")\r\nasync def websocket(websocket: WebSocket):\r\n    await websocket.accept()\r\n    await websocket.send_json({\"msg\": \"Hello WebSocket 2\"})\r\n    await websocket.close()\r\n\r\n\r\ndef test_websocket():\r\n    client = TestClient(app)\r\n    with client.websocket_connect(\"/ws\") as websocket:\r\n        data = websocket.receive_json()\r\n        assert data == {\"msg\": \"Hello WebSocket\"}\r\n\r\n\r\ndef test_websocket2():\r\n    client = TestClient(app)\r\n    with client.websocket_connect(\"/test/ws\") as websocket:\r\n        data = websocket.receive_json()\r\n        assert data == {\"msg\": \"Hello WebSocket 2\"}\r\n\r\n```\r\n\r\nError log:\r\n```\r\ndef test_websocket2():\r\n        client = TestClient(app)\r\n>      with client.websocket_connect(\"/test/ws\") as websocket:\r\n\r\n/opt/conda/envs/build_env/envs/run_env/lib/python3.6/site-packages/starlette/testclient.py:444: in websocket_connect\r\nsuper().request(\"GET\", url, **kwargs)\r\n/opt/conda/envs/build_env/envs/run_env/lib/python3.6/site-packages/requests/sessions.py:542: in request\r\nresp = self.send(prep, **send_kwargs)\r\n/opt/conda/envs/build_env/envs/run_env/lib/python3.6/site-packages/requests/sessions.py:655: in send\r\nr = adapter.send(request, **kwargs)\r\n/opt/conda/envs/build_env/envs/run_env/lib/python3.6/site-packages/starlette/testclient.py:145: in send\r\nsession = WebSocketTestSession(self.app, scope)\r\n/opt/conda/envs/build_env/envs/run_env/lib/python3.6/site-packages/starlette/testclient.py:278: in __init__\r\nself._raise_on_close(message)\r\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\r\nself = <starlette.testclient.WebSocketTestSession object at 0x7f7cbc689c50>\r\nmessage = {'code': 1000, 'type': 'websocket.close'}\r\ndef _raise_on_close(self, message: Message) -> None:\r\n        if message[\"type\"] == \"websocket.close\":\r\n>           raise WebSocketDisconnect(message.get(\"code\", 1000))\r\nE           starlette.websockets.WebSocketDisconnect: 1000\r\n\r\n```\r\n\r\nEnvironment:\r\n - OS: Amazon Linux Workspace\r\n\r\n - FastAPI Version: 0.63.0\r\n\r\n - Python version: 3.6.8\r\n\r\nThank you for the attention.\n\n---\n\n@brunopcarv This is a 2 years old issue... You'll have better chances of getting help if you create a new one. :kissing:", "source": "issue", "type": "qa_comprehensive", "issue_number": 26}
{"instruction": "Very poor performance does not align with marketing\n\nDetails:\nI wanted to check the temperature of this project and so I ran a quick, very simple, benchmark with `wrk` and the default example:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n```\r\n\r\nEverything default with wrk, regular Ubuntu Linux, Python 3.8.2, latest FastAPI as of now.\r\n\r\n> wrk http://localhost:8000\r\n\r\nUvicorn with logging disabled (obviously), as per the README:\r\n\r\n> python3 -m uvicorn fast:app --log-level critical\r\n\r\nI get very poor performance, way worse than Node.js and really, really far from Golang:\r\n\r\n```\r\nRunning 10s test @ http://localhost:8000\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency     1.83ms  365.59us   3.90ms   75.34%\r\n    Req/Sec     2.74k   116.21     2.98k    65.00%\r\n  54447 requests in 10.00s, 7.37MB read\r\nRequests/sec:   5442.89\r\nTransfer/sec:    754.78KB\r\n```\r\n\r\nThis machine can do 400k req/sec on one single thread using other software, so 5k is not at all fast. Even Node.js does 20-30k on this machine, so this does not align at all with the README:\r\n\r\n```\r\nThe key features are:\r\n\r\nFast: Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available.\r\n```\r\n\r\nWhere do you post benchmarks? How did you come to that conclusion? I cannot see you have posted any benchmarks at all?\r\n\r\nPlease fix marketing, it is not at all true.", "input": "Repository: FastAPI\nLabels: ", "output": "If you [read README further](https://github.com/tiangolo/fastapi/blob/master/README.md#performance)...\r\n\r\n> Independent TechEmpower benchmarks show **FastAPI** applications running under Uvicorn as <a href=\"https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7\" class=\"external-link\" target=\"_blank\">one of the fastest Python frameworks available</a>, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)\r\n>\r\n> To understand more about it, see the section <a href=\"https://fastapi.tiangolo.com/benchmarks/\" class=\"internal-link\" target=\"_blank\">Benchmarks</a>.", "source": "issue", "type": "qa_best_answer", "issue_number": 25}
{"instruction": "Provide a comprehensive answer to this question: Very poor performance does not align with marketing", "input": "I wanted to check the temperature of this project and so I ran a quick, very simple, benchmark with `wrk` and the default example:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n```\r\n\r\nEverything default with wrk, regular Ubuntu Linux, Python 3.8.2, latest FastAPI as of now.\r\n\r\n> wrk http://localhost:8000\r\n\r\nUvicorn with logging disabled (obviously), as per the README:\r\n\r\n> python3 -m uvicorn fast:app --log-level critical\r\n\r\nI get very poor performance, way worse than Node.js and really, really far from Golang:\r\n\r\n```\r\nRunning 10s test @ http://localhost:8000\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency     1.83ms  365.59us   3.90ms   75.34%\r\n    Req/Sec     2.74k   116.21     2.98k    65.00%\r\n  54447 requests in 10.00s, 7.37MB read\r\nRequests/sec:   5442.89\r\nTransfer/sec:    754.78KB\r\n```\r\n\r\nThis machine can do 400k req/sec on one single thread using other software, so 5k is not at all fast. Even Node.js does 20-30k on this machine, so this does not align at all with the README:\r\n\r\n```\r\nThe key features are:\r\n\r\nFast: Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available.\r\n```\r\n\r\nWhere do you post benchmarks? How did you come to that conclusion? I cannot see you have posted any benchmarks at all?\r\n\r\nPlease fix marketing, it is not at all true.", "output": "If you [read README further](https://github.com/tiangolo/fastapi/blob/master/README.md#performance)...\r\n\r\n> Independent TechEmpower benchmarks show **FastAPI** applications running under Uvicorn as <a href=\"https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7\" class=\"external-link\" target=\"_blank\">one of the fastest Python frameworks available</a>, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)\r\n>\r\n> To understand more about it, see the section <a href=\"https://fastapi.tiangolo.com/benchmarks/\" class=\"internal-link\" target=\"_blank\">Benchmarks</a>.\n\n---\n\nOkay, so taking the source **you** gave me (entirely disregarding my own test), I can read the following:\r\n\r\n\r\n268 | fastapi | 159,445 | 2.2%\r\n-- | -- | -- | --\r\n\r\n199 | uvicorn | 382,930 | 5.2%\r\n-- | -- | -- | --\r\n\r\n124 | nodejs | 884,444 | 12.0%\r\n-- | -- | -- | --\r\n\r\n27 | fasthttp | 5,962,266 | 81.2%\r\n-- | -- | -- | --\r\n\r\nWhich is in very stark contrast with the README:\r\n\r\n> Very high performance, on par with NodeJS and Go\r\n\r\nhttps://www.collinsdictionary.com/dictionary/english/on-a-par-with\r\n\r\n2.2% is not \"on par with\" 12%. It's like comparing wine with light beer - they are entirely disjoint, you cannot possibly claim light beer gets you as hammered as wine?\r\n\r\nAnd the golang thing.... jeeeez!\n\n---\n\n@alexhultman Your point might be valid, but I think you might be oversimplifying your tests here. Benchmarks are a tricky thing, but it's important to know what is it that you are comparing.\r\n\r\nFastApi is a Web application framework that provides quite a bit over just an application server.\r\n\r\nSo if you are comparing FastAPI, say, to NodeJs, then the test should be done over a Web Application Framework as NestJS or similar.\r\n\r\nSame thing with Golang. the comparison should be against Revel or something like this. \r\n\r\nIn @tiangolo's documentation on benchmarks you can read:\r\n\r\n> If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications.\r\n\r\nhttps://fastapi.tiangolo.com/benchmarks/\r\n\r\nI believe that when the developers say:\r\n\r\n> Very high performance, on par with NodeJS and Go\r\n\r\nThey mean a full application on Golang or NodeJS (on some framework) vs a Full application on FastAPI.\n\n---\n\nI must agree with @alexhultman that the performance claims are misleading ...I learned it the hard way too. Performance is not really what it claims to be.\r\n\r\nTaking another example, the one just serving a chunk of text:\r\n\r\n- 5962k req/sec for fasthttp\r\n- 884k req/sec for NodeJS\r\n- 159k req/sec for FastAPI\r\n\r\nTo boldly state as the first feature \"Fast: Very high performance, on par with NodeJS and Go\" is well... I guess I don't have to say it. ...It leads to disappointments down the road when you discover the truth.\r\n\r\nProbably it would be better to just keep \"Among the fastest Python frameworks available\" and emphasize on the other good features.\n\n---\n\nThere seem to be two intertwined discussions here that I think we can address separately.\r\n\r\n## The NodeJS and Go comparison\r\nThere is definitely contention around the phrase \"on par with NodeJS and Go\" in the documentation. I believe the *purpose* of that phrase was to be encouraging so that people will try out the framework for their purpose instead of just assuming \"it's Python, it'll be too slow\". However, clearly the phrase can also spawn anger and be off-putting which would be the opposite of what we're trying to achieve here. \r\n\r\nI believe if the comparison is causing bad feelings toward FastAPI that it should simply be removed. We can claim FastAPI is fast without specifically calling out other languages (which almost always leads to defensiveness). Obviously this is up to @tiangolo and we'll need his input here when he gets to this issue.\r\n\r\n## FastAPI's Performance\r\nIf you ask \"is it fast\" about anything, there will be evidence both for and against. I think the point of linking to TechEmpower instead of listing numbers directly is so that people can explore on their own and see if FastAPI makes sense for _their_ workloads.  However, we may be able to do a better job of guiding people about what is \"fast\" about FastAPI.\r\n\r\nFor the numbers I'm about to share, I'm using TechEmpowers \"Round 19\"  looking at only the \"micro\" classification (which is what FastAPI falls under) for \"go\", \"javascript\", \"typescript\", and \"python\".  **I don't use Go or NodeJS in production**, so I'm picking some popular frameworks which appear under this micro category to compare: \"ExpressJS\" (javascript), \"NestJS\" (typescript), and \"Gin\" (golang). I don't know how their feature sets compare to FastAPI.\r\n\r\n### Plain Text\r\nI believe this is what most of the comparisons above me are using. FastAPI is much slower than nest/express which is much slower than Gin. Exactly what people are saying above. If your primary workload is serving text, go with Go.\r\n\r\n### Data Updates\r\nRequests must fetch data from a database, update, and commit it back, then serialize and return the result to the caller.  Here FastAPI is much faster than NestJS/Express which are much faster than Gin.\r\n\r\n### Fortunes\r\nThis test uses an ORM and HTML templating. Here all the frameworks are very close to each other but, in order from fastest to slowest, were Gin, NestJS, FastAPI, Express.\r\n\r\n### Multiple Queries\r\nThis is just fetching multiple rows from the database and serializing the results. Here, FastAPI slightly edges out Gin. Express and NestJS are much slower in this test.\r\n\r\n### Single query\r\nSingle row is fetched and serialized. Gin is much faster than the rest which are, in order, FastAPI, NestJS, and Express.\r\n\r\n### JSON serialization\r\nNo database activity, just serializing some JSON. Gin blows away the competition. Express, then Nest, then FastAPI follow.\r\n\r\nSo the general theme of all the tests combined seems to be if you're working with large amounts of data from the database, FastAPI is the fastest of the bunch. The less database activity (I/O bound), the further FastAPI falls and Gin rises. The real takeaway here is that the answer to \"is it fast\" is always \"it depends\". However, we can probably do a better job of pointing out FastAPI's database strengths in the sections talking about speed.", "source": "issue", "type": "qa_comprehensive", "issue_number": 25}
{"instruction": "Can't read settings .env file\n\nDetails:\nNot working for me...\r\n\r\n\r\n    db_url=\"postgres\" # .env file\r\n   \r\n    class Settings(BaseSettings):\r\n       db_url: str\r\n\r\n       class Config:\r\n          env_file = \".env\"\r\n\r\n\r\n     settings = Settings()\r\n\r\n  \r\n     @lru_cache()\r\n     def get_settings():\r\n       return {\r\n        \"db_url\": settings.db_url,\r\n     }\r\n\r\nGetting error -> **pydantic.error_wrappers.ValidationError: 1 validation error for Settings db_url field required (type=value_error.missing)**", "input": "Repository: FastAPI\nLabels: ", "output": "Do you have `python-dotenv` installed in your current working environment?\r\n\r\nAlso, try writing `db_url` without quotes, see examples from [`python-dotenv`'s documentation](https://pypi.org/project/python-dotenv/)", "source": "issue", "type": "qa_best_answer", "issue_number": 24}
{"instruction": "Provide a comprehensive answer to this question: Can't read settings .env file", "input": "Not working for me...\r\n\r\n\r\n    db_url=\"postgres\" # .env file\r\n   \r\n    class Settings(BaseSettings):\r\n       db_url: str\r\n\r\n       class Config:\r\n          env_file = \".env\"\r\n\r\n\r\n     settings = Settings()\r\n\r\n  \r\n     @lru_cache()\r\n     def get_settings():\r\n       return {\r\n        \"db_url\": settings.db_url,\r\n     }\r\n\r\nGetting error -> **pydantic.error_wrappers.ValidationError: 1 validation error for Settings db_url field required (type=value_error.missing)**", "output": "Do you have `python-dotenv` installed in your current working environment?\r\n\r\nAlso, try writing `db_url` without quotes, see examples from [`python-dotenv`'s documentation](https://pypi.org/project/python-dotenv/)\n\n---\n\n@ycd Yes I have...I just follow the example here [docs](https://fastapi.tiangolo.com/advanced/settings/#reading-a-env-file)\n\n---\n\nJust to be sure ... , this script does not run in your setup?\r\n\r\n```python\r\nfrom pydantic import BaseSettings \r\nfrom functools import lru_cache\r\nimport dotenv\r\n\r\n\r\nwith open(\".env\", \"wt\") as fh:\r\n    print(\"db_url=postgres\", file=fh)\r\n\r\n\r\nclass Settings(BaseSettings):\r\n   db_url: str\r\n\r\n   class Config:\r\n      env_file = \".env\"\r\n\r\n\r\nsettings = Settings()\r\n\r\n@lru_cache()\r\ndef get_settings():\r\n   return {\r\n    \"db_url\": settings.db_url,\r\n }\r\n\r\nassert get_settings() == {'db_url': 'postgres'}\r\n```\n\n---\n\nI'm having the same issue.\r\nHere is my file structure\r\n```\r\n\r\nâ”œâ”€â”€ api\r\nâ”‚Â Â  â”œâ”€â”€ config.py\r\nâ”‚Â Â  â”œâ”€â”€ core\r\nâ”‚Â Â  â”œâ”€â”€ crud.py\r\nâ”‚Â Â  â”œâ”€â”€ database.py\r\nâ”‚Â Â  â”œâ”€â”€ __init__.py\r\nâ”‚Â Â  â”œâ”€â”€ main.py\r\nâ”‚Â Â  â”œâ”€â”€ models.py\r\nâ”‚Â Â  â”œâ”€â”€ schemas.py\r\nâ”‚Â Â  â”œâ”€â”€ tests.py\r\nâ”‚Â Â  â””â”€â”€ utils.py\r\nâ”œâ”€â”€ api_db.db\r\nâ”œâ”€â”€-.env\r\n```\r\n\r\nHere is my `api/config.py` file.\r\n```\r\nfrom pydantic import BaseModel\r\n\r\nclass Settings(BaseModel):\r\n    app_name: str\r\n    debug: bool = True\r\n\r\n    cors_allowed_origins = ['*']\r\n\r\n    smtp_ssl_port: int = 465\r\n    admin_email: str\r\n    admin_email_pass: str\r\n\r\n    sqlalchemy_database_url: str = 'sqlite:///./api_db.db'\r\n\r\n    class Config:\r\n        env_prefix = ''\r\n        env_file = '.env' \r\n\r\nsettings = Settings()\r\n```\r\n\r\nHere is the end of the traceback.\r\n```\r\n\r\n  File \"pydantic/main.py\", line 362, in pydantic.main.BaseModel.__init__\r\npydantic.error_wrappers.ValidationError: 3 validation errors for Settings\r\napp_name\r\n  field required (type=value_error.missing)\r\nadmin_email\r\n  field required (type=value_error.missing)\r\nadmin_email_pass\r\n  field required (type=value_error.missing)\r\n\r\n```\r\n\r\nTo me it seems this Config class isn't picking up the .env file.\r\nI have all dependencies installed and followed the FastAPI docs, and the pydantic docs too.\n\n---\n\n@rexbrandy try setting your `env_file` like this `env_file = \"../.env\"`", "source": "issue", "type": "qa_comprehensive", "issue_number": 24}
{"instruction": "multipart/form-data: Unable to parse complex types in a request form\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it. -  _**See additional context**_\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nimport inspect\r\nfrom typing import Dict, Type\r\n\r\nfrom fastapi import Depends, FastAPI, File, Form\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\ndef as_form(cls: Type[BaseModel]):\r\n    \"\"\"\r\n    Adds an as_form class method to decorated models. The as_form class method\r\n    can be used with FastAPI endpoints\r\n    \"\"\"\r\n    new_params = [\r\n        inspect.Parameter(\r\n            field.alias,\r\n            inspect.Parameter.POSITIONAL_ONLY,\r\n            default=(Form(field.default) if not field.required else Form(...)),\r\n            annotation=field.outer_type_,\r\n        )\r\n        for field in cls.__fields__.values()\r\n    ]\r\n\r\n    async def _as_form(**data)", "input": "Repository: FastAPI\nLabels: ", "output": "Try this:\r\n\r\n```python\r\n\r\nimport inspect\r\nfrom typing import Dict, Type, TypeVar, Protocol, Generic, NewType\r\n\r\nfrom fastapi import Depends, FastAPI, File, Form\r\nfrom pydantic import BaseModel, validator, BaseSettings, Json\r\n\r\napp = FastAPI()\r\n\r\nStringId = NewType('StringId', str)\r\n\r\n\r\ndef as_form(cls: Type[BaseModel]):\r\n    \"\"\"\r\n    Adds an as_form class method to decorated models. The as_form class method\r\n    can be used with FastAPI endpoints\r\n    \"\"\"\r\n    new_params = [\r\n        inspect.Parameter(\r\n            field.alias,\r\n            inspect.Parameter.POSITIONAL_ONLY,\r\n            default=(Form(field.default) if not field.required else Form(...)),\r\n        )\r\n        for field in cls.__fields__.values()\r\n    ]\r\n\r\n    async def _as_form(**data):\r\n        return cls(**data)\r\n\r\n    sig = inspect.signature(_as_form)\r\n    sig = sig.replace(parameters=new_params)\r\n    _as_form.__signature__ = sig\r\n    setattr(cls, \"as_form\", _as_form)\r\n    return cls\r\n\r\n\r\n@as_form\r\nclass Item(BaseModel):\r\n    name: str\r\n    another: str\r\n    opts: Json[Dict[str, int]] = '{}'\r\n\r\n\r\n@app.post(\"/test\")\r\nasync def endpoint(item: Item = Depends(Item.as_form)):\r\n    return item.dict()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import json\r\n    import os\r\n\r\n    from fastapi.testclient import TestClient\r\n\r\n    tc = TestClient(app)\r\n\r\n    item = {\"name\": \"vivalldi\", \"another\": \"mause\"}\r\n\r\n    data = bytearray(os.urandom(1))\r\n    files = {\"data\": (\"data\", data, \"text/csv\")}\r\n\r\n    r = tc.post(\"/test\", data=item, files=files)\r\n    assert r.status_code == 200, r.text\r\n    assert r.json() == {\"name\": \"vivalldi\", \"another\": \"mause\", \"opts\": {}}\r\n\r\n    files[\"opts\"] = (None, json.dumps({\"a\": 2}), \"application/json\")\r\n    r = tc.post(\"/test\", data=item, files=files)\r\n    assert r.status_code == 200\r\n    assert r.json() == {\"name\": \"vivalldi\", \"another\": \"mause\", \"opts\": {\"a\": 2}}\r\n```\r\n\r\nThe main two changes were using the `Json` class from pydantic, and removing the annotation from the as_form method, as otherwise pydantic would be validating the data twice - once for `as_form`, and once for the model itself", "source": "issue", "type": "qa_best_answer", "issue_number": 23}
{"instruction": "Provide a comprehensive answer to this question: multipart/form-data: Unable to parse complex types in a request form", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it. -  _**See additional context**_\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nimport inspect\r\nfrom typing import Dict, Type\r\n\r\nfrom fastapi import Depends, FastAPI, File, Form\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\ndef as_form(cls: Type[BaseModel]):\r\n    \"\"\"\r\n    Adds an as_form class method to decorated models. The as_form class method\r\n    can be used with FastAPI endpoints\r\n    \"\"\"\r\n    new_params = [\r\n        inspect.Parameter(\r\n            field.alias,\r\n            inspect.Parameter.POSITIONAL_ONLY,\r\n            default=(Form(field.default) if not field.required else Form(...)),\r\n            annotation=field.outer_type_,\r\n        )\r\n        for field in cls.__fields__.values()\r\n    ]\r\n\r\n    async def _as_form(**data)", "output": "Try this:\r\n\r\n```python\r\n\r\nimport inspect\r\nfrom typing import Dict, Type, TypeVar, Protocol, Generic, NewType\r\n\r\nfrom fastapi import Depends, FastAPI, File, Form\r\nfrom pydantic import BaseModel, validator, BaseSettings, Json\r\n\r\napp = FastAPI()\r\n\r\nStringId = NewType('StringId', str)\r\n\r\n\r\ndef as_form(cls: Type[BaseModel]):\r\n    \"\"\"\r\n    Adds an as_form class method to decorated models. The as_form class method\r\n    can be used with FastAPI endpoints\r\n    \"\"\"\r\n    new_params = [\r\n        inspect.Parameter(\r\n            field.alias,\r\n            inspect.Parameter.POSITIONAL_ONLY,\r\n            default=(Form(field.default) if not field.required else Form(...)),\r\n        )\r\n        for field in cls.__fields__.values()\r\n    ]\r\n\r\n    async def _as_form(**data):\r\n        return cls(**data)\r\n\r\n    sig = inspect.signature(_as_form)\r\n    sig = sig.replace(parameters=new_params)\r\n    _as_form.__signature__ = sig\r\n    setattr(cls, \"as_form\", _as_form)\r\n    return cls\r\n\r\n\r\n@as_form\r\nclass Item(BaseModel):\r\n    name: str\r\n    another: str\r\n    opts: Json[Dict[str, int]] = '{}'\r\n\r\n\r\n@app.post(\"/test\")\r\nasync def endpoint(item: Item = Depends(Item.as_form)):\r\n    return item.dict()\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    import json\r\n    import os\r\n\r\n    from fastapi.testclient import TestClient\r\n\r\n    tc = TestClient(app)\r\n\r\n    item = {\"name\": \"vivalldi\", \"another\": \"mause\"}\r\n\r\n    data = bytearray(os.urandom(1))\r\n    files = {\"data\": (\"data\", data, \"text/csv\")}\r\n\r\n    r = tc.post(\"/test\", data=item, files=files)\r\n    assert r.status_code == 200, r.text\r\n    assert r.json() == {\"name\": \"vivalldi\", \"another\": \"mause\", \"opts\": {}}\r\n\r\n    files[\"opts\"] = (None, json.dumps({\"a\": 2}), \"application/json\")\r\n    r = tc.post(\"/test\", data=item, files=files)\r\n    assert r.status_code == 200\r\n    assert r.json() == {\"name\": \"vivalldi\", \"another\": \"mause\", \"opts\": {\"a\": 2}}\r\n```\r\n\r\nThe main two changes were using the `Json` class from pydantic, and removing the annotation from the as_form method, as otherwise pydantic would be validating the data twice - once for `as_form`, and once for the model itself\n\n---\n\nHi, I am just wondering why not add something like [this](https://github.com/tiangolo/fastapi/compare/master...tricosmo:patch-1). The error(`type is not dict`) is the value of `Item` comes in as string when it is `multipart/form-data`. This solution also works with nested classes, it also won't unpack all fields of `Item` into form fields, which is not very nice if this `Item` class is a little complicated. Happy to create a PR if this is really a good solution.\n\n---\n\nThat snippet alone isn't really sufficient, as it doesn't include any pydantic validation. But feel free to submit a pr with appropriate documentation and tests if you think it's worth it.\n\n---\n\n@Mause  please could you review the PR above? thanks\n\n---\n\nThe above snippet works for me. The only thing (as mentioned) is that if you want to share a base model across endpoints (some with form-encoding and some with pure JSON) then you'll run into needing to nest JSON. Not a huge issue, and one I can workaround for now. Many thanks @Mause", "source": "issue", "type": "qa_comprehensive", "issue_number": 23}
{"instruction": "Your upgrade of 113 broken all gradio apps - a fix needed ASAP this is devastating\n\nDetails:\na very basic just gradio having app\r\n\r\nfast api 111 fixes issue\r\n\r\nall of my followers now reporting errors and so hard to fix all\r\n\r\ni don't know how can you publish such a devastating bug having version please fix it ASAP\r\n\r\n\r\n```\r\n2024-09-06 00:12:20,515 - INFO - HTTP Request: GET https://api.gradio.app/gradio-messaging/en \"HTTP/1.1 200 OK\"\r\nRunning on local URL:  http://127.0.0.1:7860\r\n2024-09-06 00:12:20,542 - INFO - HTTP Request: GET http://127.0.0.1:7860/startup-events \"HTTP/1.1 200 OK\"\r\n2024-09-06 00:12:20,552 - INFO - HTTP Request: HEAD http://127.0.0.1:7860/ \"HTTP/1.1 200 OK\"\r\n\r\nTo create a public link, set `share=True` in `launch()`.\r\n2024-09-06 00:12:20,673 - INFO - HTTP Request: GET https://checkip.amazonaws.com/ \"HTTP/1.1 200 \"\r\n2024-09-06 00:12:21,337 - INFO - HTTP Request: GET https://api.gradio.app/pkg-version \"HTTP/1.1 200 OK\"\r\nERROR:    Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\pydantic\\type_adapter.py\", line 209, in __init__\r\n    core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\pydantic\\type_adapter.py\", line 98, in _getattr_no_parents\r\n    raise AttributeError(attribute)\r\nAttributeError: __pydantic_core_schema__\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\uvicorn\\protocols\\http\\h11_impl.py\", line 406, in run_asgi\r\n    result = await app(  # type: ignore[func-returns-value]\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\uvicorn\\middleware\\proxy_headers.py\", line 70, in __call__\r\n    return await self.app(scope, receive, send)\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\fastapi\\applications.py\", line 1054, in __call__\r\n    await super().__call__(scope, receive, send)\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\starlette\\applic", "input": "Repository: FastAPI\nLabels: ", "output": "It looks like this latest version broke the vllm project as well:\r\nhttps://github.com/vllm-project/vllm/issues/8212\r\n\r\nNot quite sure how to fix it so just pinning `fastapi == 0.112.2` for now. :-(", "source": "issue", "type": "qa_best_answer", "issue_number": 22}
{"instruction": "Provide a comprehensive answer to this question: Your upgrade of 113 broken all gradio apps - a fix needed ASAP this is devastating", "input": "a very basic just gradio having app\r\n\r\nfast api 111 fixes issue\r\n\r\nall of my followers now reporting errors and so hard to fix all\r\n\r\ni don't know how can you publish such a devastating bug having version please fix it ASAP\r\n\r\n\r\n```\r\n2024-09-06 00:12:20,515 - INFO - HTTP Request: GET https://api.gradio.app/gradio-messaging/en \"HTTP/1.1 200 OK\"\r\nRunning on local URL:  http://127.0.0.1:7860\r\n2024-09-06 00:12:20,542 - INFO - HTTP Request: GET http://127.0.0.1:7860/startup-events \"HTTP/1.1 200 OK\"\r\n2024-09-06 00:12:20,552 - INFO - HTTP Request: HEAD http://127.0.0.1:7860/ \"HTTP/1.1 200 OK\"\r\n\r\nTo create a public link, set `share=True` in `launch()`.\r\n2024-09-06 00:12:20,673 - INFO - HTTP Request: GET https://checkip.amazonaws.com/ \"HTTP/1.1 200 \"\r\n2024-09-06 00:12:21,337 - INFO - HTTP Request: GET https://api.gradio.app/pkg-version \"HTTP/1.1 200 OK\"\r\nERROR:    Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\pydantic\\type_adapter.py\", line 209, in __init__\r\n    core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\pydantic\\type_adapter.py\", line 98, in _getattr_no_parents\r\n    raise AttributeError(attribute)\r\nAttributeError: __pydantic_core_schema__\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\uvicorn\\protocols\\http\\h11_impl.py\", line 406, in run_asgi\r\n    result = await app(  # type: ignore[func-returns-value]\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\uvicorn\\middleware\\proxy_headers.py\", line 70, in __call__\r\n    return await self.app(scope, receive, send)\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\fastapi\\applications.py\", line 1054, in __call__\r\n    await super().__call__(scope, receive, send)\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\starlette\\applic", "output": "It looks like this latest version broke the vllm project as well:\r\nhttps://github.com/vllm-project/vllm/issues/8212\r\n\r\nNot quite sure how to fix it so just pinning `fastapi == 0.112.2` for now. :-(\n\n---\n\n> It looks like this latest version broke the vllm project as well: [vllm-project/vllm#8212](https://github.com/vllm-project/vllm/issues/8212)\r\n> \r\n> Not quite sure how to fix it so just pinning `fastapi == 0.112.2` for now. :-(\r\n\r\nit broken literally all of the gradio apps. it is such a devastating bug. i have 10s of apps and updating installers and making all fast api lower version is so problematic\r\n\r\nespecially many apps are remote repos that i use from other people\n\n---\n\nhttps://github.com/bmaltais/kohya_ss/issues/2783#issuecomment-2332444719\n\n---\n\n@FurkanGozukara please share a self-contained [minimal self-contained example](https://stackoverflow.com/help/minimal-reproducible-example) that replicates the issue so that I can copy-paste it, run it, and see your error. I just tried with the getting-started Gradio app, and it all seems to work.\r\n\r\nNow, the right place to start would have been a GitHub Discussion, filling the form, that would have guided you to provide a reproducible example.\r\n\r\nAnd then, please be kind, your post is aggressive and demeaning, this is open source, you get it for free, you are not paying nor contributing anything here, so at least, be kind.\n\n---\n\nsame issue in my gradio project. \r\n\r\nrollback to 0.112.2 as the workaround\r\n\r\ntechnically, it affects all the projects related to gradio", "source": "issue", "type": "qa_comprehensive", "issue_number": 22}
{"instruction": "Are there plans to make class-based-views a first-class feature?\n\nDetails:\n**Description**\r\n\r\nHi @tiangolo! First off kudos on FastAPI, beautiful stuff. My team (about a dozen backenders, pinging one here @gvbgduh) are in the midst of porting out Py2 services to Py3 and thought it'd be a good time to move away from Flask and Flask-RESTful and into something that makes better use of the Py3 features (predominantly async). Thus far FastAPI/Starlette is the top contender but the one feature we're missing the most is class-based-views (CBVs) as opposed to the defacto function-based-views (FBVs). Thus we were wondering if there's any plans to introduce CBVs as a first-class feature in FastAPI.\r\n\r\nWhile we know Starlette plays well with CBVs we looove the automagical features FastAPI offers like validation, OpenAPI generation, etc, things we had to do in very round-about ways prior.\r\n\r\nWay we see it CBVs have the following primary perks:\r\n- Centralised routing since you tend to declare the different routes in one place, typically after instantiating the application.\r\n- Code reusability since you can easily do OOP and inherit (eg through mixins) or compose common functionality around.\r\n- Would make it much easier to port existing CBVs to FastAPI since we'd be coming from Flask-RESTful.\r\n\r\nThus far we've found we can 'hack' CBVs into FastAPI as such:\r\n\r\n```\r\nfrom typing import Dict\r\n\r\nimport fastapi\r\nfrom starlette.endpoints import HTTPEndpoint\r\n\r\nfrom app.services.api.models import Something\r\n\r\n\r\napp = fastapi.FastAPI(debug=True)\r\n\r\n\r\nclass ResourceRoot(HTTPEndpoint):\r\n    def get(self):\r\n        # do stuff\r\n\r\n\r\nclass ResourceSomething(HTTPEndpoint):\r\n\r\n    def get(self, some_id: str) -> Dict:\r\n        # do stuff\r\n\r\n    def post(self, something: Something) -> None:\r\n        # do stuff\r\n\r\n\r\nresource_root = ResourceRoot(scope={\"type\": \"http\"})\r\nresource_something = ResourceSomething(scope={\"type\": \"http\"})\r\napp.add_api_route(\r\n    path=\"/\",\r\n    endpoint=resource_root.get,\r\n    methods=[\"GET\"],\r\n)\r\napp.add_api_route(\r\n    path=\"/something\",\r\n    en", "input": "Repository: FastAPI\nLabels: ", "output": "I also want this feature. Great, support!", "source": "issue", "type": "qa_best_answer", "issue_number": 21}
{"instruction": "Provide a comprehensive answer to this question: Are there plans to make class-based-views a first-class feature?", "input": "**Description**\r\n\r\nHi @tiangolo! First off kudos on FastAPI, beautiful stuff. My team (about a dozen backenders, pinging one here @gvbgduh) are in the midst of porting out Py2 services to Py3 and thought it'd be a good time to move away from Flask and Flask-RESTful and into something that makes better use of the Py3 features (predominantly async). Thus far FastAPI/Starlette is the top contender but the one feature we're missing the most is class-based-views (CBVs) as opposed to the defacto function-based-views (FBVs). Thus we were wondering if there's any plans to introduce CBVs as a first-class feature in FastAPI.\r\n\r\nWhile we know Starlette plays well with CBVs we looove the automagical features FastAPI offers like validation, OpenAPI generation, etc, things we had to do in very round-about ways prior.\r\n\r\nWay we see it CBVs have the following primary perks:\r\n- Centralised routing since you tend to declare the different routes in one place, typically after instantiating the application.\r\n- Code reusability since you can easily do OOP and inherit (eg through mixins) or compose common functionality around.\r\n- Would make it much easier to port existing CBVs to FastAPI since we'd be coming from Flask-RESTful.\r\n\r\nThus far we've found we can 'hack' CBVs into FastAPI as such:\r\n\r\n```\r\nfrom typing import Dict\r\n\r\nimport fastapi\r\nfrom starlette.endpoints import HTTPEndpoint\r\n\r\nfrom app.services.api.models import Something\r\n\r\n\r\napp = fastapi.FastAPI(debug=True)\r\n\r\n\r\nclass ResourceRoot(HTTPEndpoint):\r\n    def get(self):\r\n        # do stuff\r\n\r\n\r\nclass ResourceSomething(HTTPEndpoint):\r\n\r\n    def get(self, some_id: str) -> Dict:\r\n        # do stuff\r\n\r\n    def post(self, something: Something) -> None:\r\n        # do stuff\r\n\r\n\r\nresource_root = ResourceRoot(scope={\"type\": \"http\"})\r\nresource_something = ResourceSomething(scope={\"type\": \"http\"})\r\napp.add_api_route(\r\n    path=\"/\",\r\n    endpoint=resource_root.get,\r\n    methods=[\"GET\"],\r\n)\r\napp.add_api_route(\r\n    path=\"/something\",\r\n    en", "output": "I also want this feature. Great, support!\n\n---\n\nFWIW, I'm looking for this feature because I have a HTTP header I need to pass through to external APIs - right now I'm passing it through a bunch of different functions, would be nice to have a class so I can just do `self.my_header = whatever` and just pass in `self.my_header` where I need to.\n\n---\n\n@knyghty wouldn't a middleware make more sense there?\n\n---\n\n@somada141 it was my first thought, but I don't only need to replicate the header on the response, but also to other requests to external services I'm making.\n\n---\n\n> Hi @tiangolo! First off kudos on FastAPI, beautiful stuff.\r\n\r\nI'm glad you're liking it!\r\n\r\n> [...] CBVs [...]\r\n\r\nThanks for the request and the explanation @somada141 .\r\n\r\nHelp me understand something, in your example, the same `ResourceSomething` has two different URL paths, `/something` and `/something/{some_id}`.\r\n\r\nFrom the examples I can see in Flask-restful and the ones for HTTPEndpoint in Starlette, I see that class-based views would only be able to handle one path operation at a time, right?\r\n\r\nSo, it would have to be a class for `/something`, I guess with `get` to read all the resources of that type and `post` to create new ones.\r\n\r\n...and then another class for `/something/{some_id}`, with `put` to update an item and `get` to read a specific item.\r\n\r\nIs that correct? How would you expect that to work?\r\n\r\n---\r\n\r\nMaybe to put it another way, how would you imagine the code you write using FastAPI with class-based views? How would it look like?", "source": "issue", "type": "qa_comprehensive", "issue_number": 21}
{"instruction": "Context managers in `Depends` are broken after 0.106\n\nDetails:\n### Discussed in https://github.com/tiangolo/fastapi/discussions/11107\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **FeeeeK** February  7, 2024</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, Request\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Session:\r\n    def __init__(self):\r\n        print(\"creating session\")\r\n\r\n    async def __aenter__(self):\r\n        print(\"opening session\")\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc, tb):\r\n        print(\"closing session\")\r\n\r\n    async def commit(self):\r\n        print(\"committing session\")\r\n\r\n    async def rollback(self):\r\n        print(\"rolling back session\")\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def commit_session(request: Request, call_next):\r\n    # minimalistic middleware for example, my code uses ASGI middleware\r\n    response = await call_next(request)\r\n    db_session = request.scope.get(\"db_session\")\r\n    if not db_session:\r\n        return response\r\n\r\n    if response.status_code // 200 != 1:\r\n        await db_session.rollback()\r\n    else:\r\n        await db_session.commit()\r\n\r\n    return response\r\n\r\n\r\nasync def get_db_session(request: Request):\r\n    async with Ses", "input": "Repository: FastAPI\nLabels: ", "output": "I [commented](https://github.com/tiangolo/fastapi/discussions/11107#discussioncomment-8459459) in the Discussion that `StreamingResponse`'s no longer work with `Depends` resources. Since this is a pretty large change in behavior, and wasn't called out in the release notes, I wonder if this is intended. Should this be a separate Issue?", "source": "issue", "type": "qa_best_answer", "issue_number": 20}
{"instruction": "Provide a comprehensive answer to this question: Context managers in `Depends` are broken after 0.106", "input": "### Discussed in https://github.com/tiangolo/fastapi/discussions/11107\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **FeeeeK** February  7, 2024</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, Request\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Session:\r\n    def __init__(self):\r\n        print(\"creating session\")\r\n\r\n    async def __aenter__(self):\r\n        print(\"opening session\")\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc, tb):\r\n        print(\"closing session\")\r\n\r\n    async def commit(self):\r\n        print(\"committing session\")\r\n\r\n    async def rollback(self):\r\n        print(\"rolling back session\")\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def commit_session(request: Request, call_next):\r\n    # minimalistic middleware for example, my code uses ASGI middleware\r\n    response = await call_next(request)\r\n    db_session = request.scope.get(\"db_session\")\r\n    if not db_session:\r\n        return response\r\n\r\n    if response.status_code // 200 != 1:\r\n        await db_session.rollback()\r\n    else:\r\n        await db_session.commit()\r\n\r\n    return response\r\n\r\n\r\nasync def get_db_session(request: Request):\r\n    async with Ses", "output": "I [commented](https://github.com/tiangolo/fastapi/discussions/11107#discussioncomment-8459459) in the Discussion that `StreamingResponse`'s no longer work with `Depends` resources. Since this is a pretty large change in behavior, and wasn't called out in the release notes, I wonder if this is intended. Should this be a separate Issue?\n\n---\n\n> I [commented](https://github.com/tiangolo/fastapi/discussions/11107#discussioncomment-8459459) in the Discussion that `StreamingResponse`'s no longer work with `Depends` resources. Since this is a pretty large change in behavior, and wasn't called out in the release notes, I wonder if this is intended. Should this be a separate Issue?\r\n\r\nNo. The only reason I created this issue is because of your comment. ðŸ™\n\n---\n\nDoes this comment by @tiangolo answers this issue: https://github.com/tiangolo/fastapi/discussions/11177#discussioncomment-8559300 ?\n\n---\n\nI might be misinterpreting but I don't think so? Seems like it was intended to disable using resources in background tasks. But was it intended to also disable using resources in path operators with `StreamingResponses`?\n\n---\n\nIt seems this is what breaks our streaming endpoints, the lack of which kills throughput making everything slow.", "source": "issue", "type": "qa_comprehensive", "issue_number": 20}
{"instruction": "Debug and solve this technical issue: Context managers in `Depends` are broken after 0.106", "input": "### Discussed in https://github.com/tiangolo/fastapi/discussions/11107\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **FeeeeK** February  7, 2024</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, Request\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Session:\r\n    def __init__(self):\r\n        print(\"creating session\")\r\n\r\n    async def __aenter__(self):\r\n        print(\"opening session\")\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc, tb):\r\n        print(\"closing session\")\r\n\r\n    async def commit(self):\r\n        print(\"committing session\")\r\n\r\n    async def rollback(self):\r\n        print(\"rolling back session\")\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def commit_session(request: Request, call_next):\r\n    # minimalistic middleware for example, my code uses ASGI middleware\r\n    response = await call_next(request)\r\n    db_session = request.scope.get(\"db_session\")\r\n    if not db_session:\r\n        return response\r\n\r\n    if response.status_code // 200 != 1:\r\n        await db_session.rollback()\r\n    else:\r\n        await db_session.commit()\r\n\r\n    return response\r\n\r\n\r\nasync def get_db_session(request: Request):\r\n    async with Session() as session:\r\n        request.scope[\"db_session\"] = session\r\n        yield session\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root(session: Session = Depends(get_db_session)):\r\n    return {\"message\": \"Hello World\"}\r\n\r\n\r\n# Pre 0.106 behaviour:\r\n\r\n# creating session\r\n# opening session\r\n# committing session\r\n# closing session\r\n\r\n# Post 0.106 behaviour:\r\n# creating session\r\n# opening session\r\n# closing session\r\n# committing session\r\n\r\n# The session is not committed, because it's closed before the middleware is called.\r\n```\r\n\r\n\r\n### Description\r\n\r\nBefore `0.106`, Depends execution after yield was after middlewares, which allowed to access resources created for a route (e.g. sessions) and do something with them depending on the response (which cannot be done with Depends), but after 0.106, the behavior has changed and this feature is no longer available. The documentation only talks about background tasks, but not a word about middlewares. Was this behavior change intentional?\r\n\r\n### Operating Syst", "output": "I [commented](https://github.com/tiangolo/fastapi/discussions/11107#discussioncomment-8459459) in the Discussion that `StreamingResponse`'s no longer work with `Depends` resources. Since this is a pretty large change in behavior, and wasn't called out in the release notes, I wonder if this is intended. Should this be a separate Issue?", "source": "issue", "type": "qa_technical", "issue_number": 20}
{"instruction": "Using pydantic models for GET request query params? Currently not possible, have to use dataclasses or normal classes.\n\nDetails:\n**Description**\r\n\r\nIs there a way to use pydantic models for GET requests? I would like to have a similar interface for both query params and for the body. So for instance, an example could look like this:\r\n\r\n```\r\nclass PingArgs(BaseModel):\r\n    \"\"\"Model input for PingArgs.\"\"\"\r\n\r\n    dt: datetime.datetime = ...\r\n    to_sum: List[int] = ...\r\n\r\n    @validator(\"dt\", pre=False, always=True, whole=True)\r\n    def validate_dt(cls, v, values):\r\n        \"\"\"Validate dt.\"\"\"\r\n        parsed_dt = v.replace(tzinfo=None)\r\n        return parsed_dt\r\n\r\n@router.get(\"/ping\", tags=[\"basic\"])\r\ndef ping(args: PingArgs, request: Request):\r\n    \"\"\"Example.\"\"\"\r\n    return JSONResponse(\r\n        status_code=starlette.status.HTTP_200_OK,\r\n        content={\"detail\": \"pong\", \"dt\": args.dt.isoformat() \"summed\": sum(x for x in args.to_sum)},\r\n    )\r\n```\r\n\r\nWhere as, right now I think you would have to do something like this:\r\n\r\n```\r\n@router.get(\"/ping\", tags=[\"basic\"])\r\ndef ping(dt: datetime.datetime = Query(None), to_sum: List[int] = Query(None), request: Request):\r\n    \"\"\"Example.\"\"\"\r\n    parsed_dt = dt.replace(tzinfo=None)\r\n    \r\n    return JSONResponse(\r\n        status_code=starlette.status.HTTP_200_OK,\r\n        content={\"detail\": \"pong\", \"dt\": dt.isoformat() \"summed\": sum(x for x in to_sum)},\r\n    )\r\n```\r\n\r\nHope this can be clarified.", "input": "Repository: FastAPI\nLabels: ", "output": "@LasseGravesen the problem is that GET operations don't have a body: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET\r\n\r\nThe Pydantic body you are defining in the first example is not equivalent to the query parameters in the second.\r\n\r\nThat Pydantic model would require a JSON body with something like:\r\n\r\n```JSON\r\n{\r\n  \"dt\": \"2019-06-20T01:02:03+05:00\",\r\n  \"to_sum\": [2, 3, 4]\r\n}\r\n```\r\n\r\nBut what you can do, to avoid having to put all the parameters in each path operation, is to create a dependency, it would require the query parameters as you have them, and then you can put them in a Pydantic model with the shape you want, and it would return that Pydantic model.\r\n\r\nOr even shorter, you can create a class dependency, check a very similar example in the docs: https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/", "source": "issue", "type": "qa_best_answer", "issue_number": 19}
{"instruction": "Provide a comprehensive answer to this question: Using pydantic models for GET request query params? Currently not possible, have to use dataclasses or normal classes.", "input": "**Description**\r\n\r\nIs there a way to use pydantic models for GET requests? I would like to have a similar interface for both query params and for the body. So for instance, an example could look like this:\r\n\r\n```\r\nclass PingArgs(BaseModel):\r\n    \"\"\"Model input for PingArgs.\"\"\"\r\n\r\n    dt: datetime.datetime = ...\r\n    to_sum: List[int] = ...\r\n\r\n    @validator(\"dt\", pre=False, always=True, whole=True)\r\n    def validate_dt(cls, v, values):\r\n        \"\"\"Validate dt.\"\"\"\r\n        parsed_dt = v.replace(tzinfo=None)\r\n        return parsed_dt\r\n\r\n@router.get(\"/ping\", tags=[\"basic\"])\r\ndef ping(args: PingArgs, request: Request):\r\n    \"\"\"Example.\"\"\"\r\n    return JSONResponse(\r\n        status_code=starlette.status.HTTP_200_OK,\r\n        content={\"detail\": \"pong\", \"dt\": args.dt.isoformat() \"summed\": sum(x for x in args.to_sum)},\r\n    )\r\n```\r\n\r\nWhere as, right now I think you would have to do something like this:\r\n\r\n```\r\n@router.get(\"/ping\", tags=[\"basic\"])\r\ndef ping(dt: datetime.datetime = Query(None), to_sum: List[int] = Query(None), request: Request):\r\n    \"\"\"Example.\"\"\"\r\n    parsed_dt = dt.replace(tzinfo=None)\r\n    \r\n    return JSONResponse(\r\n        status_code=starlette.status.HTTP_200_OK,\r\n        content={\"detail\": \"pong\", \"dt\": dt.isoformat() \"summed\": sum(x for x in to_sum)},\r\n    )\r\n```\r\n\r\nHope this can be clarified.", "output": "@LasseGravesen the problem is that GET operations don't have a body: https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET\r\n\r\nThe Pydantic body you are defining in the first example is not equivalent to the query parameters in the second.\r\n\r\nThat Pydantic model would require a JSON body with something like:\r\n\r\n```JSON\r\n{\r\n  \"dt\": \"2019-06-20T01:02:03+05:00\",\r\n  \"to_sum\": [2, 3, 4]\r\n}\r\n```\r\n\r\nBut what you can do, to avoid having to put all the parameters in each path operation, is to create a dependency, it would require the query parameters as you have them, and then you can put them in a Pydantic model with the shape you want, and it would return that Pydantic model.\r\n\r\nOr even shorter, you can create a class dependency, check a very similar example in the docs: https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/\n\n---\n\n@tiangolo \r\nIt would not be a body, it would just be GET parameters as defined in a model. For instance, I come from the perspective of Flask and webargs, where you can define a 'model' and use that with the same interface for both GET and POST parameters, see for instance here:\r\n\r\nhttps://github.com/marshmallow-code/webargs/blob/dev/examples/flask_example.py#L23-L34\r\n\r\nThat is not a body, but rather it puts the GET query parameters into a model.\r\n\r\nI'll look into dependencies, but I hope you'll consider the above.\n\n---\n\nDependencies might work, is there any reason why we couldn't use a pydantic class as a dependency?\n\n---\n\n@LasseGravesen I think you may have misunderstood the get parameter.\r\n\r\nwhy it not use a pydantic class as a dependency?\r\n\r\nI think that:\r\n\r\n* first of all, you must to know the query parameters are dynamic. for example:\r\n```\r\nhttp://www.localhost.com?q=1&page=1&pageSize=1&field='name'\r\n```\r\nLet's think about it. if use pydantic class, we should define the model. maybe like this:\r\n```\r\nclass QueryArgs(BaseModel):\r\n    q: int = ...\r\n    page: int  = ...\r\n    pageSize: int  = ... \r\n    field: string = ...\r\n```\r\nok,  all the parameters are defined in the model.\r\n\r\nHowever,  In practice,  you will find that one request only need two field, such as page and pageSize, \r\n\r\nSupposing the ```page``` range is 1-100, ```pageSize``` range is 1 - 100. \r\n\r\nSo if I request the ```pageSize``` is -1, it will throw error.  however the  â€œ-1 â€  represents no need for paging. \r\n\r\nSo I must remove the field from the model. \r\n\r\nThere are many more examples.\r\n\r\n* More flexible and clarity. I can choice any field to check. because I only need to add field to the function as the params. you don't need to get the field from the object and can avoid the repeat the work.\r\n\r\n----\r\n\r\nTo make a long story short, I think the code design style is better than use the  ```pydantic model```  and more suitable for get parameters.\n\n---\n\n@tiangolo, I had an opportunity to fiddle a little bit more with this today. \r\nHere is a full example of the different ways to specify parameters using depends: https://gist.github.com/Atheuz/075f4d8fe3b56d034741301ba2574ef1\r\n\r\nYou can run it using this command `uvicorn run:app --reload --host 0.0.0.0 --port 8080`\r\n\r\nI essence: dataclass classes work if I specify `Query(None)` and `Depends`, pure classes work if I specify `Query(None)` and use `Depends`, and input parameters in the signature just works. \r\n\r\nPydantic classes do not work, at least in terms of the generated docs, it just says `data` instead of the expected `dt` and `to_sum`.\r\n\r\ndataclasses in the generated docs:\r\n![billede](https://user-images.githubusercontent.com/202696/59960977-0c7b6580-94d1-11e9-95ad-c89090f133f9.png)\r\n\r\npydantic in the generated docs:\r\n![billede](https://user-images.githubusercontent.com/202696/59960978-18ffbe00-94d1-11e9-9869-524c738cd0e2.png)", "source": "issue", "type": "qa_comprehensive", "issue_number": 19}
{"instruction": "BrokenResourceError\n\nDetails:\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [x] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\napp.py\r\n```python\r\nimport time\r\nimport uvicorn\r\nfrom fastapi import FastAPI, Request\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def middleware(request: Request, call_next):\r\n    return await call_next(request)\r\n\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    time.sleep(4)\r\n    return {\"Hello\": \"World\"}\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(app=\"app:app\", port=8000)\r\n```\r\nscript.py\r\n```python\r\nimport requests as requests\r\n\r\nr = requests.get(f\"http://127.0.0.1:8000\", timeout=2)\r\n```\r\n\r\n### Description\r\nIf you trigger script.py, error will appear.\r\nAfter upgrade fastapi to 0.70.0 In some requests in our application its apearing this error.  So what we can do? What is problem?\r\n```\r\nERROR:    Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"venv/lib/python3.8/site-packages/uvicorn/protocols/http/httptools_impl.py\", line 398, in run_asgi\r\n    result = await app(self.scope, self.receive, self.send)\r\n  File \"venv/lib/python3.8/site-packages/uvicorn/middleware/proxy_headers.py\", line 45, in __call__\r\n    return await self.app(scope, receive, send)\r\n", "input": "Repository: FastAPI\nLabels: ", "output": "This looks like a starlette issue: https://github.com/encode/starlette/issues/1284", "source": "issue", "type": "qa_best_answer", "issue_number": 18}
{"instruction": "Provide a comprehensive answer to this question: BrokenResourceError", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [x] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\napp.py\r\n```python\r\nimport time\r\nimport uvicorn\r\nfrom fastapi import FastAPI, Request\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def middleware(request: Request, call_next):\r\n    return await call_next(request)\r\n\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    time.sleep(4)\r\n    return {\"Hello\": \"World\"}\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(app=\"app:app\", port=8000)\r\n```\r\nscript.py\r\n```python\r\nimport requests as requests\r\n\r\nr = requests.get(f\"http://127.0.0.1:8000\", timeout=2)\r\n```\r\n\r\n### Description\r\nIf you trigger script.py, error will appear.\r\nAfter upgrade fastapi to 0.70.0 In some requests in our application its apearing this error.  So what we can do? What is problem?\r\n```\r\nERROR:    Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"venv/lib/python3.8/site-packages/uvicorn/protocols/http/httptools_impl.py\", line 398, in run_asgi\r\n    result = await app(self.scope, self.receive, self.send)\r\n  File \"venv/lib/python3.8/site-packages/uvicorn/middleware/proxy_headers.py\", line 45, in __call__\r\n    return await self.app(scope, receive, send)\r\n", "output": "This looks like a starlette issue: https://github.com/encode/starlette/issues/1284\n\n---\n\n```\r\nException in ASGI application\r\nBrokenResourceError: null\r\n  File \"uvicorn/protocols/http/h11_impl.py\", line 373, in run_asgi\r\n    result = await app(self.scope, self.receive, self.send)\r\n  File \"uvicorn/middleware/proxy_headers.py\", line 75, in __call__\r\n    return await self.app(scope, receive, send)\r\n  File \"fastapi/applications.py\", line 208, in __call__\r\n    await super().__call__(scope, receive, send)\r\n  File \"starlette/applications.py\", line 112, in __call__\r\n    await self.middleware_stack(scope, receive, send)\r\n  File \"starlette/middleware/errors.py\", line 181, in __call__\r\n    raise exc\r\n  File \"starlette/middleware/errors.py\", line 159, in __call__\r\n    await self.app(scope, receive, _send)\r\n  File \"starlette/middleware/base.py\", line 57, in __call__\r\n    task_group.cancel_scope.cancel()\r\n  File \"anyio/_backends/_asyncio.py\", line 567, in __aexit__\r\n    raise exceptions[0]\r\n  File \"starlette/middleware/base.py\", line 30, in coro\r\n    await self.app(scope, request.receive, send_stream.send)\r\n  File \"starlette/exceptions.py\", line 82, in __call__\r\n    raise exc\r\n  File \"starlette/exceptions.py\", line 71, in __call__\r\n    await self.app(scope, receive, sender)\r\n  File \"starlette/routing.py\", line 656, in __call__\r\n    await route.handle(scope, receive, send)\r\n  File \"starlette/routing.py\", line 259, in handle\r\n    await self.app(scope, receive, send)\r\n  File \"starlette/routing.py\", line 64, in app\r\n    await response(scope, receive, send)\r\n  File \"starlette/responses.py\", line 139, in __call__\r\n    await send({\"type\": \"http.response.body\", \"body\": self.body})\r\n  File \"starlette/exceptions.py\", line 68, in sender\r\n    await send(message)\r\n  File \"anyio/streams/memory.py\", line 205, in send\r\n    raise BrokenResourceError\r\n```\r\n### Operating System\r\nLinux\r\n### FastAPI Version\r\n0.70.0\r\n\r\n### Python Version\r\n3.9.7\n\n---\n\nI have the same problem, this is my code:\r\n\r\n**main.py**\r\n```python\r\n# -*- coding: utf-8 -*-\r\n\r\n\r\nfrom fastapi import FastAPI, Request\r\nfrom fastapi.responses import JSONResponse\r\nfrom fastapi.encoders import jsonable_encoder\r\nfrom pony.orm import *\r\n\r\nfrom models_pony.name_basics import NameBasics as pn_name_basics\r\n\r\napi = FastAPI() \r\n\r\n\r\n@api.middleware('http')\r\nasync def process_request(request: Request, call_next):\r\n    return await call_next(request)\r\n\r\n\r\n@api.get('/namebasics/id/{id}')\r\nasync def get_namebasic_by_id(id:int):\r\n    with db_session:\r\n         result = (pn_name_basics[id]).to_dict()\r\n    return JSONResponse(result)\r\n\r\n\r\n\r\n@api.get('/namebasics/ncost/{ncost}')\r\nasync def get_namebasic_by_ncost(ncost:str):\r\n    with db_session:\r\n        result = (pn_name_basics.get(ncost=ncost)).to_dict()\r\n    return JSONResponse(result)\r\n\r\n\r\n\r\n@api.get('/namebasics/year/{year}')\r\nasync def get_namebasic_by_year(year:str):\r\n    with db_session:\r\n        results = select(p for p in pn_name_basics if p.birth_year == year)[:]\r\n        _results = [i.to_dict() for i in results]\r\n        _results = jsonable_encoder(_results)\r\n    return JSONResponse(_results)\r\n\r\n\r\n\r\n@api.get('/namebasics/yearalive/{yearalive}')\r\nasync def get_namebasic_by_yearalive(yearalive:str):\r\n    with db_session:\r\n        results = select(p for p in pn_name_basics if p.birth_year == yearalive and p.death_year is None)[:]\r\n        _results = [i.to_dict() for i in results]\r\n        _results = jsonable_encoder(_results)\r\n    return JSONResponse(_results)\r\n```\r\n\r\n**Command terminal test**\r\n```\r\nwrk --duration 20s --threads 2 --connections 5 http://0.0.0.0:8000/namebasics/id/1024\r\nRunning 20s test @ http://0.0.0.0:8000/namebasics/id/1024\r\n  2 threads and 5 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency     8.54ms    9.84ms 112.06ms   91.46%\r\n    Req/Sec   289.56    154.88   565.00     59.00%\r\n  11538 requests in 20.05s, 3.66MB read\r\nRequests/sec:    575.56\r\nTransfer/sec:    187.17KB\r\n```\r\n\r\n**Error**\r\n```\r\n[2021-10-20 01:50:45 +0000] [5117] [ERROR] Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/uvicorn/protocols/http/httptools_impl.py\", line 375, in run_asgi\r\n    result = await app(self.scope, self.receive, self.send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/uvicorn/middleware/proxy_headers.py\", line 75, in __call__\r\n    return await self.app(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/fastapi/applications.py\", line 208, in __call__\r\n    await super().__call__(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/applications.py\", line 112, in __call__\r\n    await self.middleware_stack(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/middleware/errors.py\", line 181, in __call__\r\n    raise exc\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/middleware/errors.py\", line 159, in __call__\r\n    await self.app(scope, receive, _send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/middleware/base.py\", line 57, in __call__\r\n    task_group.cancel_scope.cancel()\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/anyio/_backends/_asyncio.py\", line 567, in __aexit__\r\n    raise exceptions[0]\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/anyio/_backends/_asyncio.py\", line 604, in _run_wrapped_task\r\n    await coro\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/middleware/base.py\", line 30, in coro\r\n    await self.app(scope, request.receive, send_stream.send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/exceptions.py\", line 82, in __call__\r\n    raise exc\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/exceptions.py\", line 71, in __call__\r\n    await self.app(scope, receive, sender)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/routing.py\", line 656, in __call__\r\n    await route.handle(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/routing.py\", line 259, in handle\r\n    await self.app(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/routing.py\", line 64, in app\r\n    await response(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/responses.py\", line 139, in __call__\r\n    await send({\"type\": \"http.response.body\", \"body\": self.body})\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/exceptions.py\", line 68, in sender\r\n    await send(message)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/anyio/streams/memory.py\", line 205, in send\r\n    raise BrokenResourceError\r\nanyio.BrokenResourceError\r\n[2021-10-20 01:50:45 +0000] [5117] [ERROR] Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/uvicorn/protocols/http/httptools_impl.py\", line 375, in run_asgi\r\n    result = await app(self.scope, self.receive, self.send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/uvicorn/middleware/proxy_headers.py\", line 75, in __call__\r\n    return await self.app(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/fastapi/applications.py\", line 208, in __call__\r\n    await super().__call__(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/applications.py\", line 112, in __call__\r\n    await self.middleware_stack(scope, receive, send)\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/middleware/errors.py\", line 181, in __call__\r\n    raise exc\r\n  File \"/lxcshared/benchmark.git/Python/src/.venv/site-packages/starlette/middleware/errors.py\", line 159, in __call__\r\n    await self.app(", "source": "issue", "type": "qa_comprehensive", "issue_number": 18}
{"instruction": "Dependency Injection - Singleton?\n\nDetails:\n**Don't you think the dependency injection framework needs a singleton type?**\r\n\r\nI checked the documentation and as I can see there is no option for creating a class as a singleton. If I want to pass in a class as a dependency it will be created every time. So a feature to create singleton and if that already exists just pass it in as a dependency would be great. Because if you create a huge dependency tree than you have to specify one-by-one to make singletons. \r\n\r\nMaybe I missed something how to do that but if not that could be a new feature.", "input": "Repository: FastAPI\nLabels: ", "output": "I think the easiest way to achieve this would be to put a `functools.lru_cache` on a function that returns an instance of the class, and use that as your dependency. Would that work for you?\r\n\r\nIf that doesnâ€™t work for you there may be another (related) approach that does (likely involving the metaclass), but I donâ€™t see why this should be a fastapi feature if you can just make the class itself a singleton.", "source": "issue", "type": "qa_best_answer", "issue_number": 17}
{"instruction": "Provide a comprehensive answer to this question: Dependency Injection - Singleton?", "input": "**Don't you think the dependency injection framework needs a singleton type?**\r\n\r\nI checked the documentation and as I can see there is no option for creating a class as a singleton. If I want to pass in a class as a dependency it will be created every time. So a feature to create singleton and if that already exists just pass it in as a dependency would be great. Because if you create a huge dependency tree than you have to specify one-by-one to make singletons. \r\n\r\nMaybe I missed something how to do that but if not that could be a new feature.", "output": "I think the easiest way to achieve this would be to put a `functools.lru_cache` on a function that returns an instance of the class, and use that as your dependency. Would that work for you?\r\n\r\nIf that doesnâ€™t work for you there may be another (related) approach that does (likely involving the metaclass), but I donâ€™t see why this should be a fastapi feature if you can just make the class itself a singleton.\n\n---\n\ncan't remember for certain but I thought @tiangolo had implemented a cache mechanism for dependencies where it's called only once, am I confused ?\n\n---\n\nseems like it's in [0.28](https://github.com/tiangolo/fastapi/releases/tag/0.28.0) is there a difference with what you want to achieve ? I may have misunderstood the goal obviously, but it seems like it's called once already\n\n---\n\n@euri10 My interpretation was that @Gui-greg wanted it to be a singleton across multiple requests (i.e., the state is shared across all requests); the caching mechanism just prevents the dependency from being called multiple times within the *same* request.\n\n---\n\nagreed @dmontagu , I read it too fast.\r\nanother option then could be to instantiate your class dependency once in the `app.on_event(\"startup\")`", "source": "issue", "type": "qa_comprehensive", "issue_number": 17}
{"instruction": "Use of socket.io\n\nDetails:\n**Description**\r\n\r\nHow can I use socket.io instead of the plain websocket integration? I guess this is more a question belonging to starlette.\r\n\r\nCurrently migrating from a flask application using flask-socketio / python-socketio\r\n\r\nAny hint is appreciated. Thx.", "input": "Repository: FastAPI\nLabels: ", "output": "Socket-IO has an ASGI compatible app: https://python-socketio.readthedocs.io/en/latest/server.html#uvicorn-daphne-and-other-asgi-servers\r\n\r\nYou should be able to mount that app like if it was a FastAPI sub-application: https://fastapi.tiangolo.com/tutorial/sub-applications-proxy/#mount-the-sub-application", "source": "issue", "type": "qa_best_answer", "issue_number": 16}
{"instruction": "Provide a comprehensive answer to this question: Use of socket.io", "input": "**Description**\r\n\r\nHow can I use socket.io instead of the plain websocket integration? I guess this is more a question belonging to starlette.\r\n\r\nCurrently migrating from a flask application using flask-socketio / python-socketio\r\n\r\nAny hint is appreciated. Thx.", "output": "Socket-IO has an ASGI compatible app: https://python-socketio.readthedocs.io/en/latest/server.html#uvicorn-daphne-and-other-asgi-servers\r\n\r\nYou should be able to mount that app like if it was a FastAPI sub-application: https://fastapi.tiangolo.com/tutorial/sub-applications-proxy/#mount-the-sub-application\n\n---\n\nHi,\r\n\r\nAlso have a question regarding python-socketio, Ive tried:\r\n\r\n ```\r\nsio = socketio.AsyncServer(async_mode='asgi')\r\nsio_asgi_app = socketio.ASGIApp(sio, app)\r\napp.mount(\"/api/socket.io\", sio_asgi_app)\r\n```\r\n\r\nWhich does indeed seem to work, but only partially. Only GET requests seems to get through \r\nand POST's are somehow blocked, I get:\r\n\r\n```\r\nINFO:uvicorn:('127.0.0.1', 51888) - \"GET /api/socket.io/ HTTP/1.1\" 200\r\nINFO:uvicorn:('127.0.0.1', 51890) - \"POST /api/socket.io/ HTTP/1.1\" 405\r\n```\r\nIs there a way to also allow POST on `/api/socket.io/` ?\r\n\r\nThanks\n\n---\n\nI am unable to get this to work at all, even with the snippet above.\n\n---\n\nI see, here is my complete example,\r\n\r\n```\r\n    app = FastAPI(debug=True)\r\n    sio = socketio.AsyncServer(async_mode='asgi')\r\n    sio_asgi_app = socketio.ASGIApp(sio, app, socketio_path=\"/api/socket.io\")\r\n\r\n    app.mount(\"/api/socket.io\", sio_asgi_app)\r\n    sio.register_namespace(ws.ConnectNS('/'))\r\n```\r\n\r\nWhere the `ws` module contains:\r\n```\r\n\r\nclass ConnectNS(socketio.AsyncNamespace):\r\n    def on_connect(self, sid, environ):\r\n        logging.debug(\"Websocket connected %s\", sid)\r\n\r\n    def on_disconnect(self, sid):\r\n        logging.debug(\"Websocket disconnected %s\" % sid)\r\n```\r\nI then run uvicorn with the `app` object, running it with `sio_asgi_app` works fine but the `FastAPI` app does not receive any traffic.\r\n\r\nIt seems that the routing mechanism in either FastAPI ot Starlette somehow only allows GET requests, but I might be wrong and I'm maybe doing something else wrong.\r\n\r\n@BlackHoleFox: it did not work at all for me either until I noticed that second parameter of `ASGIApp`, which gets me to the currently partially working state ...\n\n---\n\nFinally,\r\n\r\n\r\n```app = FastAPI(debug=True)\r\n    sio = socketio.AsyncServer(async_mode='asgi')\r\n    sio_asgi_app = socketio.ASGIApp(sio, app, socketio_path=\"/api/socket.io\")\r\n    sio.register_namespace(ws.ConnectNS('/'))\r\n```\r\n\r\nWorks just fine if you use the `ASGIApp` object, It might maybe have other consequences but it seems\r\nto work fine for me so far. I had some other issues with the routing in my example application making it fail the first time i tried. I never got `app.mount(\"/api/socket.io\", sio_asgi_app)` to work properly though.", "source": "issue", "type": "qa_comprehensive", "issue_number": 16}
{"instruction": "using external oAuth providers\n\nDetails:\nHi,\r\n\r\nFirst of all, thank you for all the amazing work you've done with FastAPI. I'm just scratching the surface and I'm already amazed by what you're able to do right out of the box.\r\n\r\nAs for my question, At my institute we use a centralized authentication service for all webapps base on [ORY Hydra](https://github.com/ory/hydra). Is there an easy way built in to integrate an external server to authenticate again and use the token query the API?\r\n\r\nThanks\r\nM", "input": "Repository: FastAPI\nLabels: ", "output": "To clarify, the app structure should look a bit like this (super simplified)\r\n\r\n![image](https://user-images.githubusercontent.com/11850640/51682864-bf11cf80-1fe8-11e9-8d7c-fea1fc3d2801.png)\r\n\r\n\r\nCheers\r\nM", "source": "issue", "type": "qa_best_answer", "issue_number": 15}
{"instruction": "Provide a comprehensive answer to this question: using external oAuth providers", "input": "Hi,\r\n\r\nFirst of all, thank you for all the amazing work you've done with FastAPI. I'm just scratching the surface and I'm already amazed by what you're able to do right out of the box.\r\n\r\nAs for my question, At my institute we use a centralized authentication service for all webapps base on [ORY Hydra](https://github.com/ory/hydra). Is there an easy way built in to integrate an external server to authenticate again and use the token query the API?\r\n\r\nThanks\r\nM", "output": "To clarify, the app structure should look a bit like this (super simplified)\r\n\r\n![image](https://user-images.githubusercontent.com/11850640/51682864-bf11cf80-1fe8-11e9-8d7c-fea1fc3d2801.png)\r\n\r\n\r\nCheers\r\nM\n\n---\n\nHey @matthdsm ,\r\n\r\nThis particular set of docs and examples should get you pretty far:\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/security/simple-oauth2/ \r\nhttps://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/\r\n\r\nYou also get an interactive way to test all this out too. \r\n![image](https://user-images.githubusercontent.com/13604961/51725656-9a8e1580-2031-11e9-8042-d4d1ff6601ad.png)\r\n(taken from the docs above)\r\n\r\nThe only piece missing (I assume, based on  your chart) would be an ```async def``` that implements a request to your external service to check the token and user. If it were me, I'd swap out the parts I need from this guy:\r\n\r\n```python\r\nasync def get_current_user(token: str = Security(oauth2_scheme)):\r\n    try:\r\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\r\n        token_data = TokenPayload(**payload)\r\n    except PyJWTError:\r\n        raise HTTPException(\r\n            status_code=HTTP_403_FORBIDDEN, detail=\"Could not validate credentials\"\r\n        )\r\n\r\n    #use something like requests.get and pass your payload here probably\r\n    user = get_user(fake_users_db, username=token_data.username)\r\n    return user\r\n```\r\n\r\n\r\nSide note: if you're coming from Django or Flask, most people reuse or enforce auth using the decorator pattern (i.e. @requires_auth). @tiangolo 's examples above show a much easier and traceable way using ```Depends```. It's _**asynchronous time-traveling chain-lightning black magic**_ and it totally rocks imo. I bring this up because you may want to reuse parts of it in your auth flow too.\r\n\r\nHope that helps, but I'll stick around if you run into probs or have more specific questions.\n\n---\n\n> First of all, thank you for all the amazing work you've done with FastAPI. I'm just scratching the surface and I'm already amazed by what you're able to do right out of the box.\r\n\r\nThat's awesome to hear @matthdsm !\r\n\r\nAlso, thanks for taking the time to create the diagram and explain the use case so clearly.\r\n\r\n@rcox771 Awesome response! Thanks for sticking around and helping here :smile: :taco: \r\n\r\n> It's **asynchronous time-traveling chain-lightning black magic** and it totally rocks imo.\r\n\r\nLoved that, I'm citing it :joy: :grin: \r\n\r\n---\r\n\r\nSome more info:\r\n\r\nPretty much what @rcox771 explained.\r\n\r\nLet's say the function `get_user` doesn't take the parameters in the example, and actually goes and calls Hydra's [OpenId Connect UserInfo](https://www.ory.sh/docs/next/hydra/sdk/api#openid-connect-userinfo) endpoint, most probably using [Requests](http://docs.python-requests.org/en/master/), and then returns a Pydantic model with the user data (if you use a Pydantic model you can have all the completion, type checks, etc). Then you pretty much have the rest already from those examples.\r\n\r\nOne little detail: as Requests doesn't use `async` in the current versions, you would declare `def get_current_user` with a normal `def` instead of `async def`.\r\n\r\n---\r\n\r\nMore technical details (this is about to get pretty technical with specs stuff):\r\n\r\nSpecifically for your use case that is a bit more \"elaborate\", FastAPI has some other utilities that you can use for advanced OAuth2 flows, that are not in the tutorials but are there available for these cases.\r\n\r\nThe tutorials use the OAuth2 Password Flow. Which is the one appropriate when the same FastAPI application is the \"Authorization Server\" and the \"Resource Server\" (using [OAuth 2.0 spec terms](https://tools.ietf.org/html/rfc6749)). That's the simplest case that works for the simplest/more common scenarios.\r\n\r\nIn your case, your FastAPI application would be the \"Resource Server\", but Hydra would be the \"Authorization Server\".\r\n\r\nIn this case, you would probably use the \"Authorization Code\" or the \"Impicit\" OAuth 2.0 flows.\r\n\r\nAs Hydra is OpenId Connect compatible, you might want to use [`fastapi.security.open_id_connect_url.OpenIdConnect`](https://github.com/tiangolo/fastapi/blob/master/fastapi/security/open_id_connect_url.py#L8).\r\n\r\nAnd instead of using `OAuth2PasswordBearer`, you would use [`OAuth2`](https://github.com/tiangolo/fastapi/blob/master/fastapi/security/oauth2.py#L114) directly.\r\n\r\n`OAuth2` receives a `flows` parameter with your OAuth 2.0 flows, you can define them as a simple dictionary, but also using the included Pydantic models...\r\n\r\nFastAPI, although not documented, includes Pydantic models for the whole OpenAPI 3.0 spec, this might help you if you want to use completion, etc during development. And it includes, of course, all the models for OAuth 2.0 flows, etc. You can use them from here: https://github.com/tiangolo/fastapi/blob/master/fastapi/openapi/models.py#L291\r\n\r\nThere are models for all the OAuth 2.0 flows, also made to match the OpenAPI 3.0 spec (and the way it's sub-divided in sections):\r\n\r\n* `OAuthFlowImplicit`: :heavy_check_mark: this is the one where your frontend gets the token directly with the authentication. And then sends it to the FastAPI backend.\r\n* `OAuthFlowPassword`: :x: this probably doesn't apply to you, because the frontend sends the password to Hydra directly, not to FastAPI.\r\n* `OAuthFlowClientCredentials`: :x: I guess this doesn't apply either, as your public frontend is the one authenticating your users, not a secure backend.\r\n* `OAuthFlowAuthorizationCode`: :heavy_check_mark: this is when your frontend gets a \"code\" that sends to your FastAPI backend, and then your FastAPI backend uses that code with secret client credentials to call Hydra to get a token that it can actually use to perform operations (again calling Hydra) like authenticating and getting user info. This is the most complex flow.\r\n\r\n---\r\n\r\nAll this OAuth 2.0 stuff gets hairy, abstract and not very easy to understand quickly. If you are an expert in OAuth 2.0 with all it covers already (wow, congrats), I'm probably talking (writing) too much already and you know what to do.\r\n\r\nBut I personally don't know anyone that knows and understands deeply all OAuth 2.0 with all its abstractions, flows, etc. :joy: \r\n\r\nMy suggestion is, build something quick that you can throw away using the basic OAuth 2.0 tutorial. Just to get your hands dirty and check that you have the basics working (debug any unrelated errors). This should take you 15 minutes (less?) if you do the OAuth 2.0 tutorial in FastAPI's docs.\r\n\r\nThen, after that, use the `OAuthFlowImplicit` (the simplest one that applies for your case).\r\n\r\nIf needed, then implement the `OAuthFlowAuthorizationCode`, but I think that's not very common.\n\n---\n\nI guess what I'm wondering, without going too far down the OAuth rabbits hole, is how to enable both a password bearer scheme for local authentication as well as an OpenID Connect scheme for federated authentication.\r\n\r\nSo for example to let someone login either via Google or local username/password bearer, would I define one `def async` with two token arguments, one based on `OAuth2PasswordBearer` (but that wouldn't raise an error on no token being there), one based on regular OAuth2?\n\n---\n\n@kkinder `OAuth2PasswordBearer` is just a utility that inherits from `OAuth2`: https://github.com/tiangolo/fastapi/blob/master/fastapi/security/oauth2.py#L130, extracts the bearer token and sets the OAuth2 `flows` to `password`.\r\n\r\nIn your case, you could create a custom `CustomOAuth2` (or similar) that inherits from [`OAuth2`](https://github.com/tiangolo/fastapi/blob/master/fastapi/security/oauth2.py#L114) directly and that gets the token from the request, checks if it's a password token and if not, checks if it's an OAuth2 token generated from an OpenID service.\r\n\r\nFor it, you would create the `flows` dictionary including `password` and the other type of flow used by your service (defined by the OpenID provider), e.g. `implicit`.\r\n\r\nTo parse the token in the case it was a", "source": "issue", "type": "qa_comprehensive", "issue_number": 15}
{"instruction": "Passing UploadFile objects into a StreamingResponse closes it in v0.106.0 but not v0.105.0\n\nDetails:\n### Discussed in https://github.com/tiangolo/fastapi/discussions/10856\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **adrwz** December 28, 2023</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nasync def upload_file_event(files: List[UploadFile]):\r\n    print(\"2\", files[0].filename, files[0].file._file.closed)\r\n\r\n    # ... more code ...\r\n\r\n\r\n@router.post(\"/upload_session_file\")\r\nasync def upload_file(files: List[UploadFile] = File(...)):\r\n    print(\"1\", files[0].filename, files[0].file._file.closed)\r\n\r\n    try:\r\n        return StreamingResponse(\r\n            upload_file_event(files),\r\n            media_type=\"text/event-stream\",\r\n        )\r\n    except Exception as error:\r\n        logging.error(error)\r\n        raise HTTPException(status_code=500, detail=\"Internal Server Error\")\r\n```\r\n\r\n\r\n### Description\r\n\r\nHitting this endpoint with an uploaded file on v0.105.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename false\r\n```\r\n\r\nHitting this endpoint with an uploaded file on v0.106.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename true\r\n```\r\n\r\nUnfortunately this means I'm unable to upload files in a StreamingResponse with fastapi>=0.106.0\r\n\r\n### Operating System\r", "input": "Repository: FastAPI\nLabels: ", "output": "Is there any update on this issue? I have the same problem , just migrated from `v0.103.0` to `v0.108.0` and realized my tests are failing due the same issue. Is is related to [this breaking change](https://fastapi.tiangolo.com/release-notes/#01060)? \r\nIf yes, what is the proposed approach for handling the UploadFile in the background task?\r\nmy old practice is written below\r\n``` python\r\n\r\nasync def upload_csv_to_gcloud_blob_storage(\r\n    self, file: UploadFile, bucket_name: str, blob_storage_path:str\r\n):\r\n    \"\"\"write the data to a bucket with\"\"\"\r\n    storage_client = storage.Client()\r\n    csv_bucket = storage_client.bucket(bucket_name)\r\n    blob = csv_bucket.blob(blob_storage_path)\r\n\r\n    try:\r\n        with blob.open(\"wb\") as buffer:\r\n            shutil.copyfileobj(file.file, buffer)\r\n    finally:\r\n        file.file.close()\r\n            \r\n@app.post( \"/csv_tables\" )\r\nasync def upload_csv(\r\n    csv_file: Annotated[UploadFile, File()],\r\n    background_tasks: BackgroundTasks,\r\n):\r\n  \r\n    background_tasks.add_task(\r\n        upload_csv_to_gcloud_blob_storage,\r\n        csv_file=csv_file,\r\n        bucket_name=\"csv\",\r\n        blob_storage_path=\"csv_path\",\r\n    )\r\n    return \"OK\"\r\n```", "source": "issue", "type": "qa_best_answer", "issue_number": 14}
{"instruction": "Provide a comprehensive answer to this question: Passing UploadFile objects into a StreamingResponse closes it in v0.106.0 but not v0.105.0", "input": "### Discussed in https://github.com/tiangolo/fastapi/discussions/10856\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **adrwz** December 28, 2023</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nasync def upload_file_event(files: List[UploadFile]):\r\n    print(\"2\", files[0].filename, files[0].file._file.closed)\r\n\r\n    # ... more code ...\r\n\r\n\r\n@router.post(\"/upload_session_file\")\r\nasync def upload_file(files: List[UploadFile] = File(...)):\r\n    print(\"1\", files[0].filename, files[0].file._file.closed)\r\n\r\n    try:\r\n        return StreamingResponse(\r\n            upload_file_event(files),\r\n            media_type=\"text/event-stream\",\r\n        )\r\n    except Exception as error:\r\n        logging.error(error)\r\n        raise HTTPException(status_code=500, detail=\"Internal Server Error\")\r\n```\r\n\r\n\r\n### Description\r\n\r\nHitting this endpoint with an uploaded file on v0.105.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename false\r\n```\r\n\r\nHitting this endpoint with an uploaded file on v0.106.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename true\r\n```\r\n\r\nUnfortunately this means I'm unable to upload files in a StreamingResponse with fastapi>=0.106.0\r\n\r\n### Operating System\r", "output": "Is there any update on this issue? I have the same problem , just migrated from `v0.103.0` to `v0.108.0` and realized my tests are failing due the same issue. Is is related to [this breaking change](https://fastapi.tiangolo.com/release-notes/#01060)? \r\nIf yes, what is the proposed approach for handling the UploadFile in the background task?\r\nmy old practice is written below\r\n``` python\r\n\r\nasync def upload_csv_to_gcloud_blob_storage(\r\n    self, file: UploadFile, bucket_name: str, blob_storage_path:str\r\n):\r\n    \"\"\"write the data to a bucket with\"\"\"\r\n    storage_client = storage.Client()\r\n    csv_bucket = storage_client.bucket(bucket_name)\r\n    blob = csv_bucket.blob(blob_storage_path)\r\n\r\n    try:\r\n        with blob.open(\"wb\") as buffer:\r\n            shutil.copyfileobj(file.file, buffer)\r\n    finally:\r\n        file.file.close()\r\n            \r\n@app.post( \"/csv_tables\" )\r\nasync def upload_csv(\r\n    csv_file: Annotated[UploadFile, File()],\r\n    background_tasks: BackgroundTasks,\r\n):\r\n  \r\n    background_tasks.add_task(\r\n        upload_csv_to_gcloud_blob_storage,\r\n        csv_file=csv_file,\r\n        bucket_name=\"csv\",\r\n        blob_storage_path=\"csv_path\",\r\n    )\r\n    return \"OK\"\r\n```\n\n---\n\nWe ran into this issue. Calling `file.read()` in code our began raising an error after upgrading fastapi: `ValueError: I/O operation on closed file.`\n\n---\n\nI'm having similar issue with a tempfile I'm yielding....\r\n\r\n```\r\ndef create_temp_file():\r\n    fd, path = tempfile.mkstemp(suffix='.csv')\r\n    try:\r\n        yield fd, path\r\n    finally:\r\n        os.unlink(path)\r\n```\r\n\r\n\r\nWhen I try to return the file in a FileResponse I hit:\r\n`RuntimeError(f\"File at path {self.path} does not exist.\")`\n\n---\n\n> Is there any update on this issue? I have the same problem , just migrated from `v0.103.0` to `v0.108.0` and realized my tests are failing due the same issue. Is is related to [this breaking change](https://fastapi.tiangolo.com/release-notes/#01060)? If yes, what is the proposed approach for handling the UploadFile in the background task? my old practice is written below\r\n\r\nIt seems to be, removing this line prevent the file in the body from being closed: https://github.com/tiangolo/fastapi/blob/958425a899642d1853a1181a3b89dcb07aabea4f/fastapi/routing.py#L231\r\n\r\nIt was introduced in the only commit changing the code between versions 105 and 106:\r\nhttps://github.com/tiangolo/fastapi/commit/a4aa79e0b4cacc6b428d415d04d234a8c77af9d5#diff-4d573079004a9f3d148baa4658e68e82b8a3d1a95d603fee8177daa92cf65c93R231\r\n\r\nUnfortunately the `get_request_handler` is not trivial, so I cannot create PR without a bit of help.\n\n---\n\nI went through the `get_request_handler` function again and maybe the behavior is intentional? I don't know. Anyway the problem is that it simply runs the endpoint handler:\r\nhttps://github.com/tiangolo/fastapi/blob/958425a899642d1853a1181a3b89dcb07aabea4f/fastapi/routing.py#L294\r\nand then closes the file. But in case the handler is asynchronous, like a background task:\r\n```python\r\n@app.post(...)\r\nasync def foo():\r\n   background_tasks.add_task(process_recording_file, file=file, ...)\r\n```\r\nit closes the file before the task can actually run. So I created a deep copy like this:\r\n```diff\r\n-background_tasks.add_task(process_recording_file, file=file, ...)\r\n+background_tasks.add_task(process_recording_file, file=copy.deepcopy(file), ...)\r\n```\r\nand I close the file myself in the function:\r\n```python\r\nasync def process_recording_file(file: UploadFile...):\r\n    try:\r\n        ...\r\n    finally:\r\n        await file.close()\r\n```\r\nwhich fixes the issue even with the newest version of FastAPI. It is probably not very efficient given that the file is few MB in my case.\r\n\r\nSo maybe a better question would be, what is the expected usage of UploadFile combined with BackgroundTasks? https://fastapi.tiangolo.com/tutorial/background-tasks/", "source": "issue", "type": "qa_comprehensive", "issue_number": 14}
{"instruction": "Debug and solve this technical issue: Passing UploadFile objects into a StreamingResponse closes it in v0.106.0 but not v0.105.0", "input": "### Discussed in https://github.com/tiangolo/fastapi/discussions/10856\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **adrwz** December 28, 2023</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nasync def upload_file_event(files: List[UploadFile]):\r\n    print(\"2\", files[0].filename, files[0].file._file.closed)\r\n\r\n    # ... more code ...\r\n\r\n\r\n@router.post(\"/upload_session_file\")\r\nasync def upload_file(files: List[UploadFile] = File(...)):\r\n    print(\"1\", files[0].filename, files[0].file._file.closed)\r\n\r\n    try:\r\n        return StreamingResponse(\r\n            upload_file_event(files),\r\n            media_type=\"text/event-stream\",\r\n        )\r\n    except Exception as error:\r\n        logging.error(error)\r\n        raise HTTPException(status_code=500, detail=\"Internal Server Error\")\r\n```\r\n\r\n\r\n### Description\r\n\r\nHitting this endpoint with an uploaded file on v0.105.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename false\r\n```\r\n\r\nHitting this endpoint with an uploaded file on v0.106.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename true\r\n```\r\n\r\nUnfortunately this means I'm unable to upload files in a StreamingResponse with fastapi>=0.106.0\r\n\r\n### Operating System\r\n\r\nmacOS\r\n\r\n### Operating System Details\r\n\r\n_No response_\r\n\r\n### FastAPI Version\r\n\r\n0.105.0\r\n\r\n### Pydantic Version\r\n\r\n2.5.3\r\n\r\n### Python Version\r\n\r\n3.11.4\r\n\r\n### Additional Context\r\n\r\n_No response_</div>", "output": "Is there any update on this issue? I have the same problem , just migrated from `v0.103.0` to `v0.108.0` and realized my tests are failing due the same issue. Is is related to [this breaking change](https://fastapi.tiangolo.com/release-notes/#01060)? \r\nIf yes, what is the proposed approach for handling the UploadFile in the background task?\r\nmy old practice is written below\r\n``` python\r\n\r\nasync def upload_csv_to_gcloud_blob_storage(\r\n    self, file: UploadFile, bucket_name: str, blob_storage_path:str\r\n):\r\n    \"\"\"write the data to a bucket with\"\"\"\r\n    storage_client = storage.Client()\r\n    csv_bucket = storage_client.bucket(bucket_name)\r\n    blob = csv_bucket.blob(blob_storage_path)\r\n\r\n    try:\r\n        with blob.open(\"wb\") as buffer:\r\n            shutil.copyfileobj(file.file, buffer)\r\n    finally:\r\n        file.file.close()\r\n            \r\n@app.post( \"/csv_tables\" )\r\nasync def upload_csv(\r\n    csv_file: Annotated[UploadFile, File()],\r\n    background_tasks: BackgroundTasks,\r\n):\r\n  \r\n    background_tasks.add_task(\r\n        upload_csv_to_gcloud_blob_storage,\r\n        csv_file=csv_file,\r\n        bucket_name=\"csv\",\r\n        blob_storage_path=\"csv_path\",\r\n    )\r\n    return \"OK\"\r\n```", "source": "issue", "type": "qa_technical", "issue_number": 14}
{"instruction": "Provide timing data for things FastAPI does outside of user code\n\nDetails:\n**Is your feature request related to a problem? Please describe.**\r\nI currently find myself using FastAPI as an API frontend for a database running queries of varying levels of complexity that usually return fairly large quantities of data. The problem I have is that, when attempting to figure out why an API request is taking time to respond, there's a lot going on outside of what fencing the code inside your route with the usual `time_start = time.time()`, `time_delta = time.time() - time_start` won't tell you.\r\n\r\nIn your average FastAPI application, there's 4 main causes for slowdowns:\r\n* Endpoint code running (app)\r\n* Waiting for the database (io)\r\n* Data validation (pydantic)\r\n* Data serialization (json/ujson)\r\n\r\nOf those 4, only the first two are actually part of the user code, the other two are handled behind the scenes by FastAPI. If I'm testing a route that's returning 50MBs of JSON (for whatever reason), it's actually rather tricky to determine whether switching from `json` to `ujson` or `orjson` will have any performance benefit or if the slowdown is coming from Pydantic choking on the sheer amount of data being fed to it or the database being slow.\r\n\r\n**Describe the solution you'd like**\r\nGiven FastAPI is performing operations outside of what the user can observe or measure, it should probably expose timing data for those things in some way (especially validation and serialization, since I doubt routing is going to factor a lot in the processing time). I don't know how the implementation should go, though, given any middleware is only going to receive a Starlette `Response` object and FastAPI probably shouldn't be doing this sort of thing automatically anymore than it does with CORS. The `Response` object could probably be extended in some way to contain some sort of `timing` dict, though that's sure to cause all sorts of compatibility issues, so I don't know whether that can be done without some upstream work with Starlette.\r\n\r\n**Describe alternatives yo", "input": "Repository: FastAPI\nLabels: ", "output": "A couple tangential profiling-related notes that may be of interest to anyone working with \"50MBs of JSON\"-sized payloads:\r\n<details>\r\n    <summary>Click to expand</summary>\r\n\r\n* Serialization may *also* involve two (potentially very costly!) steps: 1) if specifying a `response_model`, where the returned data is parsed into the `response_model`, and 2) in all cases unless you return a `Response` directly, where `fastapi.encoders.jsonable_encoder` is used to convert your output to json.\r\n    * For payloads with long lists or dicts with many keys this function call is not cheap, and unless you return a `Response` or one of its subclasses from your endpoint, in most cases, the cost of `jsonable_encoder` will probably dwarf the call to `json.dumps` or faster alternatives from other packages.\r\n* For faster creation of pydantic model instances, consider using `BaseModel.construct` if you *know* the input data doesn't require parsing (e.g., whenever you perform the instantiation yourself in a type-safe way, rather than relying on fastapi's parsing machinery).\r\n    * I profiled this method at ~30-40x faster than calls to `BaseModel.__init__`, even for relatively small payloads.\r\n    * The API is a little awkward in pydantic v0.32.2 since you have to pass the values as a dict (and have to specify the fields set), but starting in v1 it has the same API as the `__init__` calls and is even type-checked by the pydantic mypy plugin (a good reason for FastAPI to update to pydantic v1 as soon as possible!).\r\n</details>\r\n\r\n-----\r\n\r\nAddressing the main point brought up in this issue, I think it might be worth looking into [yappi](https://github.com/sumerc/yappi) -- if you look at the docs for the [get_func_stats](https://github.com/sumerc/yappi/blob/master/doc/api.md#get_func_statsfilternone) function and the [YFuncStat](https://github.com/sumerc/yappi/blob/master/doc/api.md#yfuncstat) class, it looks like it should be relatively easy to package up the profiling results inside an ASGI middleware. (Also, for what it's worth, it has built-in support in PyCharm.)\r\n\r\nI'm not very familiar with the `Server-Timing` header, but based on a quick skim of the linked docs, it seems that such a yappi ASGI middleware could return Server-Timing headers for each of its YFuncStat instances, presumably with some (configurable) filtering and formatting. (Obviously it could also just log the results to the console.)", "source": "issue", "type": "qa_best_answer", "issue_number": 13}
{"instruction": "Provide a comprehensive answer to this question: Provide timing data for things FastAPI does outside of user code", "input": "**Is your feature request related to a problem? Please describe.**\r\nI currently find myself using FastAPI as an API frontend for a database running queries of varying levels of complexity that usually return fairly large quantities of data. The problem I have is that, when attempting to figure out why an API request is taking time to respond, there's a lot going on outside of what fencing the code inside your route with the usual `time_start = time.time()`, `time_delta = time.time() - time_start` won't tell you.\r\n\r\nIn your average FastAPI application, there's 4 main causes for slowdowns:\r\n* Endpoint code running (app)\r\n* Waiting for the database (io)\r\n* Data validation (pydantic)\r\n* Data serialization (json/ujson)\r\n\r\nOf those 4, only the first two are actually part of the user code, the other two are handled behind the scenes by FastAPI. If I'm testing a route that's returning 50MBs of JSON (for whatever reason), it's actually rather tricky to determine whether switching from `json` to `ujson` or `orjson` will have any performance benefit or if the slowdown is coming from Pydantic choking on the sheer amount of data being fed to it or the database being slow.\r\n\r\n**Describe the solution you'd like**\r\nGiven FastAPI is performing operations outside of what the user can observe or measure, it should probably expose timing data for those things in some way (especially validation and serialization, since I doubt routing is going to factor a lot in the processing time). I don't know how the implementation should go, though, given any middleware is only going to receive a Starlette `Response` object and FastAPI probably shouldn't be doing this sort of thing automatically anymore than it does with CORS. The `Response` object could probably be extended in some way to contain some sort of `timing` dict, though that's sure to cause all sorts of compatibility issues, so I don't know whether that can be done without some upstream work with Starlette.\r\n\r\n**Describe alternatives yo", "output": "A couple tangential profiling-related notes that may be of interest to anyone working with \"50MBs of JSON\"-sized payloads:\r\n<details>\r\n    <summary>Click to expand</summary>\r\n\r\n* Serialization may *also* involve two (potentially very costly!) steps: 1) if specifying a `response_model`, where the returned data is parsed into the `response_model`, and 2) in all cases unless you return a `Response` directly, where `fastapi.encoders.jsonable_encoder` is used to convert your output to json.\r\n    * For payloads with long lists or dicts with many keys this function call is not cheap, and unless you return a `Response` or one of its subclasses from your endpoint, in most cases, the cost of `jsonable_encoder` will probably dwarf the call to `json.dumps` or faster alternatives from other packages.\r\n* For faster creation of pydantic model instances, consider using `BaseModel.construct` if you *know* the input data doesn't require parsing (e.g., whenever you perform the instantiation yourself in a type-safe way, rather than relying on fastapi's parsing machinery).\r\n    * I profiled this method at ~30-40x faster than calls to `BaseModel.__init__`, even for relatively small payloads.\r\n    * The API is a little awkward in pydantic v0.32.2 since you have to pass the values as a dict (and have to specify the fields set), but starting in v1 it has the same API as the `__init__` calls and is even type-checked by the pydantic mypy plugin (a good reason for FastAPI to update to pydantic v1 as soon as possible!).\r\n</details>\r\n\r\n-----\r\n\r\nAddressing the main point brought up in this issue, I think it might be worth looking into [yappi](https://github.com/sumerc/yappi) -- if you look at the docs for the [get_func_stats](https://github.com/sumerc/yappi/blob/master/doc/api.md#get_func_statsfilternone) function and the [YFuncStat](https://github.com/sumerc/yappi/blob/master/doc/api.md#yfuncstat) class, it looks like it should be relatively easy to package up the profiling results inside an ASGI middleware. (Also, for what it's worth, it has built-in support in PyCharm.)\r\n\r\nI'm not very familiar with the `Server-Timing` header, but based on a quick skim of the linked docs, it seems that such a yappi ASGI middleware could return Server-Timing headers for each of its YFuncStat instances, presumably with some (configurable) filtering and formatting. (Obviously it could also just log the results to the console.)\n\n---\n\n> A couple tangential profiling-related notes that may be of interest to anyone working with \"50MBs of JSON\"-sized payloads:\r\n\r\nAh, that's interesting, I'd usually just build my own `RawJSONResponse` class and handle json conversion on my own so I could bypass Pydantic entirely, but this is certainly much cleaner if you trust your input source.\r\n\r\n> Addressing the main point brought up in this issue, I think it might be worth looking into [yappi](https://github.com/sumerc/yappi) -- if you look at the docs for the [get_func_stats](https://github.com/sumerc/yappi/blob/master/doc/api.md#get_func_statsfilternone) function and the [YFuncStat](https://github.com/sumerc/yappi/blob/master/doc/api.md#yfuncstat) class, it looks like it should be relatively easy to package up the profiling results inside an ASGI middleware. (Also, for what it's worth, it has built-in support in PyCharm.)\r\n> \r\n> I'm not very familiar with the `Server-Timing` header, but based on a quick skim of the linked docs, it seems that such a yappi ASGI middleware could return Server-Timing headers for each of its YFuncStat instances, presumably with some (configurable) filtering and formatting. (Obviously it could also just log the results to the console.)\r\n\r\nThanks for pointing out yappi. I've tried the middleware solution with it, and while it's working well enough, it runs into the issue where, since profiling is global, if a route is called while another one is running, the profiler gets confused and the resulting profiling data will be incorrect or missing.\r\n\r\n```py\r\nfrom starlette.middleware.base import BaseHTTPMiddleware\r\nfrom starlette.responses import Response\r\nfrom starlette.requests import Request\r\n\r\nimport fastapi\r\nimport json\r\nimport sqlalchemy\r\n\r\nimport yappi\r\n\r\nclass BenchMiddleware(BaseHTTPMiddleware):\r\n    async def dispatch(self, request: Request, call_next) -> Response:\r\n        yappi.start()\r\n        response = await call_next(request)\r\n        yappi.stop()\r\n\r\n        #yappi.get_func_stats().sort('ttot', sort_order=\"desc\").print_all() # All time\r\n\r\n        db_exec_time = yappi.get_func_stats(dict(name=sqlalchemy.engine.base.Engine.execute.__qualname__))\r\n        #db_fetch_time = yappi.get_func_stats(dict(name=sqlalchemy.engine.result.ResultProxy.fetchone.__qualname__))\r\n        pydantic_time = yappi.get_func_stats(dict(name=fastapi.routing.serialize_response.__qualname__))\r\n        render_time = yappi.get_func_stats(dict(name=response.render.__qualname__))\r\n\r\n        server_timing = []\r\n\r\n        if not db_exec_time.empty():\r\n            server_timing.append(f\"db_exec;dur={(db_exec_time.pop().ttot * 1000):.3f}\")\r\n\r\n        if not pydantic_time.empty():\r\n            server_timing.append(f\"pydantic;dur={(pydantic_time.pop().ttot * 1000):.3f}\")\r\n\r\n        if not render_time.empty():\r\n            server_timing.append(f\"render;dur={(render_time.pop().ttot * 1000):.3f}\")\r\n\r\n        yappi.clear_stats()\r\n        response.headers[\"Server-Timing\"] = ','.join(server_timing)\r\n        return response\r\n```\r\n\r\nBecause of that, I doubt that can be \"correctly realized\" on an async framework like FastAPI using a regular profiler, since I'd ideally want to leave this sort of performance collection online to facilitate performance analysis in real-world use cases.\r\n\r\n`Server-Timing` is working as I'd hoped, though.\r\n\r\n![image](https://user-images.githubusercontent.com/516999/68608734-9b3d4e80-0481-11ea-82d2-890dbfbeeca8.png)\n\n---\n\nHaha, that's some heavy pydantic!\r\n\r\nYappi is able to track threads appropriately; I'm wondering if there is a way to use async contextvars in python 3.7 to achieve similar functionality. I'll look into it.\n\n---\n\nAha! It looks like you can override the context id callback with yappi!\r\n\r\nSee here: https://github.com/sumerc/yappi/blob/master/yappi.py#L938\r\n\r\nI think we could use a contextvar for this and should be able to get proper per-request profiling! (In Python >=3.7)\n\n---\n\n> Haha, that's some heavy pydantic!\r\n\r\nSeems like it's actually half `jsonable_encoder` and half `Field.validate`. But yeah, it's 6 or so sets of 9600 datapoints each, separated in arrays of 100 floats keyed by ISO8601 datetime. It's a good stress test, I'd say, even if common sense would advise to just return this as a CSV instead.\r\n\r\n\r\n> Aha! It looks like you can override the context id callback with yappi!\r\n> \r\n> See here: https://github.com/sumerc/yappi/blob/master/yappi.py#L938\r\n> \r\n> I think we could use a contextvar for this and should be able to get proper per-request profiling! (In Python >=3.7)\r\n\r\nYou seem to have a pretty clear idea of how that could be done. I haven't had the occasion to use contextvars yet, so could you show me how you would go about doing that?", "source": "issue", "type": "qa_comprehensive", "issue_number": 13}
{"instruction": "ApiKey Header documentation\n\nDetails:\nHi,\r\n\r\nDo you have some documentation or example regarding configuration for ApiKey (header) and how to verify it on FastAPI ?\r\n\r\nthanks in advance,\r\n\r\nRÃ©my.", "input": "Repository: FastAPI\nLabels: ", "output": "Hi @meandus - @tiangolo has a full example that includes that functionality:  https://github.com/tiangolo/full-stack-fastapi-postgresql/tree/cd112bd683dcb9017e5f84c0ed3e4974a52e5571/%7B%7Bcookiecutter.project_slug%7D%7D/backend/app/app\r\n\r\nand plenty of tutorial info here: https://fastapi.tiangolo.com/tutorial/security/intro/\r\n\r\nAlso - the Gitter channel is already pretty active for these types of questions: https://gitter.im/tiangolo/fastapi", "source": "issue", "type": "qa_best_answer", "issue_number": 12}
{"instruction": "Provide a comprehensive answer to this question: ApiKey Header documentation", "input": "Hi,\r\n\r\nDo you have some documentation or example regarding configuration for ApiKey (header) and how to verify it on FastAPI ?\r\n\r\nthanks in advance,\r\n\r\nRÃ©my.", "output": "Hi @meandus - @tiangolo has a full example that includes that functionality:  https://github.com/tiangolo/full-stack-fastapi-postgresql/tree/cd112bd683dcb9017e5f84c0ed3e4974a52e5571/%7B%7Bcookiecutter.project_slug%7D%7D/backend/app/app\r\n\r\nand plenty of tutorial info here: https://fastapi.tiangolo.com/tutorial/security/intro/\r\n\r\nAlso - the Gitter channel is already pretty active for these types of questions: https://gitter.im/tiangolo/fastapi\n\n---\n\nThanks @wshayes for your help here! Much appreciated as always :tada: \r\n\r\n@meandus if you can use OAuth2, that tutorial and the project generator might help. If somehow you explicitly need something different than OAuth2, with some custom APIKeyHeader (as defined in OpenAPI), yes, it is supported, but it is not properly documented yet.\r\n\r\nI suggest you check the security section in the docs shared by William, and after knowing how it works, if you need to explicitly use `APIKeyHeader` instead of OAuth2, you can `from fastapi.security.api_key import APIKeyHeader`.\r\n\r\nAt least while I update the docs with those specifics... :grin:\n\n---\n\nI found something in the library for apikey and looks good. But for the token (string defined) i dont know what is the best practice for that. Currently i can do a secret.cfg or a json file to store the key and permissions.\n\nI dont know high level of security for this part, thats why im using a apikey in header.\n\nRegards \n\nLe 9 avril 2019 20:42:23 GMT+02:00, \"SebastiÃ¡n RamÃ­rez\" <notifications@github.com> a Ã©crit :\n>Thanks @wshayes for your help here! Much appreciated as always :tada: \n>\n>@meandus if you can use OAuth2, that tutorial and the project generator\n>might help. If somehow you explicitly need something different than\n>OAuth2, with some custom APIKeyHeader (as defined in OpenAPI), yes, it\n>is supported, but it is not properly documented yet.\n>\n>I suggest you check the security section in the docs shared by William,\n>and after knowing how it works, if you need to explicitly use\n>`APIKeyHeader` instead of OAuth2, you can `from\n>fastapi.security.api_key import APIKeyHeader`.\n>\n>At least while I update the docs with those specifics... :grin: \n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/tiangolo/fastapi/issues/142#issuecomment-481380266\n\n-- \nEnvoyÃ© de mon appareil Android avec K-9 Mail. Veuillez excuser ma briÃ¨vetÃ©.\n\n---\n\n@meandus it depends mostly on your setup, how are you deploying, if you have CI, etc. These kinds of things normally go in environment variables. You can also put them in a file that you read. If the repo is public, then you don't commit that file, just use it during deployment.\r\n\r\nIf you use the project generators, those settings are read from environment variables, and are passed as environment variables by Docker, reading them from Docker config files.\n\n---\n\nHi !\n\nYes i did env_files. I cant use your docker full stack cause of business constraint but i did a similar stuff based ln your excelent work !\n\nLe 13 avril 2019 07:21:56 GMT+02:00, \"SebastiÃ¡n RamÃ­rez\" <notifications@github.com> a Ã©crit :\n>@meandus it depends mostly on your setup, how are you deploying, if you\n>have CI, etc. These kinds of things normally go in environment\n>variables. You can also put them in a file that you read. If the repo\n>is public, then you don't commit that file, just use it during\n>deployment.\n>\n>If you use the project generators, those settings are read from\n>environment variables, and are passed as environment variables by\n>Docker, reading them from Docker config files.\n>\n>-- \n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/tiangolo/fastapi/issues/142#issuecomment-482777730\n\n-- \nEnvoyÃ© de mon appareil Android avec K-9 Mail. Veuillez excuser ma briÃ¨vetÃ©.", "source": "issue", "type": "qa_comprehensive", "issue_number": 12}
{"instruction": "Debug and solve this technical issue: ApiKey Header documentation", "input": "Hi,\r\n\r\nDo you have some documentation or example regarding configuration for ApiKey (header) and how to verify it on FastAPI ?\r\n\r\nthanks in advance,\r\n\r\nRÃ©my.", "output": "Hi @meandus - @tiangolo has a full example that includes that functionality:  https://github.com/tiangolo/full-stack-fastapi-postgresql/tree/cd112bd683dcb9017e5f84c0ed3e4974a52e5571/%7B%7Bcookiecutter.project_slug%7D%7D/backend/app/app\r\n\r\nand plenty of tutorial info here: https://fastapi.tiangolo.com/tutorial/security/intro/\r\n\r\nAlso - the Gitter channel is already pretty active for these types of questions: https://gitter.im/tiangolo/fastapi", "source": "issue", "type": "qa_technical", "issue_number": 12}
{"instruction": "Korean translations\n\nDetails:\n### ðŸ‡°ðŸ‡· Korean translations (ko)\r\n\r\nI hope to translate the whole docs into Korean.  \r\nThis issue is opened to track the progress of Korean language translation.\r\n\r\nAny suggestion is welcome, and I will appreciate it. ðŸ˜ƒ \r\n\r\n### ðŸ“š Glossary\r\nUse [python official Korean glossary](https://docs.python.org/ko/3/glossary.html) for maintaining consistency.\r\n\r\nIf you can't find a proper word in the glossary, you can find it from https://www.flowdas.com/pages/python-docs-ko.html python Korean document maintainer, @flowdas, maintains.\r\n\r\nAlso, use less English as you can. For instance, at [ì²«ê±¸ìŒ](https://fastapi.tiangolo.com/ko/tutorial/first-steps/#_7)\r\n\r\n- PUT : ë°ì´í„°ë¥¼ ~ì—…ë°ì´íŠ¸~ìˆ˜ì •í•˜ê¸° ìœ„í•´\r\n\r\nSee https://github.com/tiangolo/fastapi/discussions/3167#discussioncomment-1502428 (Thanks, @0417taehyun)\r\n\r\n### âœðŸ» Writing style (2020-11-07 added)\r\në¹„ê²©ì‹ì²´(Informal)ì¸ í•´ìš”ì²´ë¥¼ ì§€ì–‘í•˜ê³  ê²©ì‹ì²´(Formal)ì¸ í•©ì‡¼ì²´ë¥¼ ì§€í–¥í•©ë‹ˆë‹¤.\r\n\r\ne.g.\r\n- ~ì´ì—ìš” (NOT Recommended)\r\n- ~ìž…ë‹ˆë‹¤.\r\n\r\n### ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Discussion (2021-05-04 added)\r\nI opened a discussion, https://github.com/tiangolo/fastapi/discussions/3167.\r\nIf you have a suggestion or an idea, please comment on it the discussion.\r\n\r\nOR\r\n\r\nYou can join [FastAPI Discord](https://discord.gg/VQjSZaeJmf) and talk to in `Korean` channel!\r\n\r\n### ðŸŽ PR Guide\r\nSee https://fastapi.tiangolo.com/contributing/#translations, please.\r\n\r\nYou don't have to get any permission. FastAPI is an open-source project.\r\nAnd I'm not an owner, just a contributor like anyone else.\r\nIf you want to contribute, do it right now!", "input": "Repository: FastAPI\nLabels: ", "output": "ë²ˆì—­ìž‘ì—…ì— ê¸°ì—¬í•˜ê³  ì‹¶ì€ë° í˜¹ì‹œ ê´€ë ¨ëœ ì†Œí†µ ì±„ë„ì´ ìžˆì„ê¹Œìš”?(deployment ë¶€ë¶„ë¶€í„° ì°¸ì—¬í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤.)", "source": "issue", "type": "qa_best_answer", "issue_number": 11}
{"instruction": "Provide a comprehensive answer to this question: Korean translations", "input": "### ðŸ‡°ðŸ‡· Korean translations (ko)\r\n\r\nI hope to translate the whole docs into Korean.  \r\nThis issue is opened to track the progress of Korean language translation.\r\n\r\nAny suggestion is welcome, and I will appreciate it. ðŸ˜ƒ \r\n\r\n### ðŸ“š Glossary\r\nUse [python official Korean glossary](https://docs.python.org/ko/3/glossary.html) for maintaining consistency.\r\n\r\nIf you can't find a proper word in the glossary, you can find it from https://www.flowdas.com/pages/python-docs-ko.html python Korean document maintainer, @flowdas, maintains.\r\n\r\nAlso, use less English as you can. For instance, at [ì²«ê±¸ìŒ](https://fastapi.tiangolo.com/ko/tutorial/first-steps/#_7)\r\n\r\n- PUT : ë°ì´í„°ë¥¼ ~ì—…ë°ì´íŠ¸~ìˆ˜ì •í•˜ê¸° ìœ„í•´\r\n\r\nSee https://github.com/tiangolo/fastapi/discussions/3167#discussioncomment-1502428 (Thanks, @0417taehyun)\r\n\r\n### âœðŸ» Writing style (2020-11-07 added)\r\në¹„ê²©ì‹ì²´(Informal)ì¸ í•´ìš”ì²´ë¥¼ ì§€ì–‘í•˜ê³  ê²©ì‹ì²´(Formal)ì¸ í•©ì‡¼ì²´ë¥¼ ì§€í–¥í•©ë‹ˆë‹¤.\r\n\r\ne.g.\r\n- ~ì´ì—ìš” (NOT Recommended)\r\n- ~ìž…ë‹ˆë‹¤.\r\n\r\n### ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Discussion (2021-05-04 added)\r\nI opened a discussion, https://github.com/tiangolo/fastapi/discussions/3167.\r\nIf you have a suggestion or an idea, please comment on it the discussion.\r\n\r\nOR\r\n\r\nYou can join [FastAPI Discord](https://discord.gg/VQjSZaeJmf) and talk to in `Korean` channel!\r\n\r\n### ðŸŽ PR Guide\r\nSee https://fastapi.tiangolo.com/contributing/#translations, please.\r\n\r\nYou don't have to get any permission. FastAPI is an open-source project.\r\nAnd I'm not an owner, just a contributor like anyone else.\r\nIf you want to contribute, do it right now!", "output": "ë²ˆì—­ìž‘ì—…ì— ê¸°ì—¬í•˜ê³  ì‹¶ì€ë° í˜¹ì‹œ ê´€ë ¨ëœ ì†Œí†µ ì±„ë„ì´ ìžˆì„ê¹Œìš”?(deployment ë¶€ë¶„ë¶€í„° ì°¸ì—¬í•˜ê³  ì‹¶ìŠµë‹ˆë‹¤.)\n\n---\n\n@SangRyul ë”°ë¡œ ì†Œí†µ ì±„ë„ì´ ìžˆì§€ ì•ŠìŠµë‹ˆë‹¤. ìžìœ ë¡­ê²Œ PR ë‚ ë ¤ì£¼ì‹œë©´ ë©ë‹ˆë‹¤.\r\nì¶”í›„ ì¸ì›ì´ ë§Žì•„ì§€ë©´ ìƒˆ discussion ì„ ë§Œë“¤ì–´ì„œ ë²ˆì—­ ìž‘ì—…ì´ ì¤‘ë³µë˜ì§€ ì•Šê²Œ í•˜ê±°ë‚˜ ìš©ì–´ ë²ˆì—­ë“¤ì— ëŒ€í•œ ì˜ê²¬ì„ ë‚˜ëˆ„ê³ ìž í•©ë‹ˆë‹¤.ðŸ˜\n\n---\n\në²ˆì—­ í˜‘ì—…ì— [git Localize](https://gitlocalize.com/) ë„ í•œë²ˆ ìƒê°í•´ë´ì£¼ì‹œë©´ ì¢‹ì„ê²ƒ ê°™ìŠµë‹ˆë‹¤. ì ë‹¹ížˆ ë–¨ì–´ì ¸ ìžˆëŠ” ë¬¸ì„œ ì°¸ì—¬í•´ë³´ê² ìŠµë‹ˆë‹¤!\n\n---\n\nì‹ ê·œ í”„ë¡œì íŠ¸ì— fastapi ë¥¼ ì‚¬ìš©í•˜ê³  ìžˆëŠ”ë°, feature ì˜ ë²ˆì—­ì•ˆëœ ë¶€ë¶„ë¶€í„° ì°¸ì—¬í•´ë³´ë ¤ê³  í•©ë‹ˆë‹¤!\n\n---\n\n@ParkDyel, @joosangkim\r\n\r\nhttps://fastapi.tiangolo.com/contributing/#translations PR ë²ˆì—­ ê°€ì´ë“œ ë¼ì¸ìž…ë‹ˆë‹¤.\r\nì´ í”„ë¡œì íŠ¸ëŠ” ëª¨ë‘ì—ê²Œ ì—´ë ¤ ìžˆìœ¼ë¯€ë¡œ ìžìœ ë¡­ê²Œ PR ë‚ ë¦¬ì‹œë©´ ë©ë‹ˆë‹¤:)", "source": "issue", "type": "qa_comprehensive", "issue_number": 11}
{"instruction": "Gunicorn Workers Hangs And Consumes Memory Forever\n\nDetails:\n**Describe the bug**\r\nI have deployed FastAPI which queries the database and returns the results. I made sure closing the DB connection and all. I'm running gunicorn with this line ;\r\n`gunicorn -w 8 -k uvicorn.workers.UvicornH11Worker -b 0.0.0.0 app:app --timeout 10`\r\nSo after exposing it to the web, I run a load test which makes 30-40 requests in parallel to the fastapi. And the problem starts here. I'm watching the 'HTOP' in the mean time and I see that RAM usage is always growing, seems like no task is killed after completing it's job. Then I checked the Task numbers, same goes for it too, seems like gunicorn workers do not get killed. After some time RAM usage gets at it's maximum, and starts to throw errors. So I killed the gunicorn app but the thing is processes spawned by main gunicorn proces did not get killed and still using all the memory. \r\n\r\n**Environment:**\r\n - OS:  Ubuntu 18.04\r\n - FastAPI Version : 0.38.1\r\n\r\n- Python version : 3.7.4", "input": "Repository: FastAPI\nLabels: ", "output": "You're using the PyPy compliant uvicorn worker class - is your system based on PyPy? If you're running on cpython then I suggest you try out the cpython implementation `uvicorn.workers.UvicornWorker`.  \r\n\r\nBut in other news, I'm seeing something similar. I just run uvicorn with this:\r\n`uvicorn --host 0.0.0.0 --port 7001 app:api --reload` but in some cases the memory is never freed up.\r\n\r\nFor example this function:\r\n```\r\n@api.post(\"/randompath\")\r\ndef get_xoxo(file: UploadFile = File(...)):\r\n    k = []\r\n    for i in range(10):\r\n        k.append('gab' * 9999999)\r\n```\r\nWhen I hit the endpoint once, the memory is cleared up, but when I hit it 10x, some of the memory is left allocated and when I hit it another 10x, even more memory is left allocated. This continues until I run out of memory or restart the process.\r\nIf I change the `get_xoxo` function to be `async`, then the memory is always cleared up, but the function also blocks much more (which makes sense since I'm not taking advantage of any `await`s in there).\r\n\r\nSo - is there a memory leak? I'm not sure, but something is handled incorrectly.\r\n\r\nMy system is running on `python:3.7` Docker container. Basically the same problem occurs in production where uvicorn is run with `uvicorn --host 0.0.0.0 --port %(ENV_UVICORN_PORT)s --workers %(ENV_UVICORN_WORKERS)s --timeout-keep-alive %(ENV_UVICORN_KEEPELIVE)s --log-level %(ENV_UVICORN_LOGLEVEL)s app:api`.", "source": "issue", "type": "qa_best_answer", "issue_number": 10}
{"instruction": "Provide a comprehensive answer to this question: Gunicorn Workers Hangs And Consumes Memory Forever", "input": "**Describe the bug**\r\nI have deployed FastAPI which queries the database and returns the results. I made sure closing the DB connection and all. I'm running gunicorn with this line ;\r\n`gunicorn -w 8 -k uvicorn.workers.UvicornH11Worker -b 0.0.0.0 app:app --timeout 10`\r\nSo after exposing it to the web, I run a load test which makes 30-40 requests in parallel to the fastapi. And the problem starts here. I'm watching the 'HTOP' in the mean time and I see that RAM usage is always growing, seems like no task is killed after completing it's job. Then I checked the Task numbers, same goes for it too, seems like gunicorn workers do not get killed. After some time RAM usage gets at it's maximum, and starts to throw errors. So I killed the gunicorn app but the thing is processes spawned by main gunicorn proces did not get killed and still using all the memory. \r\n\r\n**Environment:**\r\n - OS:  Ubuntu 18.04\r\n - FastAPI Version : 0.38.1\r\n\r\n- Python version : 3.7.4", "output": "You're using the PyPy compliant uvicorn worker class - is your system based on PyPy? If you're running on cpython then I suggest you try out the cpython implementation `uvicorn.workers.UvicornWorker`.  \r\n\r\nBut in other news, I'm seeing something similar. I just run uvicorn with this:\r\n`uvicorn --host 0.0.0.0 --port 7001 app:api --reload` but in some cases the memory is never freed up.\r\n\r\nFor example this function:\r\n```\r\n@api.post(\"/randompath\")\r\ndef get_xoxo(file: UploadFile = File(...)):\r\n    k = []\r\n    for i in range(10):\r\n        k.append('gab' * 9999999)\r\n```\r\nWhen I hit the endpoint once, the memory is cleared up, but when I hit it 10x, some of the memory is left allocated and when I hit it another 10x, even more memory is left allocated. This continues until I run out of memory or restart the process.\r\nIf I change the `get_xoxo` function to be `async`, then the memory is always cleared up, but the function also blocks much more (which makes sense since I'm not taking advantage of any `await`s in there).\r\n\r\nSo - is there a memory leak? I'm not sure, but something is handled incorrectly.\r\n\r\nMy system is running on `python:3.7` Docker container. Basically the same problem occurs in production where uvicorn is run with `uvicorn --host 0.0.0.0 --port %(ENV_UVICORN_PORT)s --workers %(ENV_UVICORN_WORKERS)s --timeout-keep-alive %(ENV_UVICORN_KEEPELIVE)s --log-level %(ENV_UVICORN_LOGLEVEL)s app:api`.\n\n---\n\n@wanaryytel \r\n\r\nThis is probably an issue with starlette's `run_in_threadpool`, or maybe even the python ThreadPoolExecutor. If you port that endpoint to starlette, I expect you'll get the same behavior.\r\n\r\nRecently the starlette and uvicorn teams have been pretty good about addressing issues; if you can reproduce the memory leak in starlette, I'd recommend creating an issue demonstrating it in the starlette (and possible uvicorn?) repos.\n\n---\n\n> You're using the PyPy compliant uvicorn worker class - is your system based on PyPy? If you're running on cpython then I suggest you try out the cpython implementation `uvicorn.workers.UvicornWorker`.\r\n\r\n I have noticed that too, under high load memory is left allocated but for single requests memory gets cleared up. And I already tried it making async but it is not deallocating the memory as well.\r\n\r\n\r\n\r\n> @wanaryytel\r\n> \r\n> This is probably an issue with starlette's `run_in_threadpool`, or maybe even the python ThreadPoolExecutor. If you port that endpoint to starlette, I expect you'll get the same behavior.\r\n> \r\n> Recently the starlette and uvicorn teams have been pretty good about addressing issues; if you can reproduce the memory leak in starlette, I'd recommend creating an issue demonstrating it in the starlette (and possible uvicorn?) repos.\r\n\r\nHmm, reproducing it in Starlette makes sense. I will reproduce the issue and open an issue on Starlette repo. Thanks for the idea\n\n---\n\n@wanaryytel out of curiosity, why can't you use async with an await.sleep(0) thrown in there?\n\n---\n\n@euri10 I could but I fail to see the benefit of that. It would still be blocking which I'm trying to avoid?", "source": "issue", "type": "qa_comprehensive", "issue_number": 10}
{"instruction": "Further develop startup and shutdown events\n\nDetails:\nWhile the documentationn for FastAPI is in general extremely solid, there's a weakpoint that I feel hints at some underdevelopped feature within the framework, and that's [startup and shutdown events][1]. They are briefly mentionned (separately) with the startup event in particular being demonstrated like this :\r\n\r\n```py\r\nitems = {}\r\n\r\n\r\n@app.on_event(\"startup\")\r\nasync def startup_event():\r\n    items[\"foo\"] = {\"name\": \"Fighters\"}\r\n    items[\"bar\"] = {\"name\": \"Tenders\"}\r\n\r\n\r\n@app.get(\"/items/{item_id}\")\r\nasync def read_items(item_id: str):\r\n    return items[item_id]\r\n```\r\n\r\n...which could very well be written like this:\r\n\r\n```py\r\nitems = {\r\n    \"foo\": {\"name\": \"Fighters\"},\r\n    \"bar\": {\"name\": \"Tenders\"}\r\n}\r\n\r\n@app.get(\"/items/{item_id}\")\r\nasync def read_items(item_id: str):\r\n    return items[item_id]\r\n```\r\n\r\n...and therefore makes the feature look useless. The example for `shutdown` instead uses logging as an example, which makes it look like this would be the primary purposes for those events, while in reality, it's not.\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\nThe problem is that, throughout the entire documentation, things like database connections are created in the global scope, at module import. While this would be fine in a regular Python application, this has a number of problems, especially with objects that have a side-effect outside the code itself, like database connections. To demonstrate this, I've made [a test structure that creates a lock file when initialized and deletes it when garbage collected][2].\r\n\r\nUsing it like this:\r\n```py\r\nfrom fastapi import FastAPI\r\nfrom lock import FileLock\r\n\r\napp = FastAPI()\r\nlock = FileLock(\"fastapi\")\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\r\n```\r\n\r\n...does not work and the lock is not deleted before shutdown (I was actually expecting it to be closed properly, like SQLAlchemy does with its connections, but clearly there's a lot of extra magic going on with", "input": "Repository: FastAPI\nLabels: ", "output": "@dmontagu: You were involved in the context manager dependencies, and that looked like a pretty complex addition. I'm not super familiar with the internal FastAPI codebase (though I might try my hand at this) but does that look like something that would be feasible given how dependencies currently work?", "source": "issue", "type": "qa_best_answer", "issue_number": 9}
{"instruction": "Provide a comprehensive answer to this question: Further develop startup and shutdown events", "input": "While the documentationn for FastAPI is in general extremely solid, there's a weakpoint that I feel hints at some underdevelopped feature within the framework, and that's [startup and shutdown events][1]. They are briefly mentionned (separately) with the startup event in particular being demonstrated like this :\r\n\r\n```py\r\nitems = {}\r\n\r\n\r\n@app.on_event(\"startup\")\r\nasync def startup_event():\r\n    items[\"foo\"] = {\"name\": \"Fighters\"}\r\n    items[\"bar\"] = {\"name\": \"Tenders\"}\r\n\r\n\r\n@app.get(\"/items/{item_id}\")\r\nasync def read_items(item_id: str):\r\n    return items[item_id]\r\n```\r\n\r\n...which could very well be written like this:\r\n\r\n```py\r\nitems = {\r\n    \"foo\": {\"name\": \"Fighters\"},\r\n    \"bar\": {\"name\": \"Tenders\"}\r\n}\r\n\r\n@app.get(\"/items/{item_id}\")\r\nasync def read_items(item_id: str):\r\n    return items[item_id]\r\n```\r\n\r\n...and therefore makes the feature look useless. The example for `shutdown` instead uses logging as an example, which makes it look like this would be the primary purposes for those events, while in reality, it's not.\r\n\r\n**Is your feature request related to a problem? Please describe.**\r\nThe problem is that, throughout the entire documentation, things like database connections are created in the global scope, at module import. While this would be fine in a regular Python application, this has a number of problems, especially with objects that have a side-effect outside the code itself, like database connections. To demonstrate this, I've made [a test structure that creates a lock file when initialized and deletes it when garbage collected][2].\r\n\r\nUsing it like this:\r\n```py\r\nfrom fastapi import FastAPI\r\nfrom lock import FileLock\r\n\r\napp = FastAPI()\r\nlock = FileLock(\"fastapi\")\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\r\n```\r\n\r\n...does not work and the lock is not deleted before shutdown (I was actually expecting it to be closed properly, like SQLAlchemy does with its connections, but clearly there's a lot of extra magic going on with", "output": "@dmontagu: You were involved in the context manager dependencies, and that looked like a pretty complex addition. I'm not super familiar with the internal FastAPI codebase (though I might try my hand at this) but does that look like something that would be feasible given how dependencies currently work?\n\n---\n\n@sm-Fifteen The startup/shutdown as they currently exist are taken almost without modification to starlette.\r\n\r\nI think it would be \"easy\" to add support for context managers, but it would mean going from having nothing to maintain for this feature, to having something to maintain. I'm not sure if that's preferable for fastapi.\r\n\r\nI agree that a context manager and/or exit stack could make more sense for this than the separate events as it currently exists. I think it is worth opening an issue in starlette about it. (Though I wouldn't be surprised if they eschew it due to the somewhat esoteric api.)\r\n\r\nFor what it's worth, I typically store any state necessary for startup/shutdown directly on the app instance (in `app.state`). That makes it a little nicer to work with than a global variable.\n\n---\n\n> The startup/shutdown as they currently exist are taken almost without modification to starlette.\r\n\r\nYeah, I've noticed, they certainly look out of place and the documentation barely skimming over it doesn't help.\r\n\r\n> I think it would be \"easy\" to add support for context managers, but it would mean going from having nothing to maintain for this feature, to having something to maintain. I'm not sure if that's preferable for fastapi.\r\n> \r\n> I agree that a context manager and/or exit stack could make more sense for this than the separate events as it currently exists. I think it is worth opening an issue in starlette about it. (Though I wouldn't be surprised if they eschew it due to the somewhat esoteric api.)\r\n\r\nI doubt Starlette would accept something of the sort, given how the `Depends` mechanism is a FastAPI addition, and having that upstream wouldn't really fit Starlette's goals, as far as I can tell. As for the maintenance burden, I suppose that would depend on just how much extra code this would represent and the test coverage for it. \r\n\r\nThe FastAPI tutorial glosses over that part (no mention of `app.state`, though it *was* introduced just a month ago; keeping all DB objects in global scope) because everything used in the examples make this work \"by magic\" (SQLite is all local, SQLAlchemy closes all connections on garbage collection, etc.), with the exception of [Async Databases](https://fastapi.tiangolo.com/tutorial/async-sql-databases/) where it's suddenly a requirement that you would be unlikely to notice if not specifically looking for it.\r\n\r\nFastAPI could probably use a proper mechanism for this sort of thing to advertize in that tutorial. ;)\n\n---\n\nThanks @dmontagu for the help here!\r\n\r\nAbout the events not working as you expected while debugging, that would be better in a Starlette issue. But it's possible that as you are using `--reload`, it can actually be a Uvicorn issue, or even an ASGI spec issue.\r\n\r\nAbout having the extra mechanism with context managers, it looks nice, but that would mean adding all that as an extra feature, and would probably require quite a lot of extra code to support just that. And I'm not sure it would really solve something that can't be done otherwise to justify all the extra effort.\r\n\r\nI think the best would be to first check if your problem is related to one of those things?\r\n\r\nThe best way would be to have a minimal self-contained example to demonstrate the error.\r\n\r\nThis issue slightly touches a lot of different things, if there's something else not covered here, could you please create a new issue for just that one thing? And please include a small self-contained example to show the error/misbehavior you're seeing.\r\n\r\n<!-- issue-manager: answered -->\n\n---\n\n> I think the best would be to first check if your problem is related to one of those things?\r\n> \r\n> The best way would be to have a minimal self-contained example to demonstrate the error.\r\n> \r\n> This issue slightly touches a lot of different things, if there's something else not covered here, could you please create a new issue for just that one thing? And please include a small self-contained example to show the error/misbehavior you're seeing.\r\n\r\nThe error itself isn't the problem I'm looking to fix, it's just a symptom of how we currently manage (or at least advise in the documentation) lifetime-scoped dependencies. That is, we simply initialize them in the global scope with the assumption that everything outside functions can only run once and will be destroyed automatically on server shutdown. Those assumptions are incorrect (especially the latter in async python) and I presume that's what the `lifespan` protocol was most likely designed to address.\r\n\r\n> About the events not working as you expected while debugging, that would be better in a Starlette issue. But it's possible that as you are using `--reload`, it can actually be a Uvicorn issue, or even an ASGI spec issue.\r\n\r\nNo, `--reload` is certainly an unusual way to run code, but I wouldn't say it's a Uvicorn issue or a problem with the ASGI spec, since uvicorn does the right thing by firing the shutdown event before reloading the code, calling the startup event again and only then starting the application again. The problem is the initialization that's performed during code reload, as in my example. \r\n\r\n```py\r\nfrom fastapi import FastAPI\r\nfrom lock import FileLock\r\n\r\napp = FastAPI()\r\n# Create a lock to avoid two instances of the app running at the same time\r\nlock = FileLock(\"fastapi\")\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\r\n```\r\n\r\nThis is not really any different from a module running initialization code in global scope outside of a `if __name__ == '__main__'` scope: it's *usually fine* but is going to lead to various kinds of issues further down the line in larger projects.\r\n\r\n> About having the extra mechanism with context managers, it looks nice, but that would mean adding all that as an extra feature, and would probably require quite a lot of extra code to support just that. And I'm not sure it would really solve something that can't be done otherwise to justify all the extra effort.\r\n\r\nThe context manager approach was more of a proposition of what a more ergonomic way of tying this with the dependency system could look like, though I get why that might prove tricky to implement. it's just that, looking at the proposed use cases for [CMs as dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/) involve database connections and sessions, and I'm not sure creating and removing them for each request is the prefered way to do this.\r\n\r\nJudging by how SQLAlchemy does connection pooling on its own, I figure it's generally better to create them once when starting your application (which most examples in the tutorial seem to be doing) and then closing them before the server shuts down. SQLAlchemy handles closing its connections on application shutdown because of magic:tm:, but most libraries shouldn't be expected to be this smart about cleaning up, and the current event-based mechanism from Starlette doesn't mesh that well with dependencies (see the `_db_conn` example in my original post).\r\n\r\nThe tutorial kind of shows this in the one instance where cleanup has to be handled by application code:\r\nhttps://github.com/tiangolo/fastapi/blob/1c2ecbb89a7f1ce79f470f78a99af975de884c66/docs/src/async_sql_databases/tutorial001.py#L45-L52\r\n\r\nI'd actually say this is a bit cleaner than it would be in practice because `database` is taken from the global scope, instead of  being passed as a dependency.\r\n\r\nEDIT: When I say \"Those assumptions are incorrect (especially [that everything outside functions ... will be destroyed automatically] in async python)\", I'm referring to `__del__` being generally unreliable in async Python, which [has be", "source": "issue", "type": "qa_comprehensive", "issue_number": 9}
{"instruction": "French translations\n\nDetails:\n# Bonjour ðŸ‡«ðŸ‡·\r\n\r\nWelcome to the issue that coordinates the French translation effort.\r\n\r\n## Purpose \r\n\r\n- Avoiding several people working on the same document at the same time. \r\n\r\nThe first person who declares that he/she is working on a translation gets the responsibility to carry it out. If a PR seems to be stalled, we can discuss a transfer of responsibility here.\r\n\r\n- Enforcing best practices\r\n\r\nBest practices are listed later in this description. You can propose your practice at any time, ideally with a supporting source and an example. \r\n\r\nDefining and sharing best practices will help to avoid common mistakes and will allow faster and easier reviews.\r\n\r\n- Help and build the community\r\n\r\nDo not hesitate to ask any questions regarding the french translation effort here. The stronger the community, the more effective we will be and the more we will enjoy. \r\n\r\n- Provide a french translation for this awesome library (last but not least)\r\n\r\nIf you are here, you probably like **FastAPI**, and maybe you even speak French. Giving more people the opportunity to get started using the documentation in its native language will encourage adoption. In that spirit, let's contribute to the magic of open source in this way.\r\n\r\n## How to contribute\r\n\r\n### Review \r\n\r\nKeep in mind that the easiest way to participate is to review the PRs. We need to avoid accumulating PRs waiting for review.\r\n\r\n### Translate\r\n\r\nIf you are not familiar with contributing to open source projects have a look at https://github.com/firstcontributions/first-contributions.\r\n\r\nIn any case, take a look at the documentation section related to the [contribution](https://fastapi.tiangolo.com/contributing/#development-contributing) and more precisely the part about the [documentation](https://fastapi.tiangolo.com/contributing/#docs).\r\n\r\nOnce you are decided to translate a document, make yourself known here by leaving a message here (eg. https://github.com/tiangolo/fastapi/issues/1972#issuecomment-702956335).\r\n\r\n", "input": "Repository: FastAPI\nLabels: ", "output": "I'm starting with the `docs/index.md`: https://github.com/tiangolo/fastapi/pull/1973", "source": "issue", "type": "qa_best_answer", "issue_number": 8}
{"instruction": "Provide a comprehensive answer to this question: French translations", "input": "# Bonjour ðŸ‡«ðŸ‡·\r\n\r\nWelcome to the issue that coordinates the French translation effort.\r\n\r\n## Purpose \r\n\r\n- Avoiding several people working on the same document at the same time. \r\n\r\nThe first person who declares that he/she is working on a translation gets the responsibility to carry it out. If a PR seems to be stalled, we can discuss a transfer of responsibility here.\r\n\r\n- Enforcing best practices\r\n\r\nBest practices are listed later in this description. You can propose your practice at any time, ideally with a supporting source and an example. \r\n\r\nDefining and sharing best practices will help to avoid common mistakes and will allow faster and easier reviews.\r\n\r\n- Help and build the community\r\n\r\nDo not hesitate to ask any questions regarding the french translation effort here. The stronger the community, the more effective we will be and the more we will enjoy. \r\n\r\n- Provide a french translation for this awesome library (last but not least)\r\n\r\nIf you are here, you probably like **FastAPI**, and maybe you even speak French. Giving more people the opportunity to get started using the documentation in its native language will encourage adoption. In that spirit, let's contribute to the magic of open source in this way.\r\n\r\n## How to contribute\r\n\r\n### Review \r\n\r\nKeep in mind that the easiest way to participate is to review the PRs. We need to avoid accumulating PRs waiting for review.\r\n\r\n### Translate\r\n\r\nIf you are not familiar with contributing to open source projects have a look at https://github.com/firstcontributions/first-contributions.\r\n\r\nIn any case, take a look at the documentation section related to the [contribution](https://fastapi.tiangolo.com/contributing/#development-contributing) and more precisely the part about the [documentation](https://fastapi.tiangolo.com/contributing/#docs).\r\n\r\nOnce you are decided to translate a document, make yourself known here by leaving a message here (eg. https://github.com/tiangolo/fastapi/issues/1972#issuecomment-702956335).\r\n\r\n", "output": "I'm starting with the `docs/index.md`: https://github.com/tiangolo/fastapi/pull/1973\n\n---\n\nHello, I would like to help with this but it is the first time I contribute to an open-source project. Could you summarize me the workflow to correctly push the update ?\n\n---\n\n@Jefidev \n- Post here the page you'll be translating.\n- Work on it.\n- Create the PR with your work.\n- Developers will review.\n- Fix issues/get approvals.\n- Wait for enough approvals (usually 2-3 are enough based on what I've seen).\n- @tiangolo will merge if everything is fine.\n\n---\n\nThanks, So I am translating the features.md `docs/features.md` page\n\n---\n\nHey @Jefidev , to contribute you can also review the existing PR :)\r\nThanks for you motivation :v:", "source": "issue", "type": "qa_comprehensive", "issue_number": 8}
{"instruction": "Japanese Translation\n\nDetails:\n### Tracking Japanese Translation\r\nWe can use this Issue to track the progress of the Japanese language translations.:sunglasses:\r\n\r\nPlease post here what page you plan on translating so we can coordinate. ðŸš€\r\n\r\n### Tips\r\n- If the term is a technical term, leave in English and add an explanation of the meaning of the word in Japanese.\r\n- Please unify translations as follows:\r\n\r\nen | ja | Note\r\n-- | -- | --\r\n!!! note | !!! note \"å‚™è€ƒ\" | \r\n!!! info | !!! info \"æƒ…å ±\" | \r\n!!! tip | !!! tip \"è±†çŸ¥è­˜\" | \r\n!!! check | !!! check \"ç¢ºèª\" | \r\npath operation | Â  | Â \r\nvalidation | Â  | Â \r\ncompletion | Â  | Â \r\nautomatic documentation", "input": "Repository: FastAPI\nLabels: ", "output": "@ryuckel Could you fix the title, please?\r\n`[FEATURE]Japanese Transration` -> `[FEATURE] Japanese Translation`", "source": "issue", "type": "qa_best_answer", "issue_number": 7}
{"instruction": "Provide a comprehensive answer to this question: Japanese Translation", "input": "### Tracking Japanese Translation\r\nWe can use this Issue to track the progress of the Japanese language translations.:sunglasses:\r\n\r\nPlease post here what page you plan on translating so we can coordinate. ðŸš€\r\n\r\n### Tips\r\n- If the term is a technical term, leave in English and add an explanation of the meaning of the word in Japanese.\r\n- Please unify translations as follows:\r\n\r\nen | ja | Note\r\n-- | -- | --\r\n!!! note | !!! note \"å‚™è€ƒ\" | \r\n!!! info | !!! info \"æƒ…å ±\" | \r\n!!! tip | !!! tip \"è±†çŸ¥è­˜\" | \r\n!!! check | !!! check \"ç¢ºèª\" | \r\npath operation | Â  | Â \r\nvalidation | Â  | Â \r\ncompletion | Â  | Â \r\nautomatic documentation", "output": "@ryuckel Could you fix the title, please?\r\n`[FEATURE]Japanese Transration` -> `[FEATURE] Japanese Translation`\n\n---\n\n~~Started translations of features.md~~\r\n\r\nfeatures.md translation at PR #1625 ~[needing review][Approved-2]~[merged]\n\n---\n\ntutorial/index.md translation at PR #1656 ~[needing review][Approved-2]~[merged]\r\ntutorial/first-steps.md translation at PR #1658 ~[needing review][Approved-2]~[merged]\r\ntutorial/path-params.md translation at PR #1671 ~[needing review][Approved-2]~[merged]\r\ntutorial/query-params.md translation at PR #1674 ~[needing review][Approved-2]~[merged]\r\ntutorial/body.md translation at PR #1683 ~[needing review][Approved-2]~[merged]\n\n---\n\n~Started translations of help-fastapi.md~\r\n\r\nhelp-fastapi.md translation at PR #1692 ~[needing review][Approved-2]~[merged]\n\n---\n\n~Started translations of deployment.md~\r\n\r\n~deployment.md translation at PR #1948 [needing review][Approved-1]~", "source": "issue", "type": "qa_comprehensive", "issue_number": 7}
{"instruction": "msgpack response if client asks for application/x-msgpack\n\nDetails:\nhi,\r\nwe are in the process of evaling fastapi for a large app migration from flask. Quick question on a very interesting and useful piece of functionality. \r\nThis builds upon the validations you have created for encoding json data and will be very useful for us out-of-the-box.\r\n\r\nhttps://msgpack.org/index.html is an enhancement to json which is highly compressed. There are some benchmarks that show it is as fast as protocol buffers...while making it a drop-in alternative to json. \r\n\r\nmsgpack is very important for Asia which are highly internet bandwidth constrained. We are prepared to tradeoff speed in exchange for lesser bandwidth (e.g. http://indiegamr.com/cut-your-data-exchange-traffic-by-up-to-50-with-one-line-of-code-msgpack-vs-json/ )\r\n\r\nTo be fair, it may be same size as gzipped json responses...but after having done android app deployments over a million devices in the field in asia, we realized that one has to write custom compression/decompression for gzipped json response handling. However msgpack has fairly well supported libraries. \r\n\r\nmsgpack is fairly production ready. Lots of downstream python libraries use it in production - https://github.com/0rpc/zerorpc-python\r\n\r\nThis enhancement request is for fastapi to respond in msgpack if the requesting client ask for the mimetype `application/x-msgpack`. The default behavior continues to be the same as currently.\r\n\r\nThere is no impact to any client of a fastapi deployment unless they specifically ask for msgpack (in which case, they will get better performance).\r\n\r\nI'm also pasting some criticisms of msgpack and comparisons with competing/derived json formats like CBOR\r\n\r\n- https://news.ycombinator.com/item?id=14067747\r\n- http://zderadicka.eu/comparison-of-json-like-serializations-json-vs-ubjson-vs-messagepack-vs-cbor/\r\n- https://techtutorialsx.com/2019/06/20/esp32-arduinojson-messagepack-serialization/\r\n- https://gist.github.com/frsyuki/2908191\r\n- https://prataprc.github.io/msgpack-vs-cbor.html", "input": "Repository: FastAPI\nLabels: ", "output": "@sandys \r\nI think fastapi may actually be relatively well suited to handle this now without modifications.\r\n\r\nIf your top priority is just reducing bandwidth usage, I think it should be straightforward to implement converting the json responses to msgpack (in the presence of the appropriate mimetype request) as an ASGI middleware. I imagine that would involve parsing the json and dumping it to msgpack format, so would come with some processing overhead. But that overhead would probably be negligible compared to network, especially if bandwidth is the source of the concern.\r\n\r\nIf you really want to avoid the reparsing, I think this would also be possible by creating a custom starlette response that holds the python dict you want to serialize (rather than encoded json), and adding a middleware that converts responses of that type to a new starlette.Response with msgpack-encoded contents.\r\n\r\nIf you are serious about this and want/need a little more guidance than provided above, I can put together more of a skeleton implementation.", "source": "issue", "type": "qa_best_answer", "issue_number": 6}
{"instruction": "Provide a comprehensive answer to this question: msgpack response if client asks for application/x-msgpack", "input": "hi,\r\nwe are in the process of evaling fastapi for a large app migration from flask. Quick question on a very interesting and useful piece of functionality. \r\nThis builds upon the validations you have created for encoding json data and will be very useful for us out-of-the-box.\r\n\r\nhttps://msgpack.org/index.html is an enhancement to json which is highly compressed. There are some benchmarks that show it is as fast as protocol buffers...while making it a drop-in alternative to json. \r\n\r\nmsgpack is very important for Asia which are highly internet bandwidth constrained. We are prepared to tradeoff speed in exchange for lesser bandwidth (e.g. http://indiegamr.com/cut-your-data-exchange-traffic-by-up-to-50-with-one-line-of-code-msgpack-vs-json/ )\r\n\r\nTo be fair, it may be same size as gzipped json responses...but after having done android app deployments over a million devices in the field in asia, we realized that one has to write custom compression/decompression for gzipped json response handling. However msgpack has fairly well supported libraries. \r\n\r\nmsgpack is fairly production ready. Lots of downstream python libraries use it in production - https://github.com/0rpc/zerorpc-python\r\n\r\nThis enhancement request is for fastapi to respond in msgpack if the requesting client ask for the mimetype `application/x-msgpack`. The default behavior continues to be the same as currently.\r\n\r\nThere is no impact to any client of a fastapi deployment unless they specifically ask for msgpack (in which case, they will get better performance).\r\n\r\nI'm also pasting some criticisms of msgpack and comparisons with competing/derived json formats like CBOR\r\n\r\n- https://news.ycombinator.com/item?id=14067747\r\n- http://zderadicka.eu/comparison-of-json-like-serializations-json-vs-ubjson-vs-messagepack-vs-cbor/\r\n- https://techtutorialsx.com/2019/06/20/esp32-arduinojson-messagepack-serialization/\r\n- https://gist.github.com/frsyuki/2908191\r\n- https://prataprc.github.io/msgpack-vs-cbor.html", "output": "@sandys \r\nI think fastapi may actually be relatively well suited to handle this now without modifications.\r\n\r\nIf your top priority is just reducing bandwidth usage, I think it should be straightforward to implement converting the json responses to msgpack (in the presence of the appropriate mimetype request) as an ASGI middleware. I imagine that would involve parsing the json and dumping it to msgpack format, so would come with some processing overhead. But that overhead would probably be negligible compared to network, especially if bandwidth is the source of the concern.\r\n\r\nIf you really want to avoid the reparsing, I think this would also be possible by creating a custom starlette response that holds the python dict you want to serialize (rather than encoded json), and adding a middleware that converts responses of that type to a new starlette.Response with msgpack-encoded contents.\r\n\r\nIf you are serious about this and want/need a little more guidance than provided above, I can put together more of a skeleton implementation.\n\n---\n\nThis might be even easier than I thought.\r\n\r\nI'd suggest taking a look at `starlette.responses.JSONResponse` -- it looks like you could pretty easily create a `MsgpackResponse` by defining an appropriate `render` function (e.g., using `msgpack-python`). Then, you could have your endpoints return `msgpack`-encoded data by setting `response_class=MsgpackResponse`. That wouldn't allow for dynamic determination of the response type based on the request, but maybe there is still a way to achieve that...\r\n\r\n(Certainly, in the worst case, you could just perform a reparsing of the `JSONResponse` in a middleware.)\n\n---\n\n@sandys\r\nActually, I got interested in this and was able to throw together a working example -- not quite how I expected it would need to go, and it has some hacks that could probably be removed (maybe would require a feature request or two), but it works:\r\n\r\n```python\r\nfrom typing import Any, Dict, List, Type\r\n\r\nimport msgpack\r\nfrom fastapi import FastAPI\r\nfrom fastapi.routing import APIRoute, get_app\r\nfrom starlette.background import BackgroundTask\r\nfrom starlette.requests import Request\r\nfrom starlette.responses import JSONResponse, Response\r\nfrom starlette.routing import request_response\r\nfrom starlette.testclient import TestClient\r\n\r\n\r\nclass MsgpackResponse(Response):\r\n    media_type = \"application/msgpack\"\r\n\r\n    def render(self, content: Any) -> bytes:\r\n        return msgpack.packb(content)\r\n\r\n\r\nclass MultiResponse(JSONResponse):\r\n    serialization_header = \"Accept\"\r\n    default_response_class = JSONResponse\r\n    response_class_map: Dict[str, Type[Response]] = {\"application/x-msgpack\": MsgpackResponse}\r\n\r\n    def __init__(\r\n        self,\r\n        content: Any = None,\r\n        status_code: int = 200,\r\n        headers: dict = None,\r\n        media_type: str = None,\r\n        background: BackgroundTask = None,\r\n    ) -> None:\r\n        self.content = content\r\n        self._status_code = status_code\r\n        self._media_type = media_type\r\n        self._background = background\r\n        self.init_headers(headers)\r\n\r\n    def for_request(self, request: Request) -> Response:\r\n        serialization_method = request.headers.get(self.serialization_header)\r\n        response_class = self.response_class_map.get(\r\n            serialization_method, self.default_response_class\r\n        )\r\n        return response_class(\r\n            content=self.content,\r\n            status_code=self._status_code,\r\n            headers=self.headers,\r\n            media_type=self._media_type,\r\n            background=self._background,\r\n        )\r\n\r\n\r\nclass MultiAPIRoute(APIRoute):\r\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\r\n        if kwargs[\"response_class\"] is JSONResponse:\r\n            kwargs[\"response_class\"] = MultiResponse\r\n        super().__init__(*args, **kwargs)\r\n\r\n        # Copied below from the end of the APIRoute init; overwriting the self.app with a modified version\r\n        base_app_func = get_app(\r\n            dependant=self.dependant,\r\n            body_field=self.body_field,\r\n            status_code=self.status_code,\r\n            response_class=self.response_class,\r\n            response_field=self.secure_cloned_response_field,\r\n            response_model_include=self.response_model_include,\r\n            response_model_exclude=self.response_model_exclude,\r\n            response_model_by_alias=self.response_model_by_alias,\r\n            response_model_skip_defaults=self.response_model_skip_defaults,\r\n            dependency_overrides_provider=self.dependency_overrides_provider,\r\n        )\r\n\r\n        async def app_func(request: Request) -> Response:\r\n            response = await base_app_func(request)\r\n            if isinstance(response, MultiResponse):\r\n                response = response.for_request(request)\r\n            return response\r\n\r\n        self.app = request_response(app_func)\r\n\r\n\r\napp = FastAPI()\r\napp.router.route_class = MultiAPIRoute\r\n\r\n\r\n@app.get(\"/\", response_model=List[int])\r\nasync def root():\r\n    return [1, 2, 3]\r\n\r\n\r\nclient = TestClient(app)\r\nprint(client.get(\"/\").content)\r\n# b'[1,2,3]'\r\n\r\nprint(client.get(\"/\", headers={\"X-Serialization\": \"msgpack\"}).content)\r\n# b'\\x93\\x01\\x02\\x03'\r\n```\n\n---\n\nFirst I want to thank you for taking the trouble to do this !!\nI really appreciate this and have newfound respect for the great community\naround fastapi.\n\nI'm still requesting for this to be made a first class feature within\nfastapi for the benefit it provides to the larger community\n\nOn Fri, 13 Sep, 2019, 04:05 dmontagu, <notifications@github.com> wrote:\n\n> @sandys <https://github.com/sandys>\n> Actually, I got interested in this and was able to throw together a\n> working example -- not quite how I expected it would need to go, and it has\n> some minor hacks, but it works:\n>\n> from typing import Any, Dict, List, Type\n> import msgpackfrom fastapi import FastAPIfrom fastapi.routing import APIRoute, get_appfrom starlette.background import BackgroundTaskfrom starlette.requests import Requestfrom starlette.responses import JSONResponse, Responsefrom starlette.routing import request_responsefrom starlette.testclient import TestClient\n>\n> class MsgpackResponse(Response):\n>     media_type = \"application/msgpack\"\n>\n>     def render(self, content: Any) -> bytes:\n>         return msgpack.packb(content)\n>\n> class MultiResponse(JSONResponse):\n>     serialization_header = \"X-Serialization\"\n>     default_response_class = JSONResponse\n>     response_class_map: Dict[str, Type[Response]] = {\"msgpack\": MsgpackResponse}\n>\n>     def __init__(\n>         self,\n>         content: Any = None,\n>         status_code: int = 200,\n>         headers: dict = None,\n>         media_type: str = None,\n>         background: BackgroundTask = None,\n>     ) -> None:\n>         self.content = content\n>         super().__init__(content, status_code, headers, media_type, background)\n>\n>     def for_request(self, request: Request) -> Response:\n>         serialization_method = request.headers.get(self.serialization_header)\n>         response_class = self.response_class_map.get(\n>             serialization_method, self.default_response_class\n>         )\n>         return response_class(\n>             content=self.content,\n>             status_code=self.status_code,\n>             headers=self.headers,\n>             media_type=self.media_type,\n>             background=self.background,\n>         )\n>\n> class MultiAPIRoute(APIRoute):\n>     def __init__(self, *args: Any, **kwargs: Any) -> None:\n>         if kwargs[\"response_class\"] is JSONResponse:\n>             kwargs[\"response_class\"] = MultiResponse\n>         super().__init__(*args, **kwargs)\n>\n>         # Copied below from the end of the APIRoute init; overwriting the self.app with a modified version\n>         base_app_func = get_app(\n>             dependant=self.dependant,\n>             body_field=self.body_field,\n>             status_code=self.status_code,\n>             response_class=self.response_class,\n>     ", "source": "issue", "type": "qa_comprehensive", "issue_number": 6}
{"instruction": "ðŸ‡§ðŸ‡·Portuguese translations\n\nDetails:\n## Portuguese translation tracking  <span>&#x1f1e7;&#x1f1f7;</span>\r\n\r\n### Is your feature request related to a problem\r\n\r\nI want to be able to track chapters that are in progress or already translated. \r\n\r\n### The solution you would like\r\n\r\nEach person who is working in a chapter should notify in this issue.  Comment with the name of the file. If more than two weeks are passed, other people can take this file. \r\n\r\n### Describe alternatives you've considered\r\n\r\nWe can track using our telegram channel `@fastapibr`, but the issue can be easy.\r\n\r\n### Additional context\r\n\r\nThere is no additional context.", "input": "Repository: FastAPI\nLabels: ", "output": "~~Started translations of `index.md`~~\r\n\r\nDue to some personal problems, I am leaving the translation of this file, but I continue to help by reviewing the content of all translations. Good job guys!", "source": "issue", "type": "qa_best_answer", "issue_number": 5}
{"instruction": "Provide a comprehensive answer to this question: ðŸ‡§ðŸ‡·Portuguese translations", "input": "## Portuguese translation tracking  <span>&#x1f1e7;&#x1f1f7;</span>\r\n\r\n### Is your feature request related to a problem\r\n\r\nI want to be able to track chapters that are in progress or already translated. \r\n\r\n### The solution you would like\r\n\r\nEach person who is working in a chapter should notify in this issue.  Comment with the name of the file. If more than two weeks are passed, other people can take this file. \r\n\r\n### Describe alternatives you've considered\r\n\r\nWe can track using our telegram channel `@fastapibr`, but the issue can be easy.\r\n\r\n### Additional context\r\n\r\nThere is no additional context.", "output": "~~Started translations of `index.md`~~\r\n\r\nDue to some personal problems, I am leaving the translation of this file, but I continue to help by reviewing the content of all translations. Good job guys!\n\n---\n\n~Started translations of `history-design-future.md`~\r\n\r\n`history-design-future.md` translation at PR #1249 [needing review]\n\n---\n\n~Started translations of `features.md`~\r\n\r\n`features.md` translation at PR #1248 [needing review]\n\n---\n\n~~Started translations of `benchmarks.md`~~\r\n\r\n`benchmarks.md` translation at PR [#1274](https://github.com/tiangolo/fastapi/pull/1274) [needing review]\n\n---\n\n~Started translations of `tutorial/index.md`~\r\n\r\n`tutoria/index.d` translation at PR #1259 [needing review]", "source": "issue", "type": "qa_comprehensive", "issue_number": 5}
{"instruction": "The memory usage piles up over the time and leads to OOM\n\nDetails:\n### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ ] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [ ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ ] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n<!-- Replace the code below with your own self-contained, minimal, reproducible, example, if I (or some", "input": "Repository: FastAPI\nLabels: ", "output": "> same issue i faced @prav2019\r\n\r\nAny solution to overcome that @Riki-1mg", "source": "issue", "type": "qa_best_answer", "issue_number": 4}
{"instruction": "Provide a comprehensive answer to this question: The memory usage piles up over the time and leads to OOM", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ ] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [ ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ ] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n<!-- Replace the code below with your own self-contained, minimal, reproducible, example, if I (or some", "output": "> same issue i faced @prav2019\r\n\r\nAny solution to overcome that @Riki-1mg\n\n---\n\nNo @prav2019, \r\nare you using aiohttp as http clients in your service ?\r\nhttps://github.com/tiangolo/fastapi/issues/1623\n\n---\n\nNo @Riki-1mg\n\n---\n\n```python\r\n@app.get(\"/\")\r\ndef read_root():\r\n  return {\"Hello\": \"World\"}\r\n```\r\nSurely the expected behaviour here is to return `{\"Hello\": \"World\"}`?\r\n\r\nIf you want this function to return `{\"Hello\": \"Sara\"}` you'd probably need to do something like:\r\n\r\n```python\r\n@app.get(\"/\")\r\ndef read_root():\r\n  return {\"Hello\": \"Sara\"}\r\n```\r\n\r\nFurther, I can't reproduce your error on my \"machine\" (it's sitting on a cloud somewhere). You can [see the full details here](https://repl.it/repls/ImpoliteLightblueDemos) but everything looks to be working fine.\r\n\r\nI suspect that this is specific to your operating system setup, etc. Would you please provide some more info needed/useful to know in context of how to reproduce the error?\r\n\r\n * How much RAM does your machine have?\r\n * How much memory is each function using (ideally include all the debugging output).\r\nThis wil look something like the below (example from the Python documentation)\r\n```\r\n[ Top 10 ]\r\n<frozen importlib._bootstrap>:716: size=4855 KiB, count=39328, average=126 B\r\n<frozen importlib._bootstrap>:284: size=521 KiB, count=3199, average=167 B\r\n/usr/lib/python3.4/collections/__init__.py:368: size=244 KiB, count=2315, average=108 B\r\n/usr/lib/python3.4/unittest/case.py:381: size=185 KiB, count=779, average=243 B\r\n/usr/lib/python3.4/unittest/case.py:402: size=154 KiB, count=378, average=416 B\r\n/usr/lib/python3.4/abc.py:133: size=88.7 KiB, count=347, average=262 B\r\n<frozen importlib._bootstrap>:1446: size=70.4 KiB, count=911, average=79 B\r\n<frozen importlib._bootstrap>:1454: size=52.0 KiB, count=25, average=2131 B\r\n<string>:5: size=49.7 KiB, count=148, average=344 B\r\n/usr/lib/python3.4/sysconfig.py:411: size=48.0 KiB, count=1, average=48.0 KiB\r\n```\r\n * Does your out-of-memory error include a traceback? Please include that if that's the case.\n\n---\n\n@teymour-aldridge : here is the debug statistics:\r\nMemory Statistics\r\nTop 10 Files\r\n/usr/local/lib/python3.6/site-packages/uvicorn/main.py:305: size=1652 KiB (+1499 KiB), count=4597 (+4172), average=368 B KB\r\n\r\n/usr/local/lib/python3.6/site-packages/starlette/applications.py:136: size=1288 KiB (+1173 KiB), count=2290 (+2086), average=576 B KB\r\n\r\n/usr/local/lib/python3.6/threading.py:347: size=943 KiB (+854 KiB), count=1836 (+1657), average=526 B KB\r\n\r\n/usr/local/lib/python3.6/queue.py:145: size=919 KiB (+835 KiB), count=1783 (+1619), average=528 B KB\r\n\r\n/usr/local/lib/python3.6/asyncio/locks.py:233: size=885 KiB (+807 KiB), count=9633 (+8771), average=94 B KB\r\n\r\n/usr/local/lib/python3.6/site-packages/uvicorn/protocols/http/httptools_impl.py:82: size=788 KiB (+717 KiB), count=6876 (+6264), average=117 B KB\r\n\r\n/usr/local/lib/python3.6/site-packages/uvicorn/protocols/http/httptools_impl.py:77: size=751 KiB (+684 KiB), count=2289 (+2086), average=336 B KB\r\n\r\n/usr/local/lib/python3.6/site-packages/uvicorn/protocols/http/httptools_impl.py:146: size=725 KiB (+662 KiB), count=15984 (+14611), average=46 B KB\r\n\r\n/usr/local/lib/python3.6/site-packages/sqlalchemy/engine/result.py:376: size=657 KiB (+590 KiB), count=10490 (+9426), average=64 B KB\r\n\r\n/usr/local/lib/python3.6/site-packages/uvicorn/protocols/http/httptools_impl.py:285: size=609 KiB (+555 KiB), count=4589 (+4183), average=136 B KB\r\n\r\nScanned Lines that consumes more memory\r\nuvicorn/main.py\r\n\r\nloop.run_until_complete(self.serve(sockets=sockets))\r\nstarlette/applications.py\r\n\r\nscope[\"app\"] = self\r\npython3.6/threading.py\r\n\r\nwaiters_to_notify = _deque(_islice(all_waiters, n))\r\npython3.6/queue.py\r\n\r\nself.not_empty.notify()\r\nasyncio/locks.py\r\n\r\nself._waiters = collections.deque()\r\nhttp/httptools_impl.py\r\n\r\nself.parser = httptools.HttpRequestParser(self)\r\nhttp/httptools_impl.py\r\n\r\nself.config = config\r\nhttp/httptools_impl.py\r\n\r\nself.parser.feed_data(data)\r\nengine/result.py\r\n\r\nfor obj_elem in elem[4]\r\nhttp/httptools_impl.py\r\n\r\nself.timeout_keep_alive, self.timeout_keep_alive_handler", "source": "issue", "type": "qa_comprehensive", "issue_number": 4}
{"instruction": "Spanish translations\n\nDetails:\n### Spanish translations tracking\r\n\r\nWe can use this Issue to track the progress of the Spanish language translations. ðŸ¤“ \r\n\r\nPlease let us know here what page you plan on translating so we can coordinate. ðŸš€ \r\n\r\n#### Tips\r\n\r\n- We chose to use \"tu\" instead of \"usted\" or \"vos\"\r\n\r\n- If the term is a technical term, leave in English and add an explanation of the meaning of the word in Spanish.  You can do it with a note or an `abbr` element. This should help us avoid confusion with confusing Spanish translations, for example using \"instancia\" for \"instance\". \r\n\r\nThank you for your help! Gracias por tu ayuda! ðŸŽ‰", "input": "Repository: FastAPI\nLabels: ", "output": "I'm currently translating the Features page. \r\n\r\nhttps://fastapi.tiangolo.com/es/features/\r\n\r\n---\r\n\r\nThis translation is done and up for review: #1220  ðŸš€", "source": "issue", "type": "qa_best_answer", "issue_number": 3}
{"instruction": "Provide a comprehensive answer to this question: Spanish translations", "input": "### Spanish translations tracking\r\n\r\nWe can use this Issue to track the progress of the Spanish language translations. ðŸ¤“ \r\n\r\nPlease let us know here what page you plan on translating so we can coordinate. ðŸš€ \r\n\r\n#### Tips\r\n\r\n- We chose to use \"tu\" instead of \"usted\" or \"vos\"\r\n\r\n- If the term is a technical term, leave in English and add an explanation of the meaning of the word in Spanish.  You can do it with a note or an `abbr` element. This should help us avoid confusion with confusing Spanish translations, for example using \"instancia\" for \"instance\". \r\n\r\nThank you for your help! Gracias por tu ayuda! ðŸŽ‰", "output": "I'm currently translating the Features page. \r\n\r\nhttps://fastapi.tiangolo.com/es/features/\r\n\r\n---\r\n\r\nThis translation is done and up for review: #1220  ðŸš€\n\n---\n\nGreat\r\nCount on me.\r\nLet me grasp the procedure\n\n---\n\nI'm currently translating the Python Type Intro page.\r\n\r\nhttps://fastapi.tiangolo.com/python-types/\r\n\r\n---\r\n\r\nThis translation is done and up for review: #1237  ðŸš€\n\n---\n\nok\r\nI'll do the features page\r\nhttps://fastapi.tiangolo.com/es/features/\n\n---\n\nCan I take https://fastapi.tiangolo.com/tutorial/ ?", "source": "issue", "type": "qa_comprehensive", "issue_number": 3}
{"instruction": "CORSMiddleware not work\n\nDetails:\nHi,\r\nI searched the FastAPI documentation( https://fastapi.tiangolo.com/tutorial/cors/). But get errors:\r\nAccess to XMLHttpRequest at \"http://127.0.0.1:8086/api\" from origin \"http://www.example.com\" has been blocked by CORS policy:Response to preflight request doesn't pass access control check:No 'Access-Control-Allow-Origin' header is present on the requeste resource.\r\n\r\n\"http://127.0.0.1:8086/api\" and \"http://www.example.com\" are in same pc.\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=[\"*\"],      \r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"], \r\n    allow_headers=[\"*\"],\r\n)", "input": "Repository: FastAPI\nLabels: ", "output": "How do you make the request? Could you use the web devtools to see how the request look like (with HTTP headers)?\r\n\r\nAlso you may want to follow the issue template.", "source": "issue", "type": "qa_best_answer", "issue_number": 2}
{"instruction": "Provide a comprehensive answer to this question: CORSMiddleware not work", "input": "Hi,\r\nI searched the FastAPI documentation( https://fastapi.tiangolo.com/tutorial/cors/). But get errors:\r\nAccess to XMLHttpRequest at \"http://127.0.0.1:8086/api\" from origin \"http://www.example.com\" has been blocked by CORS policy:Response to preflight request doesn't pass access control check:No 'Access-Control-Allow-Origin' header is present on the requeste resource.\r\n\r\n\"http://127.0.0.1:8086/api\" and \"http://www.example.com\" are in same pc.\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=[\"*\"],      \r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"], \r\n    allow_headers=[\"*\"],\r\n)", "output": "How do you make the request? Could you use the web devtools to see how the request look like (with HTTP headers)?\r\n\r\nAlso you may want to follow the issue template.\n\n---\n\n> How do you make the request? Could you use the web devtools to see how the request look like (with HTTP headers)?\r\n> \r\n> Also you may want to follow the issue template.\r\n\r\nvar apiUrl = \"http://127.0.0.1:8086/api\"; \r\nvar data-from = {  };\r\n$.ajax({\r\n        url: apiUrl,\r\n        type: 'POST',\r\n        data: JSON.stringify(data-from),\r\n        contentType: 'application/json;charset=utf-8',\r\n        dataType: 'json',                 \r\n        cache: false,\r\n        crossDomain: true,\r\n        async: true,\r\n       success: function (data) {\r\n               alert(JSON.stringify(data));                       \r\n       },\r\n       error: function (data, err) {\r\n             alert(\"fail \" + JSON.stringify(data) + \" \" + JSON.stringify(err));\r\n       }\r\n});\r\n\r\nClient:\r\nAccept: */*\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: zh-CN,zh;q=0.9\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36\r\nAccess-Control-Request-Headers: content-type\r\nAccess-Control-Request-Method: POST\r\n\r\nResponse:\r\nHTTP/1.1 502 Fiddler\n\n---\n\nYou should add `CORSMiddleware` like this:\r\n\r\n```python\r\napp.add_middleware(\r\nCORSMiddleware,\r\nallow_origins=[\"*\"], # Allows all origins\r\nallow_credentials=True,\r\nallow_methods=[\"*\"], # Allows all methods\r\nallow_headers=[\"*\"], # Allows all headers\r\n)\r\n```\n\n---\n\nPlease note that Safari does not support the wildcard `*` in some fields.\r\nIf wildcard is used in the middleware config, the middleware should explicitly send all values being used.\r\nSource:\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers#Browser_compatibility\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods#Browser_compatibility\n\n---\n\nI seem to be running into the same issue:\r\n\r\n```python\r\napp = FastAPI()\r\napp.add_middleware(CORSMiddleware, allow_origins=[\"*\"])\r\n\r\n@app.post(\"/tokenize/\", summary=\"Process batches of text\", response_model=ResponseModel)\r\ndef tokenize(query: RequestModel):\r\n    # do stuff\r\n```\r\nbut after a POST request from my React front-end, console notifies me: \r\n\r\n```\r\nAccess to fetch at 'http://127.0.0.1:8000/tokenize/' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\r\n```", "source": "issue", "type": "qa_comprehensive", "issue_number": 2}
{"instruction": "Chineses translations\n\nDetails:\n## Chinese translation tracking\r\n\r\n### Is your feature request related to a problem\r\n\r\nIs your feature request related to a problem?\r\n\r\nI want to be able to track chapters that are in progress or already translated.\r\n\r\n### The solution you would like\r\n\r\nEach person who is working in a chapter should notify in this issue. Comment with the name of the file. If more than two weeks are passed, other people can take this file.\r\n\r\n### Describe alternatives you've considered\r\n\r\nWe use notion to distribution chapter and tracking translating  sate.\r\nIf you want join our, you can contact with us.  @waynerv @RunningIkkyu \r\n\r\n### Additional context\r\nIt â€™s okay to talk about this in this issue.", "input": "Repository: FastAPI\nLabels: ", "output": "Add Chinese translation for tutorial/cookie-params.md. https://github.com/tiangolo/fastapi/pull/2261", "source": "issue", "type": "qa_best_answer", "issue_number": 1}
{"instruction": "Provide a comprehensive answer to this question: Chineses translations", "input": "## Chinese translation tracking\r\n\r\n### Is your feature request related to a problem\r\n\r\nIs your feature request related to a problem?\r\n\r\nI want to be able to track chapters that are in progress or already translated.\r\n\r\n### The solution you would like\r\n\r\nEach person who is working in a chapter should notify in this issue. Comment with the name of the file. If more than two weeks are passed, other people can take this file.\r\n\r\n### Describe alternatives you've considered\r\n\r\nWe use notion to distribution chapter and tracking translating  sate.\r\nIf you want join our, you can contact with us.  @waynerv @RunningIkkyu \r\n\r\n### Additional context\r\nIt â€™s okay to talk about this in this issue.", "output": "Add Chinese translation for tutorial/cookie-params.md. https://github.com/tiangolo/fastapi/pull/2261\n\n---\n\nAdd chinese translate for tutorial-middleware. #2334\n\n---\n\nchinese translate python-types.md Add `Generic types` Fix `Optional` #2360\n\n---\n\ndocs/zh query_params.md rm superfluous content #2384\r\nThe last chapter \"Optional ç±»åž‹å£°æ˜Ž\" not exists any more in English tutorial, and tutorial007.py not exists too. so this chapter should be removed.\n\n---\n\ndocs/zh body.md fix code highlight #2385\r\nFix code highlight lines and add two tips.", "source": "issue", "type": "qa_comprehensive", "issue_number": 1}
{"instruction": "How was this issue resolved: Would be nice to be able to route request using header's Accept field (or generic header's field)", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nN.A.\n```\n\n\n### Description\n\nIn some cases would be nice to specify header's field as routing rules.\r\n\r\nOne important example is to support API versioning based on Header's Accept field\n\n### Wanted Solution\n\nAbility to specify some header's fields in the `.get()`, `.post()` .... decorators\n\n### Wanted Code\n\n```python\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.0\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", accept=\"application/json;version=1.1\")\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\n```\n\n\n### Alternatives\n\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.0\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.0\"}\r\n\r\n@app.get(\"/\", headers={\"accept\": \"application/json;version=1.1\"})\r\nasync def root():\r\n    return {\"message\": \"Hello World v1.1\"}\r\n\n\n### Operating System\n\nmacOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\npython -c \"import fastapi; print(fastapi.__version__)\"\n\n### Python Version\n\nPython 3.9.7\n\n### Additional Context\n\n_No ", "output": "Resolution:\nI contributed PR #4727 that merges the open-api descriptions for routes that overlap on path and method (as in the examples [above](https://github.com/tiangolo/fastapi/issues/3910#issuecomment-1024132161)). \r\n\r\nThe current version of fast api just keeps the last operation description for each path and method. ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 118}
{"instruction": "How was this issue resolved: Need help tracking API usage", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom typing import Callable\r\nfrom fastapi import Request, Response, Depends\r\nfrom fastapi.routing import APIRoute\r\nfrom server.routes.users import fastapi_users\r\nfrom server.models.users import *\r\n\r\nclass session_log(APIRoute):\r\n    def get_route_handler(self) -> Callable:\r\n        original_route_handler = super().get_route_handler()\r\n\r\n        async def custom_route_handler(request: Request,\r\n        user: User = fastapi_users.get_current_user\r\n        ) -> Response:\r\n            response: Response = await original_route_handler(request)\r\n            # print(f\"route response: {response}\")\r\n            try:\r\n                print(\"User\", str(user))\r\n            except Exception as e:\r\n                print(f\"Error : {e}\")\r\n            return response\r\n\r\n        return custom_route_handler\r\n```\r\n\r\n\r\n### Description\r\n\r\nHi, I'm looking for a way to track api usage on user basis. We are using fastapi-users for user management. Can anyone please suggest a way to do this. I tried using a custom API Router but was unable to fetch user details as it done through dependency injection and I kept getting errors like Depends object ha", "output": "Resolution:\nA similar issue would be\r\nhttps://github.com/tiangolo/fastapi/issues/991\r\nApparently the user who asked this solved it but the solution is not provided\r\nAlso this stack overflow doubt\r\nhttps://stackoverflow.com/questions/69913998/how-to-get-current-active-user-in-middleware-fastapi-python", "source": "issue_closed", "type": "qa_resolution", "issue_number": 117}
{"instruction": "How was this issue resolved: Scale FastApi with sync endpoints", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport logging\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\nlogger = logging.getLogger()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    logger.info(f\"Running on {os.getpid()}\")\r\n    time.sleep(3600)\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nI've noticed lately that we have some latency problems when the servers are busy. I dived into it and found out that, if for example, I have four uvicorn workers, while one worker is very busy, the rest three are significantly less busier. That has two problems - \r\n1. We're not taking advantage of all our parallelism power\r\n2. We're suffering more from Python's GIL problems on the same worker.\r\n\r\nIn the example code, if I run it with `gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000`, the first five requests will result in the following output - \r\n```\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 643\r\nINFO:root:Running on 642\r\n```\r\n\r\nI investigated uvicorn workers and found out they use asyncio [server](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.Server) interface, which ac", "output": "Resolution:\n-> https://github.com/tiangolo/fastapi/issues/3091#issuecomment-824193131", "source": "issue_closed", "type": "qa_resolution", "issue_number": 116}
{"instruction": "How was this issue resolved: [Feature Request - Community Feedback needed] Additional Responses", "input": "How do we add additional responses (e.g. 401, 403, 500, etc..) to the documentation other than the default 200 response and the 422 validation error response?", "output": "Resolution:\nI Would like to add the header in a response, using a model Pydantic, but the documentation mentioned is not availibled, how can i do it?\r\nThe link is not working: https://fastapi.tiangolo.com/tutorial/additional-responses/\r\n\r\n![Captura de pantalla 2024-05-14 181214](https://github.com/tiangolo/fastapi/assets/29127489/5ef82c9b-cb94-45ec-a3db-084a410d5e5a)\r\n\r\nI would like to add a Header, like this:\r\n\r\n![imagen](https://github.com/tiangolo/fastapi/assets/29127489/432fa114-0855-481f-b1ee-7b1253b41064)\r\n\r\nSomebody knows, how i can do this? \r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 115}
{"instruction": "How was this issue resolved: How to pass list in query parameters?", "input": "**Description**\r\n\r\nI need to support several query parameters with same name in GET route. Typical request looks like this:\r\nhttp://localhost/item?num=1&num=2\r\n\r\nI configured a route\r\n````\r\n@app.get(\"/item\", content_type=UJSONResponse)\r\nasync def get_part(num: list):\r\n    found = False\r\n    for i in num:\r\n         if i in some_data:\r\n             found = True\r\n             break\r\n    return {\"found\": found}\r\n````\r\nThe idea is, that I can pass several numbers to check, if they exist in some_data. In my opinion, it is not a good idea to get numbers from body here, because it is a simple GET request, but in current version application expects argument \"num\" in body, so on my request (written above) I receive a response\r\n\r\n`{\"detail\":[{\"loc\":[\"body\",\"num\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}`\r\n\r\nAs I know, it is not restricted to pass several query parameters with the same name in an HTTP request by any specifications, so I would like to ask, is it possible to configure a route in FastAPI, which will be able to parse several query parameters with the same name?", "output": "Resolution:\n> what about using a query param with a separated string by a comma? for example: /foo?id=x,y,z expected behavior to get it in fast API like [x,y,z] currently we get it as a List with one string which is \"x,y,z\"\r\n> \r\n> is there planning to support it? or is there any patch code for it?\r\n\r\nfoo: List[str] = Query(â€¦) is \r\n/users?foo=a&foo=b&foo=c", "source": "issue_closed", "type": "qa_resolution", "issue_number": 114}
{"instruction": "How was this issue resolved: Only show documentation while logged in", "input": "**Description**\r\n\r\nIs it possible to only show the documentation based on being logged in? Many times I create an API which should only expose it's documentation when somebody is logged in.", "output": "Resolution:\n> Yes, it is relatively easy to add dependencies to those endpoints. You can create your `FastAPI` removing the automatic docs endpoints: https://fastapi.tiangolo.com/tutorial/application-configuration/#docs-urls\r\n> \r\n> And then you can create them by hand, using the utils from `fastapi.openapi.docs`, there's a `get_swagger_ui_html` and `get_redoc_html` functions. There you can create the endpoints/path operations as normally.\r\n> \r\n> But the next problem (probably the main one) is how to authenticate the user and where, outside the docs endpoints.\r\n\r\nJust wanted to update the docs-urls link: https://fastapi.tiangolo.com/tutorial/metadata/#docs-urls\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 113}
{"instruction": "How was this issue resolved: How to work with form data?", "input": "Hello everyone!\r\nI need to process form data but I can't do that with fastapi. To try understand how can I do it I used Postman to send data in different ways:\r\nfrom form-data tab\r\nfrom x-www-form-urlencoded\r\nwith header \"Content-Type: application/x-www-form-urlencoded\"\r\nwith header \"Content-Type: application/json\"\r\nwithout headers\r\n\r\nIn any case I have the same result: {\"detail\": \"There was an error parsing the body\"}.\r\n\r\n![postman](https://user-images.githubusercontent.com/22984590/57228831-54404d80-7047-11e9-8fa6-4502b8a29dca.png)\r\n\r\n```\r\nfrom fastapi import FastAPI, HTTPException, Form\r\n\r\n@app.post(\"/subscription_email\")\r\ndef subscription_email(*, customers: int = Form(...)):\r\n    return customers\r\n```\r\nCode based on example from docs.\r\n\r\nPlease, help me to fix it and understand how to work woth form data from POST requests.", "output": "Resolution:\n> > @zaitompro you can use the request directly: [fastapi.tiangolo.com/tutorial/using-request-directly](https://fastapi.tiangolo.com/tutorial/using-request-directly/)\r\n> > And from it, you can extract the body without validation.\r\n> \r\n> This is required because I cannot declare a form parameter with a nested name (because it's not valid Python syntax), correct?\r\n> \r\n> ```\r\n> @app.post('/subscriptions', response_class=HTMLResponse)\r\n> async def create_subscription(\r\n>         request: Request,\r\n> \t\t# NOT VALID PYTHON\r\n>         'subscription[customer_attributes][reference]': Form(...)\r\n>         ):\r\n> ```\r\n> \r\n> My form data names are nested, e.g.:\r\n> \r\n> ```\r\n> [gatekeeper] (b'product_handle=coreweave-cloud&subscription%5Bcustomer_attributes%5D%5Brefer'\r\n> [gatekeeper]  b'ence%5D=tenant-test&subscription%5Bcustomer_attributes%5D%5Bfirst_name%5D=Ma'\r\n> [gatekeeper]  b'tt&subscription%5Bcustomer_attributes%5D%5Blast_name%5D=Campbell&subscriptio'\r\n> [gatekeeper]  b'n%5Bcustomer_attributes%5D%5Bemail%5D=&subscription%5Bcustomer_attributes%5D'\r\n> [gatekeeper]  b'%5Bphone%5D=&subscription%5Bcustomer_attributes%5D%5Borganization%5D=&subscr'\r\n> [gatekeeper]  b'iption%5Bpayment_profile_attributes%5D%5Bfirst_name%5D=&subscription%5Bpayme'\r\n> [gatekeeper]  b'nt_profile_attributes%5D%5Blast_name%5D=&subscription%5Bpayment_profile_attr'\r\n> [gatekeeper]  b'ibutes%5D%5Bfull_number%5D=&subscription%5Bpayment_profile_attributes%5D%5Bc'\r\n> [gatekeeper]  b'vv%5D=&subscription%5Bpayment_profile_attributes%5D%5Bexpiration_month%5D=&s'\r\n> [gatekeeper]  b'ubscription%5Bpayment_profile_attributes%5D%5Bexpiration_year%5D=&subscripti'\r\n> [gatekeeper]  b'on%5Bpayment_profile_attributes%5D%5Bbilling_zip%5D=&subscription%5Bagree_to'\r\n> [gatekeeper]  b'_terms%5D=on')\r\n> ```\r\n> \r\n> Assuming I am unable to rename my form input names, I _must_ fallback to using raw request body/data, right?\r\n\r\n\r\nI managed to solve the problem as follows.\r\nI hope this helps someone.\r\n```\r\nfrom fastapi import FastAPI, Form\r\nimport uvicorn\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post(\"/test\")\r\nasync def leads_data(responsible_id: str = Form(alias='leads[responsible][0][id]'),\r\n                responsible_user_id: str = Form(alias='leads[responsible][0][responsible_user_id]'),\r\n                account_id: str = Form(alias='account[id]'),\r\n                subdomain: str = Form(alias='account[subdomain]')):\r\n    result = dict(responsible_id=responsible_id, responsible_user_id=responsible_user_id,\r\n                  account_id=account_id, subdomain=subdomain)\r\n\r\n    print(result)\r\n    print()\r\n    return {\"STATUS\": \"OK\"}\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 112}
{"instruction": "How was this issue resolved: Choices Dropdown Menu in API Documentation", "input": "**Feature Request:**\r\n\r\nIt would be nice to document in the API, which what choices are available to the user as a drop-down menu in the UI. It helps prevent such documentation in the description\\help of the parameter.  \r\n\r\n**Context**\r\n`flask_restplus` library is able to show choices in its Swagger UI, and is able to handle if incorrect choice is provided as an input by the user.  \r\n![Selection_005](https://user-images.githubusercontent.com/43503284/58156014-6dffa880-7c75-11e9-9d35-3c32150a3596.png)\r\n\r\n**Preferred Solution:**\r\nWould like to see `choices` parameter added to possibly `fastapi.Query` class and possibly other classes that handle input from user. \r\nWould be awesome if it was something like this\r\n```\r\n@api.get('/get_countries')\r\ndef get_something(\r\n    choice: str = Query('eu', choices=('eu,'us','cn,'ru'), description='foo bar')\r\n):\r\n    do_something(choice)\r\n``` \r\n\r\nWould be nice to see this feature in `FastAPI`, as I/We would prefer to use `FastAPI` over `flask_restplus`.", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 111}
{"instruction": "How was this issue resolved: Add support for Pydantic's dataclasses", "input": "**Describe the question**\r\nI am using a  pydantic.dataclasses.dataclass as a response_model of my fast api route.\r\n\r\n\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic.dataclasses import dataclass\r\n\r\n\r\n@dataclass\r\nclass Foo:\r\n    bar: int\r\n\r\napp = FastAPI()\r\n\r\n@app.get('/foo', response_model=Foo)\r\ndef get_bar() -> Foo:\r\n    return Foo(bar=1)\r\n```\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. Create a file **app.py** with the above code.\r\n2. Start the app: `uvicorn app:app`\r\n3. Open the browser and go to **localhost:8000/foo**\r\n4. See error: \r\n```\r\npydantic.error_wrappers.ValidationError: 1 validation error\r\nresponse\r\n  __init__() got an unexpected keyword argument '__initialised__' (type=type_error)\r\n```\r\n\r\n**Expected behavior**\r\nNo validation error and serialized json does not contain any keys `__initialised__`.\r\n\r\n\r\n**Environment:**\r\n - OS: Linux\r\n - FastAPI Version 0.25.0\r\n- Python version 3.7.3", "output": "Resolution:\nThanks for the discussion everyone. If any of you is still having issues related to this, please create a new issue following the template.\r\n\r\n> Sorry for the long delay! ðŸ™ˆ  I wanted to personally address each issue and they piled up through time, but now I'm checking each one in order.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 110}
{"instruction": "How was this issue resolved: Issue when debugging inside docker", "input": "**Describe the bug**\r\nWhen I run pdb in docker I run into issues if I have reload enabled.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom starlette.requests import Request\r\n\r\nimport sys\r\nsys.path.insert(0, '.')\r\nfrom app.api.api import api_router\r\nfrom app.core import config\r\nfrom app.db.session import Session\r\n\r\n\r\napp = FastAPI(title='App')\r\napp.include_router(api_router, prefix=config.API_V1_STR)\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def db_session_middleware(request: Request, call_next):\r\n   \r\n    # This set_trace crashes only if I started uvicorn with `debug=True`\r\n    import pdb; pdb.set_trace()\r\n   \r\n    request.state.db = Session()\r\n    response = await call_next(request)\r\n    request.state.db.close()\r\n    return response\r\n\r\n\r\n# For debugging\r\nif __name__ == \"__main__\":\r\n    import uvicorn\r\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=80, reload=True, debug=True)\r\n```\r\n\r\n**Expected behavior**\r\nI should be able to use pdb, but instead get an `bdb.BdbQuit` exception. This doesn't happen if I run outside docker or if I run inside docker but remove `reload=True` argument.\r\n\r\n**Environment:**\r\n`FROM tiangolo/uvicorn-gunicorn:python3.7`", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 109}
{"instruction": "How was this issue resolved: Post results to Error 405 Method not Allowed", "input": "Used the very code on the docs for simple posting and it only allows me to use get", "output": "Resolution:\nHi, I'm trying to use the fast api with Stable Difussion UI -- the Automatic 1111\r\nI installed Automatic1111 the webui works on [gradio.app](http://gradio.app/)\r\n\r\n\r\ni tried to follow this : https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/API\r\nbut I get the error:\r\n---------------------------------------------------------------------------\r\nKeyError Traceback (most recent call last)\r\nCell In[24], line 35\r\n31 r = response.json()\r\n32 print(\"Got response\")\r\n---> 35 for i in r['images']:\r\n36 image = [Image.open](http://image.open/)(io.BytesIO(base64.b64decode(i.split(\",\",1)[0])))\r\n38 png_payload = {\r\n39 \"image\": \"data:image/png;base64,\" + i\r\n40 }\r\n\r\nKeyError: 'images'\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 108}
{"instruction": "How was this issue resolved: Handling Exception Response format", "input": "Hello.\r\nI want to change the validation error response and make it inside `app` object.\r\n\r\nI've found this example:\r\n```\r\n@app.exception_handler(RequestValidationError)\r\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\r\n    return JSONResponse(\r\n        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,\r\n        content=jsonable_encoder({\"detail\": exc.errors(), \"body\": exc.body}),\r\n    )\r\n```\r\n\r\nBut can't understand how to add this function to `app` object without decorator:\r\n```\r\napp = FastAPI(\r\n    title='Bla API',\r\n    description='Bla description',\r\n    APIRoute('/api', api.toggle, methods=['POST'],\r\n             description='Switch interface state',\r\n             response_description='Interface successfully switched',\r\n             response_class=JSONResponse,\r\n             response_model=api.Success,\r\n             responses={**api.post_responses},\r\n             ),\r\n...\r\n\r\n```", "output": "Resolution:\n@MacMacky Ok. Thanks again for your help.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 107}
{"instruction": "How was this issue resolved: about qps", "input": "# Description\r\n\r\nThe simple get 'hello world' server crashed when I send more than 510 requests in a second to the fastAPI.\r\n\r\n```\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return \"Hello World\"\r\n```\r\n\r\nHow to improve qps for it?\r\n\r\nIâ€˜ve checked and can't find an effective way in question[https://github.com/tiangolo/fastapi/issues/603](https://github.com/tiangolo/fastapi/issues/603) or any other issues.\r\n\r\nMy environments:\r\nwin10 1903\r\nPython 3.7.5 64bit\r\nfastapi 0.52.0\r\nuvicorn 0.11.3\r\n\r\nused module grequests to send the requests.\r\n```\r\nimport grequests, time, collections\r\n\r\ndef qps_test(url, N):\r\n    start_time = time.time()\r\n    res_list = grequests.map([\r\n        grequests.get(url) \r\n        for _ in range(N)\r\n    ])\r\n    print(f'time: {time.time() - start_time}\\nstatue_code:')\r\n    print('\\n'.join(\r\n        f'{k}: {v}'\r\n        for k, v in collections.Counter(\r\n            res is None and 'LOST' or res.status_code\r\n            for res in res_list\r\n        ).items()\r\n    ))\r\n\r\nif __name__ == '__main__':\r\n    qps_test('http://127.0.0.1:8000/', 500)\r\n    # qps_test('http://127.0.0.1:8000/', 511) #crashed\r\n```\r\n\r\n`uvicorn main:app --reload` run in cmd (follow the docs).\r\nand i also tried `uvicorn main:app` , the same.\r\n\r\nerror message:\r\n\r\n`Process SpawnProcess-1:\r\nTraceback (most recent call last):\r\n  File \"d:\\python37\\lib\\multiprocessing\\process.py\", line 297, in _bootstrap\r\n    self.run()\r\n  File \"d:\\python37\\lib\\multiprocessing\\process.py\", line 99, in run\r\n    self._target(*self._args, **self._kwargs)\r\n  File \"d:\\python37\\lib\\site-packages\\uvicorn\\subprocess.py\", line 61, in subprocess_started\r\n    target(sockets=sockets)\r\n  File \"d:\\python37\\lib\\site-packages\\uvicorn\\main.py\", line 382, in run\r\n    loop.run_until_complete(self.serve(sockets=sockets))\r\n  File \"d:\\python37\\lib\\asyncio\\base_events.py\", line 566, in run_until_complete\r\n    self.run_forever()\r\n  File \"d:\\python37\\lib\\asyncio\\base_events.py\", line 534, in", "output": "Resolution:\nAssuming the original issue was solved, it will be automatically closed now. But feel free to add more comments or create new issues.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 106}
{"instruction": "How was this issue resolved: Use TestClient in an async fashion", "input": "### Is your feature request related to a problem\n\nUnfortunately, test client runs it's own event loop. This causes an issue when attempting to do other async operations in the background.\nRunning it inside an executor will cause it to run in a different threat, which in turn causes issues with other async libraries a they're calling coroutines from a different thread.\n\n### The solution you would like\n\nMake a TestClient that doesn't create it's own loop. Just have it async. \n\n### Describe alternatives you've considered\n\nOther than executor or partching fastapi, there are no alternatives.", "output": "Resolution:\nHi! I made my own short workaround for async WebSocket testing in FastAPI / Starlette apps:\nhttps://gist.github.com/AivanF/4616d7e89fb5ea497deda31201db2c60\n\nI also suggested Starlette maintainers to let me make a pull request so this will work out of the box: https://github.com/encode/starlette/discussions/2897\nPlease upvote if you'd like to see this feature available (and to see me working hard keeping community standards ðŸ˜…)", "source": "issue_closed", "type": "qa_resolution", "issue_number": 105}
{"instruction": "How was this issue resolved: FastAPI and Uvicorn is running synchronously and very slow", "input": "I'm new in FastAPI and i'm testing file uploads and asyncronous requests. However, when i perform several request with clients parallel and serial the FastAPI process each upload in Queue (synchronously) and very slow. I'm performing the API with uvicorn and gunicorn and with 1 worker. With both execution the time spent was the same.\r\n\r\nMy client send 4 files with approximately 20MB in parallel (or in serial) for FastAPI endpoint, however, it is storing the files one at a time and very slow.\r\n\r\nI made the same upload with a aiohttp endpoint and the files was stored in approximately 0.6 seconds with client making request in parallel (multiprocessing) and 0.8 seconds with client making request in serial (in mean). When i made this uploads in FastAPI the files was stored in approximately 13 seconds with client making parallel request and 15 seconds with client making serial request (in mean)\r\n\r\nWould I like know if i'm making anything wrong?\r\n\r\n\r\n### Server Code\r\n\r\n```python\r\n\r\n# app.py\r\n\r\nfrom fastapi import FastAPI, File, UploadFile\r\nimport random\r\nimport aiofiles\r\nimport os\r\n\r\napp = FastAPI()\r\n\r\nSTORAGE_PATH = 'storage'\r\n\r\n@app.post(\"/\")\r\nasync def read_root(file: UploadFile=File('teste')):\r\n    fpath = os.path.join(\r\n        STORAGE_PATH, f'{random.randint(0, 5000)}_{file.filename}'\r\n    )\r\n    async with aiofiles.open(fpath, 'wb') as f:\r\n        content = await file.read()\r\n        await f.write(content)\r\n\r\n    return {\"Test\": \"Test\"}\r\n\r\n\r\n# uvicorn app:app --host 0.0.0.0 --port 8000 --workers 1\r\n# gunicorn -w=1 -k=uvicorn.workers.UvicornWorker --bind=0.0.0.0:8000 app:app\r\n```\r\n\r\n\r\n### Client Code\r\n```python\r\nFILES = ['f1.txt', 'f2.txt', 'f3.txt', 'f4.txt' ]\r\n\r\ndef request(fname):\r\n    files = {'file': open(fname,'rb')} \r\n    requests.post(\"http://localhost:8000/\", files=files)\r\n\r\n\r\ndef req_mp():\r\n    start = datetime.now() \r\n    pool = Pool(4) \r\n    pool.map(request, FILES) \r\n    print(datetime.now() - start)\r\n\r\n\r\ndef req_serial():\r\n    start = datetime.now()  \r\n", "output": "Resolution:\n@dspashish this question is many variable depending on context, but, i did make some benchmark between (Django, Flask, Aiohttp and FastAPI) and i got some important results. In this benchmark that i did, i did make the upload with some (in parallel) files from 30MB to 100MB, i did the processing and store the data in the database. The best results was AioHTTP and Flask, both in  I/O of file and processing and  in I/O of database. In special, the best result was AioHTTP because of your asyncronous I/O. \r\n\r\nIn this benchmark the FastAPI did not have good result because of this slowness in file upload, but, in the theory FastAPI is to be more fast than django because of your simplified structure, (not have a stack of middleaware as Django), is based in starlette that is a microframework optimezed for process more request and has a rapid serialization of result (and is a assyncronous framework that permit make I/O non blocking). this in the theory, in practise very things can change.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 104}
{"instruction": "How was this issue resolved: Depends object returned instead of session", "input": "I am currently trying to migrate from flask to fastapi and trying to keep my files separated. My depends is not called from my routes but from within my crud file but similar to the documentation for relational databases: https://fastapi.tiangolo.com/tutorial/sql-databases/\r\n\r\nThis was my initial way of using a database session which is similar to the sqlalchemy docs\r\nAlso, is this bad practice or is it okay to use this and a mix of depends? I did kind of want to decouple sqlalchemy from fastapi.\r\n```python\r\ndef get_database():\r\n    db = scoped_session(default_session)\r\n    try:\r\n        yield db\r\n    finally:\r\n        db.close()\r\n\r\ndef get_references(db: scoped_session = next(get_database())):\r\n    references = db.query(Reference).all()\r\n    return references\r\n```\r\n\r\nI then tried to switch and use Depends but am getting the same issue as others below with my attempts added at the end:\r\n\r\n> > I am seeing this same issue in .52 using almost verbatim the doc examples with postgres. Depends is not calling the function but returning what appears to be an instantiate Depends object.\r\n> \r\n> @pspierce and @H0r53, Did you solve this? I am seeing in 0.58.1. I also tried: instead of using generator, returning the db directly -- same problem.\r\n\r\n```python\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import scoped_session, sessionmaker\r\n\r\nengine = create_engine('postgresql://postgres:postgres@localhost:5432/postgres', echo=True)\r\ndefault_session = scoped_session(sessionmaker(autocommit=False,\r\n                                         autoflush=False,\r\n                                         bind=engine))\r\n\r\ndef get_database():\r\n    db = default_session()\r\n    try:\r\n        yield db\r\n    finally:\r\n        db.close()\r\n\r\n```\r\n\r\n\r\nFirst error I got:\r\n\r\n> AttributeError: 'Depends' object has no attribute 'query'\r\n\r\n```python\r\nfrom database.data import get_database, scoped_session\r\nfrom database.models.reference import Reference\r\nfrom fastapi import Depends\r\n\r\n\r\ndef ge", "output": "Resolution:\n> Feel free to provide a comment to the documentation with a PR. I would disagree with most of your statements and nowhere in the docs is implied that the DI system of FastAPI works **outside** the context of FastAPI.\r\n> \r\n> If you think its insulting that the easiness of said methodology is stressed in the docs, then you might be able to rephrase those bits as well if your at it :)\r\n\r\nI'm sorry, but I can't agree I could write any acceptable documentation about a feature that I still don't understand after several months of fighting against. I think it would be wasting anyone's time.\r\n\r\nI'm personally very much opposed to \"intuitive and powerful\" implicit machinery, they don't fit my mental model. They set expectations which don't hold for first time users if something changes or goes wrong. That is my personal limitation which can't be generalised without additional evidence.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 103}
{"instruction": "How was this issue resolved: AsyncClient ignores the startup and shutdown events", "input": "This is very close to #1072, but for AsyncClient.\r\n\r\nThe problem is that AsyncClient ignores the startup and shutdown events. \r\n\r\n# To Reproduce\r\n\r\nSteps to reproduce the behavior with a minimum self-contained file.\r\n\r\nReplace each part with your own scenario:\r\n- Create a main.py file with:\r\n\r\n```python\r\nfrom fastapi import FastAPI, Request\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def read_main():\r\n    return {\"msg\": \"Hello World\"}\r\n\r\n\r\nasync def add_test_header(request: Request, call_next):\r\n    response = await call_next(request)\r\n    response.headers[\"X-Test-Header\"] = 'Hello'\r\n    return response\r\n\r\n\r\n@app.on_event(\"startup\")\r\ndef setup():\r\n    # example code that runs on startup\r\n    global add_test_header\r\n    print('executing startup!!')\r\n    add_test_header = app.middleware(\"http\")(add_test_header)\r\n```\r\n\r\n- Create a test_startup.py file with:\r\n\r\n```python\r\nimport pytest\r\n\r\nfrom httpx import AsyncClient\r\n\r\nfrom main import app\r\n\r\n\r\n@pytest.fixture()\r\nasync def client():\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as \r\n        yield client\r\n\r\n\r\n@pytest.mark.asyncio\r\nasync def test_read_main(client):\r\n    response = await client.get(\"/\")\r\n    assert response.status_code == 200\r\n    assert response.json() == {\"msg\": \"Hello World\"}\r\n    assert 'X-Test-Header' in response.headers\r\n```\r\nRun pytest -s -v test_startup.py\r\nYou will see an AssertionError for the X-Test-Header not being there\r\nThe test should pass\r\n\r\n\r\n\r\nSo far I am using a hack to make it work:\r\n```python\r\n@pytest.fixture()\r\nasync def client():\r\n    \"\"\"Test client pytest fixture.\r\n\r\n    Example:\r\n        >>> from httpx import Response\r\n        >>>\r\n        >>>\r\n        >>> @pytest.mark.asyncio\r\n        >>> async def test_health_check(client):\r\n        >>>    resp: Response = await client.get(\"/health_check\")\r\n        >>>    assert resp.status_code == 200\r\n\r\n    \"\"\"\r\n    app = build_app()\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as client:\r\n        await connect", "output": "Resolution:\n\r\n> @j-carson: Then, in my tests, I have a fixture that creates a brand new FastAPI instance for each test function so that nothing gets confused by all the new event loops being created and destroyed under the covers by pytest-asyncio.\r\n\r\nWas getting the error\r\n>  TypeError: 'async_generator' object is not callable\r\n\r\nDepending on your options with `pytest-asyncio`, you will want to declare those fixtures as `@pytest_asyncio.fixture`.\r\nhttps://github.com/pytest-dev/pytest-asyncio#async-fixtures\r\n\r\nYou don't need to worry about this if you have set `asuyncio_mode = auto` in `pytest.ini` or similar.\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 102}
{"instruction": "How was this issue resolved: Error 422: Unprocessable entity when I send form data from JS script", "input": "#### Backend\r\n```py\r\nfrom fastapi import FastAPI, File, Form, UploadFile, Request\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\n\r\norigins = [\"http://127.0.0.1:5500\"]\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=origins,\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n\r\n@app.post(\"/test\")\r\ndef test(username: str = Form(...)):\r\n    print(f\"########### Received {username} #############\")\r\n```\r\n### Frontend\r\n```js\r\nasync function sendData() {\r\n    formData = new FormData();\r\n    formData.append('username', 'Kareem');\r\n    const response = await fetch('http://127.0.0.1:8000/test', {\r\n        method: 'POST',\r\n        data: formData\r\n    })\r\n    console.log(response)\r\n```\r\n### Response\r\n```\r\nResponse {\r\nbody: (...)\r\nbodyUsed: false\r\nheaders: Headers {}\r\nok: false\r\nredirected: false\r\nstatus: 422\r\nstatusText: \"Unprocessable Entity\"\r\ntype: \"cors\"\r\nurl: \"http://127.0.0.1:8000/test\"\r\n__proto__: Response }\r\n```\r\n### Description\r\n- The `/test` endpoint is simply supposed to recieve a form containing only `username` and print it out.\r\n- When I test the API using swagger docs it works fine as expected, but when I try to send form data from an external script it throws me this error and that response object above.\r\n### Environment\r\n- OS: Linux\r\n- FastAPI version: 0.61.1\r\n- Python version: 3.8.2", "output": "Resolution:\nHello, I ran into the same issue, using fetch and XMLHttpRequest.\r\n@kareemamrr Do you have any explanation what append at your end that caused that 422 error? I'm struggling with that since 2 weeks, without any progress.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 101}
{"instruction": "How was this issue resolved: FastAPI+Uvicorn is running slow than Flask+uWSGI", "input": "I'm new to fastapi and I'm trying to test speed between fastapi and flask, but I didn't get a better result by fastapi. pls tell me if I'm making anything wrong?\r\n\r\n### Example\r\n1. fastapi\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI(debug=False)\r\n\r\n@app.get(\"/\")\r\nasync def run():\r\n    return {\"message\": \"hello\"}\r\n```\r\n+ run command: `uvicorn --log-level error --workers 4 fastapi_test:app > /dev/null 2>&1 `\r\n\r\n2. flask\r\n```Python\r\nimport flask\r\n\r\napp = flask.Flask(__name__)\r\n\r\n@app.route(\"/\")\r\ndef run():\r\n    return {\"message\": \"hello\"}\r\n```\r\n+ run command: `uwsgi --wsgi-file flask_test.py --process 4 --callable app --http :8000 > /dev/null 2>&1`\r\n\r\n### Result\r\n* use `ab -n 10000 -c 500 http://127.0.0.1:8000/` to test speed\r\n1. FastApi\r\n```\r\nRequests per second:    1533.91 [#/sec] (mean)\r\nTime per request:       325.965 [ms] (mean)\r\nTime per request:       0.652 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          244.17 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0   46 208.1      0    1000\r\nProcessing:     1  268 171.1    245     950\r\nWaiting:        0  201 146.1    174     909\r\nTotal:          1  314 296.7    246    1918\r\n```\r\n2. Flask\r\n```\r\nRequests per second:    1829.40 [#/sec] (mean)\r\nTime per request:       273.313 [ms] (mean)\r\nTime per request:       0.547 [ms] (mean, across all concurrent requests)\r\nTransfer rate:          162.57 [Kbytes/sec] received\r\n\r\nConnection Times (ms)\r\n              min  mean[+/-sd] median   max\r\nConnect:        0   18 131.3      0    1000\r\nProcessing:    12  192 556.3     36    4302\r\nWaiting:        0  191 556.3     35    4301\r\nTotal:         17  210 612.7     36    5300\r\n```\r\n\r\n### Environment\r\n\r\n* OS: CentOS 7\r\n* Python Version: 3.9.1\r\n* FastAPI Version: 0.63.0\r\n\r\n### Additional context\r\n\r\n<!-- Add any other context or screenshots about the question here. -->", "output": "Resolution:\n@Arrow-Li  if you are looking for raw throughput both Flask and FastAPI are limited by WSGI/ASGI servers and framework overhead of course. PyPy can reduce the overhead of Python if used with a server that is made for it. \r\n\r\nTake a look:\r\nhttps://www.techempower.com/benchmarks/#section=test&runid=adce24e2-9277-45b2-845c-3dbce439d727&test=plaintext&l=hra0hr-35r\r\n\r\nSocketify is a web framework and also provides WSGI and ASGI server\r\nhttps://github.com/cirospaciari/socketify.py\r\n\r\nGranian is a WSGI and ASGI server\r\nhttps://github.com/emmett-framework/granian\r\n\r\n\r\nIf you wanna give a performance boost to existing code go with socketify or granian, socketify performs better for now.\r\nIf you wanna move to an entirely new thing,  do not use WSGI or ASGI go for pure socketify.\r\nIf the flask is enough for you, you will find that socketify should be enough too.\r\n\r\nFastAPI is more feature complete than pure socketify, so if performance is not the only critical point, you can use FastAPI + socketify ASGI.\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 100}
{"instruction": "How was this issue resolved: Gunicorn on Google Cloud Run get an 504 error status (Upstream Request Timeout)", "input": "Why my gunicorn always get a 504 error status code when I open my URL from Cloud Runabout 15 seconds for the first time, and after that the URL can be opened without an error. But after I leave it without opening the URL for about 30-60 minutes, it will return the 504 error again? Is my Gunicorn dead/shutdown? Because when i check it from my Cloud Run log, my gunicorn got a `Shutting down`, and I think my gunicorn was dead. So I need to keep my Gunicorn always on, but how can I make it to set my gunicorn always on?\r\n\r\nMy code at startup need to load the Machine Learning Model that got a 1 pickle about 100MB, in my case I need to load 6 pickle file (around 600mb++), and I use FastAPI for my API code.\r\n\r\nThis is how my pickle load :\r\n```python\r\n# Load all model\r\n@app.on_event(\"startup\")\r\nasync def load_model():\r\n    # Pathfile\r\n    pathfile_model = os.path.join(\"modules\", \"model/\")\r\n    pathfile_data = os.path.join(\"modules\", \"data/\")\r\n\r\n    start_time = time.time()\r\n\r\n    # Load Model\r\n    usedcar.price_engine_4w = {}\r\n    top5_brand = [\"honda\", \"toyota\", \"nissan\", \"suzuki\", \"daihatsu\"]\r\n    for i in top5_brand:\r\n        with open(pathfile_model + f'{i}_all_in_one.pkl', 'rb') as file:\r\n            usedcar.price_engine_4w[i] = pickle.load(file)\r\n    with open(pathfile_model + 'ex_Top5_all_in_one.pkl', 'rb') as file:\r\n        usedcar.price_engine_4w['non'] = pickle.load(file)\r\n\r\n    # Load Dataset Match\r\n    with open(pathfile_data + settings.DATA_LIST) as path:\r\n        usedcar.list_match_seva = pd.read_csv(path)\r\n\r\n    elapsed_time = time.time() - start_time\r\n\r\n    print(\"======================================\")\r\n    print(\"INFO  : Model loaded Succesfully\")\r\n    print(\"MODEL :\", usedcar.price_engine_4w)\r\n    print(\"ELAPSED MODEL TIME : \", elapsed_time)\r\n```\r\n\r\nHere are how my main.py code run :\r\n```python\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(app, host=\"0.0.0.0\", port=8080, log_level=\"info\", loop=asyncio)\r\n```\r\n\r\nThis is my Dockerfile :\r\n```Dockerfile\r\nFROM p", "output": "Resolution:\nThanks for the help here everyone! ðŸ‘  ðŸ™‡ \r\n\r\nIf that solves the original problem, then you can close this issue @rudi101101  âœ”ï¸", "source": "issue_closed", "type": "qa_resolution", "issue_number": 99}
{"instruction": "How was this issue resolved: Ability to define response_model with native typing", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass TypicalResponse(BaseModel):\r\n    msg: str\r\n    data: int\r\n\r\n\r\n@app.get(\"/add/{x}/{y}\")\r\nasync def add(x: int, y: int) -> TypicalResponse:\r\n    return TypicalResponse(msg=\"Done!\", data=x + y)\r\n```\r\n\r\n\r\n### Description\r\n\r\nOpen the automatic doc on this handler\r\nSee no output schema defined\r\nI would like to use typing \"-> *Type*\" for annotate response model.\r\nThis is good for simple handlers.\r\n\r\n### Wanted Solution\r\n\r\nI would like to autodoc parse this typing same as \"response_model=TypicalResponse\"\r\n\r\n### Wanted Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n# Same\r\nclass TypicalResponse(BaseModel):\r\n    msg: str\r\n    data: int\r\n\r\n\r\n@app.get(\"/add/{x}/{y}\")\r\nasync def add(x: int, y: int) -> TypicalResponse:\r\n    return TypicalResponse(msg=\"Done!\", data=x + y)\r\n```\r\n\r\n\r\n### Alternatives\r\n\r\nI use kwarg \"response_model\" as single alternative\r\nBut typing already defines the output model, necessary duplicate as result.\r\n\r\n### Operating System\r\n\r\nLinux\r\n\r\n### Operating System Details\r\n", "output": "Resolution:\nI found a corner case with **Any** return annotation, so code block getting bigger, and now it's should be separated for sure.\r\n\r\nRaw&Dirty implementation:\r\n_(fastapi/routing.py, line 600)_\r\n```\r\n    from typing import get_type_hints\r\n\r\n    def api_route(self, ...) -> Callable[[DecoratedCallable], DecoratedCallable]:\r\n        def decorator(func: DecoratedCallable) -> DecoratedCallable:\r\n            nonlocal response_model\r\n            if response_model is None:\r\n                handler: Callable = func\r\n                while issubclass(type(handler), functools.partial):\r\n                    handler = handler.func\r\n                return_type = get_type_hints(handler).get('return')\r\n                if return_type is not Any:\r\n                    response_model = return_type\r\n\r\n            self.add_api_route(\r\n            ...\r\n```\r\n\r\nIssue found by test_invalid_response_model_raises (thanks to @patrickmckenna).\r\nI think it's potential to be a whole pool of \"ignore _these_ typings, pass 'None' instead of Any, etc.\"", "source": "issue_closed", "type": "qa_resolution", "issue_number": 98}
{"instruction": "How was this issue resolved: Use third party class as property in pydantic schema", "input": "**Describe the bug**\r\nI have a pydantic schema that needs a third party class (bson.objectid.ObjectID) as a property. For this reason I created a custom validator and encoder as per pydantic documentation.\r\n<details><summary>Code</summary>\r\n<p>\r\n\r\n```python\r\nfrom bson.objectid import ObjectId\r\nfrom pydantic import BaseModel\r\nfrom pydantic import validators\r\nfrom pydantic.errors import PydanticTypeError\r\nfrom pydantic.utils import change_exception\r\n\r\nclass ObjectIdError(PydanticTypeError):\r\n    msg_template = 'value is not a valid bson.objectid.ObjectId'\r\n\r\ndef object_id_validator(v) -> ObjectId:\r\n    with change_exception(ObjectIdError, ValueError):\r\n        v = ObjectId(v)\r\n    return v\r\n\r\ndef get_validators() -> None:\r\n    yield validators.not_none_validator\r\n    yield object_id_validator\r\n\r\nObjectId.__get_validators__ = get_validators\r\n\r\ndef encode_object_id(object_id: ObjectId):\r\n    return str(object_id)\r\n\r\nclass UserId(BaseModel):\r\n    object_id: ObjectId = None\r\n\r\n    class Config:\r\n        json_encoders = {\r\n            ObjectId: encode_object_id\r\n        }\r\n\r\nclass User(UserId):\r\n    email: str\r\n    salt: str\r\n    hashed_password: str\r\n\r\n# Just for testing\r\nuser = User(object_id = ObjectId(), email=\"john.doe@example.com\", salt=\"12345678\", hashed_password=\"letmein\")\r\nprint(user.json())\r\n# Outputs:\r\n# {\"object_id\": \"5c7e424225e2971c8c548a86\", \"email\": \"john.doe@example.com\", \"salt\": \"12345678\", \"hashed_password\": \"letmein\"}\r\n```\r\n\r\n</p>\r\n</details></br>\r\n\r\nAs you can see at the bottom of the code, the serialization seems to work just fine. But when I use this schema as an argument (and/or response type) in API operations and then open the automatic documentation, I get presented with an error.\r\n\r\n<details><summary>Code</summary>\r\n<p>\r\n\r\n```python\r\nfrom bson import ObjectId\r\nfrom fastapi import FastAPI\r\nfrom user import User, UserId\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post(\"/user\", tags=[\"user\"], response_model=UserId)\r\ndef create_user(user: User):\r\n    # Create user", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 97}
{"instruction": "How was this issue resolved: How to manage relationships in (pydantic) models", "input": "EDIT: add proper greetings ðŸ™„ \r\n\r\nHi guys,\r\n\r\nMany thanks for this fantastic repo. It rocks. Not to mention https://dockerswarm.rocks/, I am now in the process to review all my projects from this base ðŸ¥‡ \r\n\r\n**Here is my question :**\r\n\r\nHow can I declare a one-to-many relationship in the pydantic models?\r\n\r\n**Context**\r\n\r\nI have a first object 'Rule', that is attached to a second 'City'.\r\n\r\nI have tried the following without success :\r\n\r\nrules.py\r\n```\r\nfrom app.models.cities import City\r\n\r\nclass RuleBase(BaseModel):\r\n    mode: Optional[RuleMode] = None\r\n    value: Optional[float] = None\r\n    city: Optional[City] = None\r\n```\r\n\r\n\r\ncities.py\r\n```\r\nclass City(BaseModel):\r\n    id: int\r\n    name: str\r\n    rules: Optional[List['Rule']]\r\n```\r\n\r\nError in tests:\r\n\r\n```\r\nImportError while loading conftest '/app/app/tests/conftest.py'.\r\napp/app/tests/conftest.py:4: in <module>\r\n    from app.models.cities import City, Rectangle, Point\r\napp/app/models/cities.py:50: in <module>\r\n    class City(BaseModel):\r\nusr/local/lib/python3.6/site-packages/pydantic/main.py:179: in __new__\r\n    config=config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:118: in infer\r\n    schema=schema,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:152: in prepare\r\n    self._populate_sub_fields()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in _populate_sub_fields\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in <listcomp>\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:210: in _create_sub_type\r\n    model_config=self.model_config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/si", "output": "Resolution:\nSoooooo this is how I typically handle this scenario. This solution lets me keep my neat type hinting and all that jazz. This works in python3.9:\r\n\r\nuser.py\r\n```python\r\nfrom typing import TYPE_CHECKING, List\r\n\r\nfrom pydantic import BaseModel\r\n\r\nif TYPE_CHECKING:\r\n  from .item import Item\r\n\r\n\r\nclass User(BaseModel):\r\n  name: str\r\n  items: 'List[Item]'\r\n```\r\n\r\nitem.py\r\n```python\r\nfrom typing import List\r\n\r\nfrom pydantic import BaseModel\r\n\r\nfrom .user import User\r\n\r\n\r\nclass Item(BaseModel):\r\n  name: str\r\n  user: User\r\n\r\n# This is the important bit, we explicitly bind the forward ref 'Item'\r\nUser.update_forward_refs(Item=Item)\r\n```\r\n\r\nHowever, this leads to recursion that breaks pydantic. Pydantic has no method to resolve the cyclic parsing that this leads to (i.e. I want to pull an Item from my orm, Pydantic parses the parent User, which parses the child Items which all parse the parent User again and so on....) SQLAlchemy is perfectly equipped to handle it, just Pydantic not so much. So your only 2 ways to deal with it is break the relationship on one of the models *or* define a child model that doesn't end up in an infinite loop of parsing its children:\r\n\r\n```python\r\n# user.py stays the same\r\n\r\nclass Item(BaseModel):\r\n  name: str\r\n  user_id: int\r\n\r\nclass ItemDB(Item):\r\n  user: User\r\n```\r\n\r\nSo in that case User will contain a list of Items that doesn't attempt to recursively parse its parent User then itself etc... Done this way your max recursion depth ends up being 3. ItemDB still contains this relationship, which will return its parent User, and that parent User will have all its child Items and those will have their parent User. You could go full chooch and define 2 models of each, this'll reduce your recursion depth to 2, which is probably the deepest you'd ever want to go but is 1 more model to ensure you're returning in the right places.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 96}
{"instruction": "How was this issue resolved: Hooks to modify request and response body", "input": "How can I modify request body before it's accessed by the api handler and response body before it's returned by the handler?\r\n\r\nIs it possible to implement a middleware or view hooks to change the request body and response body as needed?\r\n\r\n**Additional context**\r\nI am working on implementing API versioning with FastAPI using [Stripe's approach](https://stripe.com/blog/api-versioning). As I understand, it requires modifying the request body and response body depending on requested version of the API. I've been experimenting with different approaches but unable to find a clean way to do it. I've tried implementing it as a middleware but it doesn't seem like the right place. So my question is, are there any hooks that I can rely on to modify the incoming request and modify the response. Thanks!", "output": "Resolution:\n@dashsatish please don't necrobump an old issue. Open a new one.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 95}
{"instruction": "How was this issue resolved: Awaiting request body in middleware blocks the application", "input": "**Describe the bug**\r\nDescription in the title\r\n\r\n**To Reproduce**\r\nMinimal code:\r\n```\r\nfrom typing import Mapping\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.requests import Request\r\n\r\napp = FastAPI()\r\n\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    print(await request.json())\r\n    return await call_next(request)\r\n\r\n@app.post(\"/\")\r\ndef read_root(arg: Mapping[str, str]):\r\n    return {\"Hello\": \"World\"}\r\n```\r\nRun the application with ```uvicorn <file>:app```\r\nTest the bug with ```curl localhost:8000 -d '{\"status\":\"ok\"}'```\r\n\r\n**Expected behavior**\r\nThe body of the request is printed, but the curl command stay pending for ever. If it is interrupted (Ctrl-C), the application then print ```ERROR: Error getting request body:```\r\n\r\n**Environment:**\r\n - OS: macOS\r\n - fastapi 0.33.0\r\n - python 3.7.3\r\n - (tested on Ubuntu too with Python 3.7.0 and 3.7.4)\r\n\r\n**Additional context**\r\n - When the route function has no body argument (```def read_root():```), there is no problem : the body is printed and the response send.\r\n - Thinking the issue was maybe coming from Starlette, I tested the following code, which works without issue. The bug seems thus to come from fastapi\r\n```\r\nfrom starlette.applications import Starlette\r\nfrom starlette.requests import Request\r\nfrom starlette.responses import JSONResponse\r\n\r\napp = Starlette()\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def func(request: Request, call_next):\r\n    print(await request.json())\r\n    return await call_next(request)\r\n\r\n\r\n@app.route('/', methods=[\"POST\"])\r\ndef homepage(request):\r\n    return JSONResponse({\"Hello\": \"World\"})\r\n```", "output": "Resolution:\nIf you're using StreamingResponse in your response.\r\n\r\n```python\r\n    receive_ = await request._receive()\r\n\r\n    async def receive() -> Message:\r\n        return receive_\r\n\r\n    request._receive = receive\r\n```\r\n\r\nDoes not work =(\r\n\r\nBut you can write\r\n\r\n```python\r\nasync def get_request_body(request: Request) -> bytes:\r\n    body = await request.body()\r\n\r\n    request._receive = ReceiveProxy(receive=request.receive, cached_body=body)\r\n    return body\r\n\r\n\r\n@dataclasses.dataclass\r\nclass ReceiveProxy:\r\n    \"\"\"Proxy to starlette.types.Receive.__call__ with caching first receive call.\"\"\"\r\n\r\n    receive: starlette.types.Receive\r\n    cached_body: bytes\r\n    _is_first_call: ClassVar[bool] = True\r\n\r\n    async def __call__(self):\r\n        # First call will be for getting request body => returns cached result\r\n        if self._is_first_call:\r\n            self._is_first_call = False\r\n            return {\"type\": \"http.request\", \"body\": self.cached_body, \"more_body\": False}\r\n\r\n        return await self.receive()\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 94}
{"instruction": "How was this issue resolved: Is this the correct way to save an uploaded file ?", "input": "Hello,\r\ni am trying to save an uploaded file to disk, the following code works correctly but i wonder if it is the correct way to do that.\r\n\r\n```\r\ndef parse(file: UploadFile = File(...)):\r\n\r\n    extension = os.path.splitext(file.filename)[1]\r\n    _, path = tempfile.mkstemp(prefix='parser_', suffix=extension)\r\n\r\n    with open(path, 'wb') as f:\r\n        f.write(file.file.read())\r\n\r\n```\r\nBasically i need to get the path of the temp file.\r\nI also have tried with .rollover() but file.file.name does not return the path (only the file descriptor)", "output": "Resolution:\n> \r\n> \r\n> @david-shiko , I don't know about him, however I spent the whole day trying to use an uploaded .csv file in memory but it threw all kind of errors, one being `JSONDecodeError: Expecting value: line 1 column 1 (char 0)`.\r\n> So I'm stuck, If someone knows a solution to that, it will be great. Ultimately, I want to upload and use in memory .feather files.\r\n\r\nAt least for .csv, now I could make it work using `pd.read_csv(io.StringIO(str(upload_file.file.read(), 'utf-8')), encoding='utf-8')`", "source": "issue_closed", "type": "qa_resolution", "issue_number": 93}
{"instruction": "How was this issue resolved: Body is always parsed as JSON regardless of media_type", "input": "### Describe the bug\r\n\r\nThis is to continue the discussion at https://github.com/tiangolo/fastapi/issues/579#issuecomment-589263249. `Body` accepts an argument `media_type`, but regardless of the media_type Body is parsed as JSON. This is a problem for other media_types such as `plain/text`, `application/sql`, etc. And this is not compliant to [OpenAPI content](https://swagger.io/docs/specification/describing-responses/). Body should be able to represent plain text as `str` too.\r\n\r\nBasically I wish I could do this:\r\n```python\r\nrequest: str = Body(..., media_type='text/plain')\r\n```\r\nHowever, this produces 400 parsing error because Body is parsed as JSON anyway.\r\n\r\n### To Reproduce\r\n\r\n1. Create a file with:\r\n\r\n```Python\r\nfrom fastapi import FastAPI, Body\r\n\r\napp = FastAPI()\r\n\r\n@app.post(\"/\")\r\ndef read_root(body: str = Body(..., media_type='text/plain')):\r\n    return {\"I received:\": body}\r\n```\r\n\r\n2. Run the server.\r\n\r\n3. Then execute: `curl -d 'I want to print this' -H 'Content-Type: plain/text' http://localhost:8000` \r\n\r\n4. It returns {\"detail\":\"There was an error parsing the body\"}\r\n\r\n5. But I expected it to return `{\"I received\": \"I want to print this\"}`.\r\n\r\n### Expected behavior\r\n\r\nMy expectation is that the Body should be parsed based on the Content-Type header always. \r\n\r\n### Screenshots\r\n\r\nI think the information is quite comprehensive without screenshots.\r\n\r\n### Environment\r\n\r\n- OS: Ubuntu 18.04\r\n- FastAPI Version: 0.49.0\r\n- Python 3.7.4\r\n\r\n\r\n### Additional context\r\nThe associated part is: https://github.com/tiangolo/fastapi/blob/9c3c9b6e78768374868d690bc05918d58481e880/fastapi/routing.py#L114\r\n\r\nThis does not check Content-Type. My proposal is to fix it as \r\n```python\r\nif body_bytes and request.headers['Content-Type'] == 'application/json':\r\n# if body_bytes and request.headers.get('Content-Type', 'application/json'): # if the content type should be assumed.\r\n    body = await request.json()\r\nelse:\r\n    body = body_bytes\r\n```\r\n\r\nI can make a PR for this, but I wo", "output": "Resolution:\nhttps://github.com/tiangolo/fastapi/commit/fa7e3c996edf2d5482fff8f9d890ac2390dede4d could be  extended to first use `body_field.field_info.media_type` when provided, or go with current logic when unspecified. This would allow to force using proper content-type e.g. for callbacks/hooks where 'content-type' received is not under control of an endpoint's implementer.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 92}
{"instruction": "How was this issue resolved: Error getting request body: The `python-multipart` library must be installed to use form parsing.", "input": "(venv) G:\\projects\\python\\fastprojects>pip list\r\n\r\npython-dateutil   2.8.1\r\npython-multipart  0.0.5\r\nrope              0.17.0\r\n\r\n```\r\n@app.post('/token', tags=['safe'])\r\nasync def login(form_data: OAuth2PasswordRequestForm = Depends()):\r\n  print('form_data', form_data)\r\n  user_dict = fake_users_db.get(form_data.username)\r\n  if not user_dict:\r\n    raise HTTPException(\r\n      status_code=400,\r\n      detail='Incorrect username or password'\r\n    )\r\n  user = UserInDB(**user_dict)\r\n  hashed_password = fake_hash_password(form_data.password)\r\n  if not hashed_password == user.hashed_password:\r\n    raise HTTPException(\r\n      status_code=400,\r\n      detail='Incorrect username or password'\r\n    )\r\n  return {'access_token': user.username, 'token_type': 'bearer'}\r\n\r\n```\r\n\r\nI don't know how to troubleshoot this problem", "output": "Resolution:\nThe issue is that an import exception is being swallowed up, and then an assumption is being printed to the user.\r\n\r\nAt the very least, the exception should be printed.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 91}
{"instruction": "How was this issue resolved: How to Prevent the 307 Temporary Redirect When There's a Missing Trailing Slash", "input": "### Description\r\n\r\nJust like the author of #731, I don't want a 307 temporary redirect which is automatically sent by uvicorn when there's a missing trailing slash in the api call. However, the solution given in that issue, i.e. route path like \"/?\" no longer works in the versions after this April as reported in in #1787, #1648 and else. Certain developers states this is an unexpected behavior and won't be supported in the future. In this case, I'm wondering what is the current elegant way to realize this. Or there's any way to handle both \"\" and \"/\" two paths simultaneously?", "output": "Resolution:\nI think when using subrouters with prefixes, you *do* want to affect a single \"/\" path.\r\n\r\nfixed by changing `len(path)` to `len(self.prefix+path)`\r\n```py\r\nif path.endswith(\"/\") and len(self.prefix+path) > 1:\r\n    path = path[:-1]\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 90}
{"instruction": "How was this issue resolved: Choosing the Right ASGI Server for Deploying FastAPI", "input": "According to [ASGI Documentation](https://asgi.readthedocs.io/en/latest/implementations.html#servers) there are 3 ASGI Servers: [Daphne](https://github.com/django/daphne), [Hypercorn](https://pgjones.gitlab.io/hypercorn/index.html) and [Uvicorn](https://www.uvicorn.org/).\r\n\r\nFrom FastAPI's documentation to [Deploy FastAPI without Docker](https://fastapi.tiangolo.com/deployment/#alternatively-deploy-fastapi-without-docker) we could use Uvicorn or Hypercorn.\r\n\r\nBut which ASGI Server works best with FastAPI in terms of performance and scalability? A comparison chart or pros and cons between the available ASGI Servers would be helpful!\r\n\r\nAlso for Serverless Deployment what else should I consider?", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 89}
{"instruction": "How was this issue resolved: What is the efficient way to get images using FAST API?", "input": "How to get an image using Fast API ?", "output": "Resolution:\nThanks for the help here @Mause and @ycd ! ðŸ° \r\n\r\nThanks for closing the issue @Gokulnath31 \r\n\r\n> Sorry for the long delay! ðŸ™ˆ  I wanted to personally address each issue/PR and they piled up through time, but now I'm checking each one in order.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 88}
{"instruction": "How was this issue resolved: Usage Graphene Subscriptions in FastAPI - Usage of Starlette-Graphene3 failed", "input": "I wanted to make the subscriptions of graphene work in FastAPI. Unfortuantely I saw two other repositories who asked a similar thing and no conclusion made there. After some research I found the package starlette-graphene3, which makes uploading files and the subscription possible in Starlette. Due to the usage of the the GraphQLApp-class of starlette i thought, that this is going to work. Unfortunately there is a little problem when using starlette-graphene3 with fastapi:\r\n\r\n- When installing starlette-graphene3 I get the error: `ERROR: fastapi 0.63.0 has requirement starlette==0.13.6, but you'll have starlette 0.14.1 which is incompatible.`, which makes FastAPI not work anymore.\r\n\r\nMy questions are: \r\n- is it in planning to use a newer Starlette version, that starlette-graphene3 could be used\r\n- Any other way to make subscriptions work in FastAPI?\r\n\r\nWhen trying to use GraphQL  like in the documentation of FastAPI with subscriptions i get the error:\r\n`\"Subscriptions are not allowed. You will need to either use the subscribe function or pass allow_subscriptions=True\"`\r\n\r\nCode to reproduce:\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom starlette.graphql import GraphQLApp\r\nimport graphene\r\nimport asyncio\r\n\r\nclass Subscription(graphene.ObjectType):\r\n    count = graphene.Int(upto=graphene.Int())\r\n\r\n    async def subscribe_count(root, info, upto=3):\r\n        for i in range(upto):\r\n            yield i\r\n            await asyncio.sleep(1)\r\n\r\n\r\napp = FastAPI()\r\napp.add_route(\"/graphql\", GraphQLApp(schema=graphene.Schema(subscription=Subscription)))\r\n```", "output": "Resolution:\nsolved this is a template for queries, mutatoins and subscriptions with testing everything in one https://github.com/aliscie/fastapi-full-graphql-template", "source": "issue_closed", "type": "qa_resolution", "issue_number": 87}
{"instruction": "How was this issue resolved: The docs page layout is abnormal", "input": "Local service running with fastapi\r\n\r\nvisit docs page, the docs page layout is abnormal.", "output": "Resolution:\n@tiangolo issue seems to be solved now.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 86}
{"instruction": "How was this issue resolved: `TestClient.delete()` no longer supports payloads", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n\r\n#### App\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n@app.delete(\"/{user_id}\")\r\nasync def _delete_user(user_id: int):\r\n    return {}\r\n```\r\n\r\n\r\n#### Test\r\n\r\n```python\r\ndef test_delete_user(client: TestClient):\r\n    user_id = 123\r\n    response = client.delete(f\"/{user_id}\", json={\"validation_code\": 789})\r\n    assert response.status_code == 200\r\n```\r\n\r\n#### Error\r\n\r\n```\r\nTypeError: TestClient.delete() got an unexpected keyword argument 'json'\r\n```\r\n\r\n### Description\r\n\r\nAfter updating my application to FastAPI 0.87.0 I found out that the new `TestClient` does not support anymore any kind of payload in the `DELETE` method. Although the use of a body within DELETE requests is highly discouraged, it is not forbidden. Hence, we should find a way to allow a full retro-compatibility. \r\n\r\nAn idea would be to wrap the `httpx.delete` method used within the `TestClient` class in order to re-enable this feature. For this to happen, the solution described [here](https://www.python-httpx.org/compatibility/#request-body-on-http-methods) can be reused.\r\n  \r\n\r\n### Operating System\r\n\r\nmacOS\r\n\r\n### Operating System Details\r\n\r\n_No res", "output": "Resolution:\n\"So, yep, you can still send payloads with HTTP operations that don't really support it, but you have to be explicit that you are doing something that is kind of wrong. That's also why it's not part of HTTPX by default, to stop encouraging developers to use HTTP in a way that is kinda wrong and possibly broken in some environments that are more strict about the standard.\"\r\n^\r\nThis is why we can't have nice things, bs standards and best practices that really just end up complicating things needlessly.\r\nWhy should I not be able to send a list of ids that I want removed? Why do I HAVE to delete each individual object by itself and spam the internet with hundreds of delete requests. Makes no sense.\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 85}
{"instruction": "How was this issue resolved: How can I serve static files (html, js) easily?", "input": "**Description**\r\n\r\n How can I serve static files (html, js) easily? Even though I don't need to inject python data, I attempted to do it with jinja and encountered issues.\r\n\r\n**Additional context**\r\n I tried something like: \r\n\r\n```\r\n@router.get(\"/webui/{file_name}\", name=\"webui.show\")\r\nasync def webui_show(file_name: str):\r\n    template = jinja2.get_template(file_name)\r\n    content = template.render()\r\n    return HTMLResponse(content=content, status_code=200)\r\n```\r\n\r\nWhere jinja2 was \r\n```\r\nloader = FileSystemLoader(web_dir(\"dist\"))\r\n# no escaping while deubing\r\njinja2 = Environment(loader=loader, autoescape=False)\r\n```\r\n\r\nBut I received an error message \"jinja2.exceptions.TemplateSyntaxError: Expected an expression, got 'end of print statement'\" when returning JavaScript files. What's sanctioned way to implement simple static file serving in fastapi? If so, it'd be nice to have some documentation around it.", "output": "Resolution:\nI am trying to mount an Angular UI I have created a build for it:\r\n\r\n```\r\nPATH = pathlib.Path().resolve().parent / \"App\\\\dist\\\\app\\\\\"\r\n\r\napp.mount(\r\n    \"/\",\r\n    StaticFiles(directory=PATH, html=True),\r\n    name=\"static\"\r\n)\r\n\r\n@app.get(\"/.*\", include_in_schema=False)\r\nasync def get_app_angular():\r\n    return RedirectResponse(url=PATH / 'index.html') \r\n```\r\n\r\nAll files needed in the folder arrive with 200 status code, but I only get a white page and when I check the Page Source I am able to click on the css file link and it opens it, so the linking is fine I guess.\r\n\r\nHave been trying to figure this out for 3 days now from the docs, but I can't figure out for the life of my what I am doing wrong.\r\n\r\n(The build is definitely good, I am able to call it from Flask.)", "source": "issue_closed", "type": "qa_resolution", "issue_number": 84}
{"instruction": "How was this issue resolved: Debug Logging (Maybe just a n00b issue)", "input": "Disclaimer: n00b to Python altogether. This is the first Python app that I've ever built.\r\n\r\nTrying to add formatted debug logging to the screen. I've gotten it to the point where the debug output shows twice. Once with the formatting applied, and once raw. \r\n\r\nScaled down code would be:\r\n```\r\nimport logging\r\n\r\nfrom fastapi import FastAPI\r\n\r\napi = FastAPI()\r\n\r\nlogger = logging.getLogger(\"api\")\r\nlogger.setLevel(logging.DEBUG)\r\n\r\nfh = logging.FileHandler(\"QED.log\")\r\nfh.setLevel(logging.ERROR)\r\nch = logging.StreamHandler()\r\nch.setLevel(logging.DEBUG)\r\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\nfh.setFormatter(formatter)\r\nch.setFormatter(formatter)\r\n\r\nlogger.addHandler(fh)\r\nlogger.addHandler(ch)\r\n\r\n@api.get(\"/\")\r\ndef read_root():\r\n    logger.debug(\"THIS IS A DEBUG LOG\")\r\n    logger.error(\"SOMETHING WENT VERY VERY WRONG\")\r\n    return {\"Hello\": \"World\"}\r\n```\r\nOutput to the console is:\r\n\r\n```\r\n2019-06-04 12:44:51,169 - api - DEBUG - THIS IS A DEBUG LOG\r\nDEBUG: THIS IS A DEBUG LOG\r\n2019-06-04 12:44:51,169 - api - ERROR - SOMETHING WENT VERY VERY WRONG\r\nERROR: SOMETHING WENT VERY VERY WRONG\r\nINFO: ('127.0.0.1', 55229) - \"GET / HTTP/1.1\" 200\r\n\r\n```\r\n\r\nSo, two things are happening.\r\n\r\n1. Seeing both the formatted message and the raw message.\r\n2. Seeing the ERROR level message in the console. That should only be written to QED.log\r\n\r\nThanks!", "output": "Resolution:\n> @euri10 Can you help me with a configuration? Why the logging is coming out in the console with this JSON formatting?\r\n\r\nno clue, I would say you're using another library than the logging from standard library ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 83}
{"instruction": "How was this issue resolved: Starlette 0.13 declarative support?", "input": "**Description**\r\n\r\nIn the [upcoming release 0.13 of Starlette](https://github.com/encode/starlette/pull/704), a new declarative way for routing is introduced. At first, decorator style will still be supported but @tomchristie will somewhat *deprecate* it and remove it at some point in the future:\r\n\r\n> Yes, that's not going away here. However I _do think_ that I'm going to stop documenting it everywhere.\r\n> \r\n> Would I like to _eventually_ phase it out? _Possibly at some point in the future, maybe_. One of the key things I'm trying to emphasize in Starlette is a low-complexity stack, and components such as the `Starlette` and `Router` classes get _really_ simple if we move away from all the `.add_route(...)` and `@route()` futzing.\r\n\r\nAt the light of this, it seems that FastAPI needs to take a decision about this: either follow Starlette new convention or stick with the decorator style.\r\n\r\nPersonally, I tend to prefer the decorator style, which is similar to Flask or even Node's Express. However, as Starlette is one of the core component of FastAPI, I think it's better if it keeps up with its evolutions, for several reasons:\r\n\r\n* Keep the friction between the two frameworks as low as possible. Currently, if you know how to write a Starlette app, you know how to write a FastAPI one.\r\n* At some point, FastAPI will have to implement and maintain some wrapper code to convert imperative routing into the declarative style Starlette expects.\r\n\r\nThat's it! Just some quick thoughts in order to keep this subject in mind ðŸ™‚", "output": "Resolution:\nAre there any plans to upgrade the starlette version in the near future? Starlette is currently locked at `0.12.9`, though it can be safely upgraded to `0.12.12` without issues. `0.12.13` is still broken because of #683 and I don't know in detail if there are any other pending issues preventing FastAPI from forking on top of Starlette 0.13.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 82}
{"instruction": "How was this issue resolved: How does one setup a global timeout to all requests?", "input": "### First check\r\n<details>\r\n\r\n<summary>\r\n<i>Ticked all checks, then first commitment choice</i>\r\n</summary>\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n\r\n</details>\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Description\r\n\r\nHi there, first of all many thanks for the work on FastAPI - this is now my goto framework for building Python-based REST APIs :)\r\n", "output": "Resolution:\nI am afraid this solution will not play well in a concurrent environment since there is only one timer per process, whereas there will be many co-routines running concurrently within the same process.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 81}
{"instruction": "How was this issue resolved: Python - FastAPI - Optional option for an UploadFile", "input": "### First Check\r\n\r\n- [x] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom typing import Optional\r\nfrom fastapi import FastAPI, UploadFile, File\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef root():\r\n    pass\r\n\r\n@app.post(\"/OptionOne\")\r\ndef pdf_foo1(file: Optional[UploadFile] = None):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionTwo\")\r\ndef pdf_foo2(file: Optional[UploadFile] = File(None)):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionThree\")\r\ndef pdf_foo3(file: UploadFile = File(None)):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionFour\")\r\ndef pdf_foo4(file: UploadFile = None):\r\n    print(file.filename)\r\n\r\n@app.post(\"/OptionFive\")\r\ndef pdf_foo5(file: bytes = File(None)):\r\n    print(file)\r\n```\r\n\r\n\r\n### Description\r\n\r\n### Short Summary\r\nI am trying to do what I think is a simple thing but no internet solution has helped me so far, and I didn't find anything helpful yet in the issues.\r\n___\r\n### The desired solution:\r\nA route (function) that will accept an UploadFile but that will be optional, the user will not be have to provide it.\r\n\r\n### Current Case:\r\nIn the code there are 5 different cases I tried, all of them are not working as follows:\r\nCases 1, 3 Gives an 'ValueError: Value not declarabl", "output": "Resolution:\nThe last thing I can tell is:\r\n\r\n- check for middlewares\r\n\r\n**If your project is big**\r\nTry removing some other code from your app just for testing if you find it might cause the issue\r\n\r\n**if your project is small**\r\nTry to implement your project (if it's small) in this new example (just for finding the issue)", "source": "issue_closed", "type": "qa_resolution", "issue_number": 80}
{"instruction": "How was this issue resolved: Inheritance and Polymorphism support", "input": "Actually, there is no support for Inheritance and Polymorphism as I know in fastapi : https://swagger.io/docs/specification/data-models/inheritance-and-polymorphism/\r\n\r\nMaybe annotations like that will do the job : \r\n\r\n```python\r\nclass Item(BaseModel):\r\n    type: str\r\n\r\nclass CarItem(Item):\r\n    type: str\r\n\r\nclass PlaneItem(Item):\r\n    type: str\r\n    size: str\r\n\r\n\r\n@app.post(\"/items/\", response_model=Item, one_of=[CarItem, PlaneItem], discriminator=\"type\")\r\nasync def create_item(*, item: Item):\r\n    return item\r\n```\r\n\r\nFor now, we need to define an `any` response_model since defining an `Item` response_model will remove the extra attributes during serialization.\r\n\r\nI'll try to hack using the based starlette api : https://www.starlette.io/schemas/ but comment are unused by fastapi (except for description)", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 79}
{"instruction": "How was this issue resolved: Websocket Broadcast", "input": "It would be awesome to have a feature to enable broadcast messages to all connected clients at specific websocket endpoint. \n\nThis function could be executed inside a api endpoint, for example after a post method that changes some persistent data, all connected clients at /ws will receive a message telling that it is time to refresh. \n\nCheers guys, this is a incredible project. Like so much!", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 78}
{"instruction": "How was this issue resolved: UploadFile as a CSV file", "input": "**Description**\r\nI'm trying to upload csv file to fastapi server. Is there any clear way to read fastapi File object and write it as a csv file?\r\n\r\nWhen I receive byte stream through the api, it's difficult to save it as a csv file since there could be comma anywhere in the string. \r\n\r\nOne solution could be write incoming bytes files to disk and load it back but I'm wondering if there is a direct approach without writing it into a disk", "output": "Resolution:\n> This works for me.\r\n> \r\n> ```\r\n> @router.post(\"/upload_csv\")\r\n> async def upload_csv(separator=',', encoding='utf-8',\r\n>                      csv_file: UploadFile = File()):\r\n>     contents = csv_file.file.read()\r\n>     buffer = BytesIO(contents)\r\n>     data = pd.read_csv(buffer, delimiter=separator, encoding=encoding, nrows=10000)\r\n>     buffer.close()\r\n>     csv_file.file.close()\r\n> ```\r\n> \r\n> @batmanscode\r\n\r\nThank you. I didn't realize the files had to be closed.\r\n\r\nI ended up using [`csv_file.filename`](https://github.com/batmanscode/pydacc/blob/455c38ed026bec9d6c0ac9811629f49efbff9e63/api.py#L236) and just passing that into [`pd.read_csv`](https://github.com/batmanscode/pydacc/blob/455c38ed026bec9d6c0ac9811629f49efbff9e63/pydacc/data_cleaning.py#L45)", "source": "issue_closed", "type": "qa_resolution", "issue_number": 77}
{"instruction": "How was this issue resolved: Elegant way to exclude middleware in unit tests?", "input": "**Description**\r\n\r\nIs it possible to disable or override middleware in unit tests?\r\n\r\n**Additional context**\r\n\r\nI have written some middleware to obtain a database pool connection and release it when the request is done.  I'm using asyncpg directly for this as follows:\r\n\r\n```python\r\n@app.middleware(\"http\")\r\nasync def database_middleware(request: Request, call_next):\r\n    conn = None\r\n    try:\r\n        conn = await database_pool.acquire()\r\n\r\n        try:\r\n            await conn.fetch(\"SELECT 1\")\r\n        except ConnectionDoesNotExistError:\r\n            conn = await database_pool.acquire()\r\n\r\n        request.state.db = conn\r\n        return await call_next(request)\r\n    except (PostgresConnectionError, OSError) as e:\r\n        logger.error(\"Unable to connect to the database: %s\", e)\r\n        return Response(\r\n            \"Unable to connect to the database.\", status_code=HTTP_500_INTERNAL_SERVER_ERROR\r\n        )\r\n    except SyntaxOrAccessError as e:\r\n        logger.error(\"Unable to execute query: %s\", e)\r\n        return Response(\r\n            \"Unable to execute the required query to obtain data from the database.\",\r\n            status_code=HTTP_500_INTERNAL_SERVER_ERROR,\r\n        )\r\n    finally:\r\n        if conn:\r\n            await database_pool.release(conn)\r\n```\r\n\r\nI then have a little `get_db` dependency injection which is similar to the docs:\r\n\r\n```python\r\ndef get_db(request: Request):\r\n    return request.state.db\r\n```\r\n\r\nI'd like to mock my database in my unit tests so I can verify that I'm building the correct SQL given the appropriate params.\r\n\r\nI've setup a pytest fixture to mock the database as follows:\r\n\r\n```python\r\n@pytest.fixture(scope=\"function\")\r\ndef db_mock(request):\r\n    def fin():\r\n        del app.dependency_overrides[get_db]\r\n\r\n    db_mock = mock.MagicMock()\r\n    app.dependency_overrides[get_db] = lambda: db_mock\r\n\r\n    request.addfinalizer(fin)\r\n    return db_mock\r\n```\r\n\r\nThis works perfectly when the middleware is disabled.  However, when it's enabled", "output": "Resolution:\nWith Python3.8 this is easily remedied like so:\r\n\r\n```python\r\nfrom unittest.mock import patch, AsyncMock\r\n\r\n\r\n@pytest.fixture(autouse=True)\r\ndef mocked_asyncpg():\r\n    with patch(\"circular_api.utils.database.create_pool\", new_callable=AsyncMock) as mocked_pool:\r\n        mocked = mocked_pool.return_value.acquire.return_value\r\n\r\n        yield mocked\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 76}
{"instruction": "How was this issue resolved: How to use different middleware for different routes/path", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nIs it possible to use different middleware for different routes/path?\r\n\r\n### Additional context\r\n\r\nIn my case my need comes from CORS. But, I am sure there is other cases than CORS requirements that someone would need different middlewares for different paths.\r\n\r\n* I want `myapi.com/path1` to allow origins of calls from `myfrontend.com`\r\n* I want `myapi.com/path2` to allow origins of calls from anywhere ('*') since it is a public facing api.\r\n\r\nI checked if it was possible to add a middleware at a router level and did not find any documentation about it.\r\n\r\n### Code example\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\n\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['myfrontend.com'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# I want /path1 to allow only calls from 'myfrontend.com'\r\n@app.get(\"/path1\")\r\nasync def path1():\r\n    return {\"status\": \"alive\"}\r\n\r\n# I want /path2 to be a public facing api that can be accessed from anywhere ['*']\r\n@app.get(\"/path2\")\r\nasync def path2():\r\n    return {\"status\": \"alive\"}\r\n\r\n```", "output": "Resolution:\nI think that yes a PR to FastAPI would be accepted ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 75}
{"instruction": "How was this issue resolved: How to hide certain fields in Pydantic models?", "input": "Example:\r\n\r\nI have created_at and updated_at fields that I want to auto populate on the model using default_factory, but I don't want the user to be able to set them via an endpoint. I thought this could be achieved by the read only Field arg but then I can never set it.\r\n\r\nWhat's the best way to go about this?", "output": "Resolution:\nI'm late to the party, but if you want to hide Pydantic fields from the OpenAPI schema definition without either adding underscores (annoying when paired with SQLAlchemy) or overriding the `schema.field_schema` function that will display warnings in your logs, you can [customize the schema according to Pydantic's documentation](https://docs.pydantic.dev/usage/schema/#schema-customization).\r\n\r\nYou can therefore add a schema_extra static method in your class configuration to look for a `hidden` boolean field option, and remove it while still retaining all the features you need.\r\n\r\nHere is how I did it:\r\n```py\r\nfrom pydantic import BaseModel, Field\r\n\r\nclass User(BaseModel):\r\n    public_field: str\r\n    hidden_field: str = Field(hidden=True)\r\n\r\n    class Config:\r\n        @staticmethod\r\n        def schema_extra(schema: dict, _):\r\n            props = {}\r\n            for k, v in schema.get('properties', {}).items():\r\n                if not v.get(\"hidden\", False):\r\n                    props[k] = v\r\n            schema[\"properties\"] = props\r\n```\r\n\r\nThis can also be done by creating a \"proxy\" BaseModel class per example.\r\nAll your existing classes will therefore obtain this feature without editing them:\r\n```py\r\nfrom pydantic import BaseModel as _BaseModel\r\n\r\nclass BaseModel(_BaseModel):\r\n    class Config:\r\n        @staticmethod\r\n        def schema_extra(schema: dict, _):\r\n            props = {}\r\n            for k, v in schema.get('properties', {}).items():\r\n                if not v.get(\"hidden\", False):\r\n                    props[k] = v\r\n            schema[\"properties\"] = props\r\n```\r\n\r\nYou can certainly optimize this function, but that's the cleanest way I've been able to find.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 74}
{"instruction": "How was this issue resolved: FastAPI gets terminated when child multiprocessing process terminated", "input": "### Describe the bug\r\n\r\nMake a multiprocessing Process and start it.\r\nRight after terminate the process, fastapi itself(parent) terminated.\r\n\r\n### To Reproduce\r\n\r\nStart command: /usr/local/bin/uvicorn worker.stts_api:app --host 127.0.0.1 --port 8445\r\n\r\n1. Create a file with:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.post('/task/run')\r\ndef task_run(task_config: TaskOptionBody):\r\n    proc = multiprocessing.Process(\r\n        target=task.run,\r\n        args=(xxxx,))\r\n    proc.start()\r\n    return task_id\r\n\r\n@app.get('/task/abort')\r\ndef task_abort(task_id: str):\r\n    proc.terminate()\r\n    return result_OK\r\n```\r\n\r\n3. Run task_run and while the process alive, trigger task_abort\r\n4. After child process terminated then parent(fastApi) terminated as well.\r\n\r\n### Expected behavior\r\n\r\nParent process should not be terminated after child terminated.\r\n\r\n### Environment\r\n\r\n- OS: Linux\r\n- FastAPI Version 0.54.1\r\n- Python version 3.8.2\r\n\r\n\r\n### Additional context\r\n\r\nI tried same code with Flask with gunicorn, it never terminated.", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 73}
{"instruction": "How was this issue resolved: How to achieve nested parameterized dependencies?", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n\r\n### Example\r\n\r\nGiven the follow minimal working example, where `Test1` and `Test2` are parameterized dependencies (as described in https://fastapi.tiangolo.com/advanced/advanced-dependencies/). One parameter of `Test2` should be forwarded to `Test1` which should be injected into `Test2`.:\r\n\r\n```Python\r\nimport uvicorn\r\nfrom fastapi import Depends, FastAPI\r\napp = FastAPI()\r\n\r\nclass Test1():\r\n\r\n    def __init__(self, t1) -> None:\r\n        self.t1 = t1\r\n\r\n    def __call__(self):\r\n        return self.t1\r\n\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n\r\n    def __call__(self):\r\n        return Depends(Test1(t1=self.t2))\r\n\r\n@app.get(\"/test/\")\r\ndef test_call(test: str = Depends(Test2(t2='test'))):\r\n    return test\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True, debug=True)\r\n```\r\n\r\n### Description\r\n\r\nIt is not possible to include `Test1` as dependency in the `call` parameters of `Test2` since there wouldn't be any access to the parameter of `Test1`.\r\nDirectly calling `Depends` as in the example above also does not work since there does not seem to be any dependency injection at this level.\r\n\r\nHow to achieve this kind of nesting? Is this simply not po", "output": "Resolution:\nI'm not 100% sure it's the same use case / issue, but it's fairly similar and may be helpful to someone so I'll leave it here\r\n\r\nI wanted to be able to override args passed to `Depends` without having to manually track down and handle every arg or send something async so I spun up a fork here:  \r\nhttps://github.com/tiangolo/fastapi/compare/master...liquet-ai:master\r\n\r\nUsage is like this (showing that it works with `Security` as well as `Depends`):\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastapi.dependencies.models import Overrides\r\nfrom fastapi.param_functions import Depends, Security\r\n\r\napp = FastAPI()\r\n\r\n\r\ndef Inner(overrides: Overrides, orderId: str):\r\n    print(overrides)\r\n    return orderId\r\n\r\n\r\ndef OuterOverride(inner=Depends(Inner, overrides=Overrides(orderId=2))):\r\n    return inner\r\n\r\n\r\ndef OuterNoOverride(inner=Security(Inner)):\r\n    return inner\r\n\r\n\r\n@app.get(\"/\")\r\ndef overriden_dependency_args(\r\n    order_id=Depends(OuterNoOverride),\r\n    overridden_order_id=Security(OuterOverride),\r\n):\r\n    return overridden_order_id, order_id\r\n```\r\n\r\nand output will be like this:\r\n```\r\n[2,\"1\"]\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 72}
{"instruction": "How was this issue resolved: Question. SQL Alchemy and blocking calls", "input": "in the documentation it is suggested to use sql alchemy as a orm, but isn't alchemy completely synchronous? wouldn't that way create blocking calls?", "output": "Resolution:\n@marziehoghbaie I think your issue is related to SQLite only, being a no production, low load database.  Mongo wouldn't suffer from such an issue, neither would MySQL or PostgreSQL.  Assuming of course you are using an async library like encode/database (or something async for MongoDB like motor or asyncmongo), not FastAPI with non-async SQLAlchemy at it will always use a thread pool and lock up quickly.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 71}
{"instruction": "How was this issue resolved: Using UploadFile and Pydantic model in one request", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Properties(BaseModel):\r\n    language: str = None\r\n    author: str = None\r\n\r\n\r\n@app.post(\"/uploadfile/\", status_code=201)\r\nasync def create_upload_file(properties: Properties, file: UploadFile = File(...)):\r\n    return {\"filename\": file.filename, 'properties': properties}\r\n```\r\n\r\n### Description\r\n\r\n* Open the browser `/docs` and call the endpoint `/uploadfile`.\r\n* It returns error 422 Validation Error.\r\n* But I expected it to return code 201.\r\n\r\n### Environment\r\n\r\n* OS: Linux (Fedora)\r\n* FastAPI Version: 0.61.1\r\n* Python version: 3.8.6\r\n\r\n### Additional context\r\nImmediately I apologize, m", "output": "Resolution:\nHello there! If you have new questions, it's better to ask them in new issues, following all the template, creating a code example that shows what you want to achieve, etc.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 70}
{"instruction": "How was this issue resolved: FastAPI always returns content, even if 204 no content status code is set.", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n### Example\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom starlette.status import HTTP_204_NO_CONTENT\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", status_code=HTTP_204_NO_CONTENT)\r\ndef read_root():\r\n    print(\"d\")\r\n```\r\n\r\n\r\n\r\n### Description\r\n\r\nSend a request with any HTTP Client, observe the traffic using tcpdump/wireshark - you'll see that you get null as a response (content-length will be 4). This is extremely notable as this caused this issue https://github.com/encode/httpx/issues/1474 (The client doesn't expect any data in that case)\r\nI would expect FastAPI to not return null when response is None.\r\n\r\n### Environment\r\n\r\n* OS: macOS\r\n* FastAPI Version [e.g. 0.3.0]: 0.63.0\r\n* Python version: 0.63.0", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 69}
{"instruction": "How was this issue resolved: Using dependency injection to get SQLAlchemy session can lead to deadlock", "input": "### First check\r\n\r\n- [x] I added a very descriptive title to this issue.\r\n- [x] I used the GitHub search to find a similar issue and didn't find it.\r\n- [x] I searched the FastAPI documentation, with the integrated search.\r\n- [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n- [x] After submitting this, I commit to one of:\r\n  - Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n  - I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n  - Implement a Pull Request for a confirmed bug.\r\n\r\nI've noticed that when using dependency injection with SQLAlchemy, a large number of concurrent requests can leave the app in a deadlocked state. This is especially noticeable with a small SQLAlchemy connection pool size (relative to the FastAPI thread pool size). Below is a self-contained example (you might have to tweak the pool size and the request body's sleep length but this should be a good starting point).\r\n\r\n<details>\r\n  <summary>View <code>app.py</code></summary>\r\n\r\n```python\r\n\"\"\"\r\nSetup: pip install fastapi sqlalchemy uvicorn\r\nRun: python app.py\r\n\"\"\"\r\nimport time\r\nimport uvicorn\r\n\r\nfrom fastapi import Depends, FastAPI, Request\r\nfrom sqlalchemy import create_engine\r\nfrom sqlalchemy.orm import Session, sessionmaker\r\nfrom sqlalchemy.pool import QueuePool\r\n\r\n\r\n# SQLAlchemy setup\r\nengine = create_engine(\r\n    'sqlite:///test.db',\r\n    connect_args={'check_s", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 68}
{"instruction": "How was this issue resolved: Pydantic v2, dataclasses, UUID, and `__annotations__`", "input": "### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe combination of using:\r\n\r\n* Pydantic v2\r\n* dataclasses (instead of Pydantic models)\r\n* UUIDs\r\n* `from future import __annotations__`\r\n\r\nseems to break in a strange way.\r\n\r\nThis was original reported in this discussion by @sanzoghenzo: https://github.com/tiangolo/fastapi/discussions/9709#discussioncomment-6449458\r\n\r\nIn particular the comment by @raddevon with the minimal example by @fantix:\r\n\r\n```Python\r\nfrom __future__ import annotations\r\n\r\nimport uuid\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Union\r\n\r\nfrom fastapi import FastAPI\r\n\r\n\r\n@dataclass\r\nclass Item:\r\n    id: uuid.UUID\r\n    name: str\r\n    price: float\r\n    tags: List[str] = field(default_factory=list)\r\n    description: Union[str, None] = None\r\n    tax: Union[float, None] = None\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/items/next\", response_model=Item)\r\nasync def read_next_item():\r\n    return {\r\n        \"name\": \"Island In The Moon\",\r\n        \"price\": 12.99,\r\n        \"description\": \"A place to be be playin' and havin' fun\",\r\n        \"tags\": [\"breater\"],\r\n    }\r\n```\r\n\r\nStarting FastAPI with that breaks with an error of:\r\n\r\n<details>\r\n<summary>log</summary>\r\n\r\n```\r\nuvicorn main:app\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 165, in __init__\r\n    core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/type_adapter.py\", line 97, in _getattr_no_parents\r\n    raise AttributeError(attribute)\r\nAttributeError: __pydantic_core_schema__\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"/Users/user/code/fastapi/env3.10/lib/python3.10/site-packages/pydantic/_internal/_generate_schema.py\", line 625, in _resolve_forward_ref\r\n    obj = _typin", "output": "Resolution:\nThanks @YuriiMotov! Indeed, this seems to be working, at least in recent versions of FastAPI, currently at 0.124.0.\n\nI added this as a test here: https://github.com/fastapi/fastapi/pull/14477\n\nI'll now close this issue. â˜• ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 67}
{"instruction": "How was this issue resolved: Multiple regressions in the handling of forms & form validation", "input": "### Issue Content\n\nWe have found at least 2 regression in the way forms are handled while trying to migrate to v0.115.11 from version v0.112.4. After investigation we were able to identify 2 commits that introduce 2 separate bugs that break the handling of default values in both `x-form-urlencoded` and `mutlipart` froms. Partial fixes have been proposed that also address a CVE, but the PR has been hanging since october 24.\n\n# Breaking in the handling of default value in `x-url-encoded` forms\n\nThis bug has been introduced in https://github.com/fastapi/fastapi/pull/12134.\n\nMRE:\n```python\napp = FastAPI()\n\n\n@app.post(\"/\")\ndef root(\n    name: Annotated[Optional[str], Form(embed=True)] = None,\n):\n    print(name)\n    return name\n```\n\nwith the following request:\n```\nâ¯ http post -v --form localhost:8888 name=\"\"\nPOST / HTTP/1.1\nAccept: */*\nAccept-Encoding: gzip, deflate, br, zstd\nConnection: keep-alive\nContent-Length: 5\nContent-Type: application/x-www-form-urlencoded\nHost: localhost:8888\nUser-Agent: xh/0.24.0\n\nname=\n\nHTTP/1.1 200 OK\nContent-Length: 2\nContent-Type: application/json\nDate: Sun, 23 Mar 2025 21:01:49 GMT\nServer: uvicorn\n\n\"\"\n```\nThe expected result is that `None` is printed, but instead `\"\"` is printed.\n\nthis is the offending bit from the linked PR:\n```\ndiff --git a/fastapi/dependencies/utils.py b/fastapi/dependencies/utils.py\nindex 6083b731..db7eedba 100644\n--- a/fastapi/dependencies/utils.py\n+++ b/fastapi/dependencies/utils.py\n@@ -789,9 +789,9 @@ async def _extract_form_body(\n             value = serialize_sequence_value(field=field, value=results)\n         if value is not None:\n             values[field.name] = value\n-    for key, value in received_body.items():\n-        if key not in values:\n-            values[key] = value\n+    # for key, value in received_body.items():\n+    #     if key not in values:\n+    #         values[key] = value\n     return values\n```\nThis patch solves the x-form-urlencoded  case. So we indeed have two different regressions.\nThis _get_", "output": "Resolution:\nThis should have been solved by https://github.com/fastapi/fastapi/pull/13537 (thanks @MarinPostma!).\n\nThe fix will be available in FastAPI 0.123.2, released in the next few hours. ðŸŽ‰ ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 66}
{"instruction": "How was this issue resolved: Allow json/BaseModels in query parameters", "input": "### Is your feature request related to a problem\r\n\r\nI have to support getting a structured json string as parameter:\r\n<img width=\"891\" alt=\"Screenshot 2020-01-17 at 22 08 55\" src=\"https://user-images.githubusercontent.com/2737108/72646249-f86be980-3975-11ea-9e3c-3ea7816fd1e1.png\">\r\n\r\n```url\r\nhttps://localhost:8080/test?moop={\"name\": \"something %26 something else\",\"description\": \"str\" ,\"price\": 0.2,\"tax\": 0.2}&foo=bar\r\n```\r\n\r\nI would like to have a easy validation for those fields as well, as this could be automatic\r\n\r\n### The solution you would like\r\n\r\n```python\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Json[Item] = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\n<details><summary>Initial version:</summary>\r\n\r\n\r\nThis was the initial thought, before I discovered the `Json` type.\r\n```python\r\n@routes.api_route('/test', methods=['GET', 'POST'], tags=['official', 'message', 'send'])\r\nasync def test(\r\n    moop: Item = Query(..., description='Something something'),\r\n    foo: str = Query(...),\r\n):\r\n    return {'woop': moop, 'lol': foo}\r\n# end def\r\n```\r\n\r\n</details>\r\n\r\n### Bug you face\r\n\r\n```py\r\nAssertionError: Param: moop can only be a request body, using Body(...)\r\n```\r\n\r\n### Describe alternatives you've considered\r\n\r\n```py\r\n    moop: str\r\n```", "output": "Resolution:\nSo, let me get this straight. Not only does FastAPI by default assume that model-typed parameters on GET route functions are passed in the request body, despite request bodies on GET requests being strongly discouraged, it also actively _gets in my way_ when I try to correct that obviously incorrect default?", "source": "issue_closed", "type": "qa_resolution", "issue_number": 65}
{"instruction": "How was this issue resolved: Multiple aliases for query parameters", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\nI would like to be able to do this:\r\n\r\n<!-- Replace the code below with your own self-contained, minimal, reproducible, example -->\r\n\r\n```Python\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef get(query: Optional[st", "output": "Resolution:\nI am not sure if this is helpful, but I'd like to share my perspective on this matter. As far as I see there are two kinds of related needs in functionality that come with very different impact on the existing implementation:\r\n\r\n1. The less intrusive way: The ability to define one \"public\" and one \"internal\" version/alias for parameter names to have e.g. camel-cased parameters (`someParam`) published via the API, while working with snake-cased (`some_param`) parameters internally. There'd be no ambiguity about what to display in the swagger doc, because there'd be only one \"public\" version of each parameter.\r\n2. Allowing arbitrary public parameter aliases. I can see that this might be handy in some situations, but it comes with some difficulties (like the above-mentioned swagger question) and *might* also unnecessarily bloat the framework. But maybe I just overlook an important use case for this.\r\n\r\nI'd argue it's kind of a bummer no. 1 isn't possible.  \r\nAnyway, thank you a lot for this beautiful framework! I really enjoy working with it so far!", "source": "issue_closed", "type": "qa_resolution", "issue_number": 63}
{"instruction": "How was this issue resolved: Making file field as Optional", "input": "I've a form-data request for user signUp process. \r\nThe user can or can't upload it's picture it's optional. \r\nI've created a api, with field types as form and for image as Uploadfile everything works perfect but it is making the image field as required. \r\nIs it possible to make the file input as optional.. \r\nDo share any reference docs..", "output": "Resolution:\n> ning an issue on that project\r\n\r\nNo super required but for testing I'm using it.\r\nThank you very much.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 62}
{"instruction": "How was this issue resolved: Error loading ASGI app. Could not import module \"src.main\"", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nfrom fastapi import Depends, FastAPI, HTTPException, status\r\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\r\nfrom fastapi.security.oauth2 import OAuth2PasswordRequestForm\r\nfrom . import models\r\nfrom . import services\r\nfrom .database import engine, get_db\r\nfrom passlib.context import CryptContext\r\nfrom sqlalchemy.orm import Session\r\nfrom datetime import datetime, timedelta\r\n\r\napp = FastAPI()\r\n\r\noauth2_scheme = OAuth2PasswordBearer(tokenUrl='login')\r\n\r\npwd_context = CryptContext(schemes=['bcrypt'], depracated='auto')\r\n\r\nmodels.Base.metadata.create_all(bind=engine)\r\n\r\nSECRET_KEY = '[SECRET KEY]'\r\nALGORITHM = 'HS256'\r\nACCESS_TOKEN_EXPIRE_MINUTES = 30\r\n\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\r\n    \r\n@app.get(\"/test/\")\r\nasync def test(token:str = Depends(oauth2_scheme)):\r\n    return {'token', token}\r\n\r\n@app.post('/login/{method}')\r\nasync def login(method: str, form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db), ):\r\n    user = services.authenticate_user(form_data.username, form_data.password)\r\n    if not user:\r\n        raise HTTPException(\r\n            ", "output": "Resolution:\nI got absolutely the same issue, Error loading ASGI app. Attribute \"app\" not found in module \"main\". \r\nWhile it was like this, it didn't work:\r\n```\r\nfrom fastapi import FastAPi\r\napp = FastAPI()\r\n```\r\n\r\nbut since I've changed the import, it started:\r\n```\r\nimport fastapi\r\n\r\napp = fastapi.FastAPI()\r\n```\r\n\r\njust in case, someone else will get the same issue. Windows 11, home edition.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 61}
{"instruction": "How was this issue resolved: Production configuration of gunicorn", "input": "NOTE: I'm not sure whether i should be filing this here or upstream on starlette. Please let me know if Starlette developers are more knowledgeable about this. However, I'm using fastapi.\r\n\r\nWhat is a good configuration setting for gunicorn in production.\r\n\r\nOn reading documentation of gunicorn with uvicorn, there are lines like this \r\n\r\n> \"Gunicorn provides a different set of configuration options to Uvicorn, so some options such as --limit-concurrency are not yet supported when running with Gunicorn\"\r\n\r\nIs it possible for you to share a list of options that work well ? One of the biggest question is around threads - should we set the threads option?\r\nwhat about stuff like \"worker_connections\" , \"keepalive\" (especially in context of async code)", "output": "Resolution:\n@tiangolo \r\nThank you very much for your detailed explanation.\r\nIt really helps :)\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 60}
{"instruction": "How was this issue resolved: FastAPI keeps booting new workers when deploying", "input": "Hi there,\r\n\r\nI'm trying to run two different instances of FastAPI in the same Kubernetes pod (different Docker containers), but one of the two seems to keep booting up new workers. Therefor, the container uses a lot of CPU for nothing. It's also reporting that it's waiting for application startup constantly, but it is reachable (but slow).\r\n\r\nHere is the log that I keep getting:\r\n\r\n```\r\nChecking for script in /app/prestart.sh\r\nRunning script /app/prestart.sh\r\nRunning inside /app/prestart.sh, you could add migrations to this file, e.g.:\r\n #! /usr/bin/env bash\r\n # Let the DB start\r\nsleep 10;\r\n# Run migrations\r\nalembic upgrade head\r\n [2019-05-24 11:51:24 +0000] [1] [INFO] Starting gunicorn 19.9.0\r\n[2019-05-24 11:51:24 +0000] [1] [INFO] Listening at: http://0.0.0.0:8081 (1)\r\n[2019-05-24 11:51:24 +0000] [1] [INFO] Using worker: uvicorn.workers.UvicornWorker\r\n[2019-05-24 11:51:24 +0000] [8] [INFO] Booting worker with pid: 8\r\n[2019-05-24 11:51:24 +0000] [9] [INFO] Booting worker with pid: 9\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\n[2019-05-24 11:51:33 +0000] [9] [INFO] Started server process [9]\r\n[2019-05-24 11:51:33 +0000] [9] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:33 +0000] [8] [INFO] Started server process [8]\r\n[2019-05-24 11:51:33 +0000] [8] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:37 +0000] [18] [INFO] Booting worker with pid: 18\r\nWARNING:root:email-validator not installed, email fields will be treated as str.\r\nTo install, run: pip install email-validator\r\n[2019-05-24 11:51:44 +0000] [18] [INFO] Started server process [18]\r\n[2019-05-24 11:51:44 +0000] [18] [INFO] Waiting for application startup.\r\n[2019-05-24 11:51:45 +0000] [23] [INFO] Booting worker with pid: 23\r\nWARNING:root:email-validator not installed, email field", "output": "Resolution:\n> I have the same issues when deploy FastAPI on GCP's k8s.\r\n\r\nIt turns out is the pod's memory limit is too small, after increase the memory limit the `booting worker` issue disappear it.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 58}
{"instruction": "How was this issue resolved: File Upload Difficulties", "input": "Hello - I am not having any luck with file upload to FastAPI - I am trying to load JPEG images.  I have reviewed the other github, stackoverflow comments and none of the solutions work. \r\n\r\nI believe the issue is with the front-end - and I am able to get it to work with the swagger \\docs interface.  From my front-end I have tried submitting directly from a form as well as formData via XMLHttpRequest and fetch (would prefer either of the latter).  I am using plain javascript. \r\n\r\nI am sure I am doing something wrong - I just don't know what it is.  Any advice would be deeply appreciated - I am 20+hours deep into trying to solve this one.  **Thanks in advance!**\r\n\r\n**Here is the swagger curl:**\r\n``curl -X POST \"http://localhost:8000/staff/upload_image/\" -H  \"accept: application/json\" -H  \"Content-Type: multipart/form-data\" -F \"image=@_WGL1281.jpg;type=image/jpeg\"\r\n``\r\n\r\n**Server Reply:  POST http://localhost:8000/staff/upload_image/ 422 (Unprocessable Entity)**\r\n\r\n**Installed Versions:**\r\n```\r\nfastapi - 0.54.1\r\nstarlette - 0.13.2\r\npydantic - 1.5.1\r\npython - 3.832\r\npython-multipart - 0.0.5\r\n\r\n```\r\n**Server side code snippets:**\r\n\r\n```\r\nfrom fastapi import APIRouter, Request, Depends, File, UploadFile\r\n\r\n@router.post(\"/staff/upload_image/\")\r\nasync def upload_image(image: UploadFile = File(...)):\r\n\tprint(image.filename)\r\n\treturn {\"filename\": image.filename}\r\n\r\n```\r\n\r\n**client side:**\r\n```\r\nasync function imageupload(){\r\n            let imageinput = document.getElementById('testimage');\r\n            let formData = new FormData();\r\n            formData.append('imagefile', imageinput.files[0]);\r\n\r\n            let response = await fetch('/staff/upload_image/', {\r\n                method: 'POST',\r\n                body: formData\r\n            })\r\n\r\n            await console.log(response);\r\n\r\n```", "output": "Resolution:\nI faced similar issue. I was trying to send a csv file from frontend to backend. My issue got resolved by removing CONTENT-TYPE from header in my request.\r\n\r\nMy frontend in ReactJS\r\n\r\n```\r\n    const handleSubmissionDelete = async() => {\r\n        if(!isFilePickedDelete) return;\r\n        const formData = new FormData();\r\n        formData.append(\"file\", selectedFileDelete);\r\n        const requestOptions = {\r\n            method: \"POST\",\r\n            headers: {\r\n            Authorization: \"Bearer \" + token,\r\n            },\r\n            body: formData,\r\n          };   \r\n          const response = await fetch(env.BACKEND + `/deleteLightsFile`, requestOptions);\r\n          const data = await response.json();\r\n      \r\n          if (!response.ok) {\r\n            setErrorMessage(data.detail);\r\n          } else {\r\n            setLights([])\r\n          }\r\n    }\r\n```\r\n\r\nAnd my backend looked like\r\n\r\n```\r\n@app.post(\"/deleteLightsFile\")\r\nasync def deleteLightsFile(file: UploadFile = File(...), user: _schemas.User = Depends(_services.get_current_user)):\r\n    \r\n    authenticate_user(user.email)\r\n    df = pd.read_csv(file.file, dtype={'Unique Pole No.':str, 'Wattage':str})\r\n    lampposts = []\r\n     .....\r\n    return {'response': \"successfully deleted all csv poles\"}\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 57}
{"instruction": "How was this issue resolved: FastAPI 0.65.2 POST request fails with \"value is not a valid dict\" when using the Requests library; 0.65.1 works (with a caveat)", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ ] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [ ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ ] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\nFirst off, thank you for creating this marvellous piece of software. It is a real life-changer.\r\n\r\nI hit a very odd bug while implementing some unit tests. Using FastAPI `0.65.2`, a POST request via the `requests` module (`requests.post`) consistently returns the following error:\r\n\r\n`{'detail': [{'loc': ['body'], 'msg': 'value is not a valid dict', 'type': 'type_error.dict'}]}`\r\n\r\nI created a reproducible example:\r\n\r\n```\r\nfrom fastapi import FastAPI\r\nfrom pydantic import BaseModel\r\nimport uvicorn\r\n\r\napp = FastAPI()\r\n\r\nclass Data(BaseModel):\r\n    field: str\r\n\r\n\r\n@app.post(\"/test\")\r\ndef test_data(data: Data):\r\n    return \"Polo\"\r\n\r\nif __name__=='__main__':\r\n    uvicorn.run(app)\r\n```\r\n\r\nAnd the `requests` counterpart:\r\n\r\n```\r\nimport requests as rq\r\n\r\ndef test():\r\n    result = rq.post('http://127.0.0.1:8000/test', data={\"field\": \"Marco\"})\r\n    print(f\"==[ resul", "output": "Resolution:\nOn Postman, you can solve problems by changing `Content-Type` headers to `application/json`, view solution at https://stackoverflow.com/questions/71470236/post-request-response-422-error-detail-loc-body-msg-value-is-n/74947229#74947229", "source": "issue_closed", "type": "qa_resolution", "issue_number": 56}
{"instruction": "How was this issue resolved: FastAPI with Pydantic v2", "input": "Is FastAPI with support for Pydantic v2 working for you (`0.100.0-beta1`)?\r\n\r\n~Let me know **in this discussion** on the link: https://github.com/tiangolo/fastapi/discussions/9709~\r\n\r\n~(don't comment in this issue, please go to the discussions and follow the instructions there)~\r\n\r\nAs FastAPI now supports Pydantic v2, any problems are not about the beta (as it's already released ðŸ˜…), so let's keep the normal workflow.\r\n\r\nIf you are having problems, please create a new Discussion question following the template! ðŸ™  https://github.com/tiangolo/fastapi/discussions/new?category=questions", "output": "Resolution:\nI'll lock this issue. As @tiangolo said, the idea of this issue was to redirect people to the discussion on #9709. ðŸ‘€ \r\n\r\nIt's easier to organize the issues if everything is over there. ðŸ˜… \r\n\r\nIf you have an issue with FastAPI + Pydantic V2, please post it on #9709, or create a new discussion. ðŸ™ ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 55}
{"instruction": "How was this issue resolved: How to send 204 response?", "input": "I tried to send 204 response in delete method\r\n\r\nExample handler\r\n```\r\n@router.delete('/{order_id}/', tags=['smart order'], status_code=204)\r\nasync def cancel_smart_order(\r\n        session: Session = Depends(get_session),\r\n        order_id: UUID = Path(...)\r\n):\r\n    order = await session.get(order_id)\r\n\r\n    if order.status != OrderStatus.open:\r\n        raise HTTPException(409, f'Order have status: {order.status}')\r\n\r\n    order.status = OrderStatus.canceled\r\n\r\n    await session.commit_only(order)\r\n```\r\n\r\nBut got error `h11._util.LocalProtocolError: Too much data for declared Content-Length`. Seems framefork convert None to null but set content length 0.", "output": "Resolution:\n> > Instead of returning `None`, and instead of injecting the response, just return a newly created response. It would look like:\r\n> > ```python\r\n> > @api.get(\r\n> >     \"/test_request_results/{test_request_id}\",\r\n> >     response_model=schemas.TestRequestResults,\r\n> >     responses={204: {\"model\": None}},\r\n> > )\r\n> > async def read_test_request_results(test_request_id: int):\r\n> >     # ... snipped ...\r\n> >     if not complete:\r\n> >         return Response(status_code=HTTP_204_NO_CONTENT)\r\n> > ```\r\n> > \r\n> > \r\n> >     \r\n> >       \r\n> >     \r\n> > \r\n> >       \r\n> >     \r\n> > \r\n> >     \r\n> >   \r\n> > The reason you are getting content is because FastAPI uses a `JSONResponse` by default (instead of a `Response`), which converts the returned value `None` to `\"null\"`. By returning a `Response` directly, you prevent FastAPI from using the `JSONResponse` and encoding the `None`.\r\n> \r\n> and how can I add a message to that Response?\r\n\r\nWell, that's the whole idea with `204`: you shouldn't. If you want to add a message to a `Response`, just return status code `200` and the message in JSON or whatever.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 54}
{"instruction": "How was this issue resolved: Using MQTT with FastAPI", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description: How can I receive MQTT with fastAPI?\r\n\r\nMQTT is used often in IoT. It is much lighter than HTTP and is build on top of TCP. It can also use a WebSocket transport layer.\r\n\r\nI can think of the following options and would be interested to hear what you think.\r\n\r\n#### 1. Use Flask middleware\r\n\r\nFlask has support for MQTT routes, so I could follow the instructions here to implement Flask middleware, https://fastapi.tiangolo.com/advanced/wsgi/#using-wsgimiddleware, however I don't know if this works in general for any protocol (HTTP, MQTT, WS etc.) of if it only routes HTTP.\r\n\r\n#### 2. Use RabbitMQ\r\n\r\n[RabbitMQ](https://www.rabbitmq.com/mqtt.html) has support for MQTT. But I'm unsure how I would integrate this with FastAPI. It would not be appropriate to use a background task, https://fastapi.tiangolo.com/tutorial/background-tasks/ because these are tasks that fired off after returning a response. Probably I would need to use an asyncio.Queue and call API methods manually when an event arrives.\r\n\r\n#### 3. Use MQTT over Websocket\r\n\r\n[paho-mqtt](https://www.eclipse.org/paho/clients/python/docs/) can use WebSocket transport. Again I'm unsure how to integrate this with FastAPI. Could I use the `@websocket` decorator. Probably not because that would just be the transport layer, not the protocol layer!\r\n\r\n```python\r\n@app.websocket(\"/sent_data\")  #  PUT called by external client to send data here\r\nasync def recieved_data_mqtt_over_ws():\r\n    pass\r\n```\r\n\r\n#### Would it be possible to ...?\r\n\r\nEventually something like this might be possible?\r\n\r\n```python\r\n@app.mqtt(\"/sent_data\")  #  PUT called by external client to send data here\r\nasync def recieved_data_mqtt_over_ws():\r\n    pass\r\n```\r\n\r\nI have not yet starte", "output": "Resolution:\n@wiserdivisor it will good idea to open an issue in the module itself rather than writing here. Subscribers of this thread will be annoyed getting mails and notifications plus if it is on the module others can also gain some practice instead of posting and discussing here being away from the module. \r\n[fastapi-mqtt-issues](https://github.com/sabuhish/fastapi-mqtt/issues)", "source": "issue_closed", "type": "qa_resolution", "issue_number": 53}
{"instruction": "How was this issue resolved: Italian translations", "input": "### Italian translations tracking\r\nWe can use this Issue to track the progress of the Italian language translations. ðŸ‡®ðŸ‡¹ \r\n\r\nPlease post here what page you plan on translating so we can coordinate. ðŸš€\r\n\r\n**Tips**\r\n* Just like [we're doing with the Spanish translations](https://github.com/tiangolo/fastapi/issues/1218), let's use \"tu\" instead of the more formal \"lei\" or \"voi\".\r\n* If the term is a technical term, leave in English and add an explanation of the meaning of the word in Italian.", "output": "Resolution:\nThanks @matteospanio! \r\nI am sorry that there is not an active community on this issue. I choose a page and get to work ðŸ˜‰", "source": "issue_closed", "type": "qa_resolution", "issue_number": 52}
{"instruction": "How was this issue resolved: 404 Error with OpenAPI", "input": "Hi all,\r\n\r\nNew to fastAPI, and coming from Flask, I'm very impressed by the solution.\r\nBut using the OpenAPI documentation/UI, I can see in the logs that I have the following issue each time I extend a resource/API :\r\n`INFO:     <IP>:57175 - \"GET /%5Bobject%20Module%5D HTTP/1.1\" 404 Not Found`\r\nThe API is working, but I get this error in the log.\r\n\r\nI'm using v0.63.0, on an ubuntu server (18.04)\r\n\r\nThanks a lot for your support.", "output": "Resolution:\nIt also returns a `404` response when passing `url` as a path parameter.\r\n\r\n```python\r\nfrom fastapi import APIRouter\r\nfrom .models import OpenGraphMetaTags\r\n\r\nrouter = APIRouter()\r\n\r\n@router.get(\r\n    path='/opengraph-metatags/{url}',\r\n    response_model=OpenGraphMetaTags,\r\n    response_model_by_alias=True,\r\n    response_model_exclude_none=True,\r\n)\r\nasync def parse_metatags(url: str):\r\n    ...\r\n```\r\n\r\nAbove code works if path paremeter is a plain string eg. `some-string`, but not for something like `https://facebook.com`. Terminal logs show that the request url is \r\n\r\n```bash\r\nINFO: 127.0.0.1:59924 - \"GET /opengraph-metatags/https%3A//facebook.com HTTP/1.1\" 404 Not Found\r\n```\r\n\r\nIt fails to encode the slashes. On swagger I have the following data, tho\r\n![Screenshot from 2021-11-23 13-59-56](https://user-images.githubusercontent.com/86353187/142977445-3459b898-8dd7-407f-a4b8-95d3f64006b7.png)\r\n\r\n\r\nI hope this gets fix soon. I really love **FastAPI**", "source": "issue_closed", "type": "qa_resolution", "issue_number": 51}
{"instruction": "How was this issue resolved: FastAPI debugging", "input": "Hello\r\nI've seen on FastAPI documentation site, that it integrates nice with a VSCode. \r\nAny hint on debugging an FastAPI application in VSCode? There are some exaple configrations for python projects, but unfortunately I'm not able to utilize these for  FastAPI\r\n\r\nThanks\r\nOlegas", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 50}
{"instruction": "How was this issue resolved: enhance serialization speed", "input": "**Description**\r\n\r\nI have to return sometimes big objects, I'm constrained in the fact that chunking them is not an option\r\n\r\nAn example of such an object would be a dict `{\"key:: value}` where value is a list of list, 20 list of 10k elements.\r\n\r\nI wrote this simple [test case](https://github.com/euri10/fastapi/blob/slow_serial/tests/test_serial_speed.py) that shows quite clearly the massive hit in several scenarios (run with `pytest tests/test_serial_speed.py --log-cli-level=INFO`) \r\nHere's the output:\r\n```\r\n======================================================================================================================= 1 passed in 3.68 seconds =======================================================================================================================\r\n(fastapi) âžœ  fastapi git:(slow_serial) âœ— pytest tests/test_serial_speed.py --log-cli-level=INFO\r\n========================================================================================================================= test session starts ==========================================================================================================================\r\nplatform linux -- Python 3.6.8, pytest-5.0.0, py-1.8.0, pluggy-0.12.0\r\nrootdir: /home/lotso/PycharmProjects/fastapi\r\nplugins: cov-2.7.1\r\ncollected 1 item                                                                                                                                                                                                                                                       \r\n\r\ntests/test_serial_speed.py::test_routes \r\n---------------------------------------------------------------------------------------------------------------------------- live log call -----------------------------------------------------------------------------------------------------------------------------\r\nINFO     tests.test_serial_speed:test_serial_speed.py:39 route1: 0.05402565002441406\r\nINFO     tests.test_serial_speed:test_serial_speed.py:18 a", "output": "Resolution:\nYeah, it's also easy enough to write a decorator that performs the conversion to a response for endpoints you know are safe. Something like:\r\n```python\r\ndef go_fast(f):\r\n    @wraps(f)\r\n    async def wrapped(*args, **kwargs):\r\n        return UJSONResponse(await f(*args, **kwargs))\r\n    return wrapped\r\n```\r\n(Might want to use `inspect.iscoroutinefunction` to also handle `def` endpoints.)", "source": "issue_closed", "type": "qa_resolution", "issue_number": 49}
{"instruction": "How was this issue resolved: How can I pass the configuration in the app?", "input": "How can I pass the configuration in the app? Can I do it in some way like it was in Flask with app.config, or this framework manages it differently?", "output": "Resolution:\nAssuming the original issue was solved, it will be automatically closed now. But feel free to add more comments or create new issues.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 48}
{"instruction": "How was this issue resolved: Use UploadFile in Pydantic model", "input": "**Description**\r\n\r\nIs it possible to use `UploadFile` in a Pydantic model? The FastAPI docs [say](https://fastapi.tiangolo.com/tutorial/request-files/) â€œFastAPI's UploadFile inherits directly from Starlette's UploadFile, but adds some necessary parts to make it compatible with Pydantic and the other parts of FastAPI.â€ \r\n\r\n```python3\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom pydantic import BaseModel\r\n\r\nclass PydanticFile(BaseModel):\r\n    file: UploadFile = File(...)\r\n\r\napp = FastAPI()\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(file: PydanticFile):\r\n    return {\"filename\": file.filename}\r\n```\r\n\r\nHowever, `UploadFile` does not seem to be compatible with Pydantic. The code above â€“ derived from the example in FastAPI's [Request Files tutorial](https://fastapi.tiangolo.com/tutorial/request-files/) â€“ raises a value error:\r\n\r\n```\r\nValueError: Value not declarable with JSON Schema, field: file type=UploadFile required\r\n```", "output": "Resolution:\n@rudy-haryanto \r\n\r\nhttps://www.freecodecamp.org/news/formdata-explained/\r\n\r\nAnd same accept it on FastApI side.\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 47}
{"instruction": "How was this issue resolved: ðŸŒ Translations coordination (list of translations)", "input": "Here are the issues coordinating the translations to each language:\r\n\r\n* Portuguese: https://github.com/tiangolo/fastapi/issues/1211\r\n* Spanish: https://github.com/tiangolo/fastapi/issues/1218\r\n* Chinese: https://github.com/tiangolo/fastapi/issues/1228\r\n* Russian: https://github.com/tiangolo/fastapi/issues/1362\r\n* Italian: https://github.com/tiangolo/fastapi/issues/1556\r\n* Japanese: https://github.com/tiangolo/fastapi/issues/1572\r\n* Ukrainian: https://github.com/tiangolo/fastapi/issues/1748\r\n* Turkish: https://github.com/tiangolo/fastapi/issues/1892\r\n* French: https://github.com/tiangolo/fastapi/issues/1972\r\n* Korean: https://github.com/tiangolo/fastapi/issues/2017\r\n* Persian: https://github.com/tiangolo/fastapi/issues/2041\r\n* Polish: https://github.com/tiangolo/fastapi/issues/3169\r\n* German: https://github.com/tiangolo/fastapi/issues/3716\r\n* Indonesian: https://github.com/tiangolo/fastapi/issues/3717\r\n* Azerbaijani: https://github.com/tiangolo/fastapi/issues/3994\r\n* Dutch: https://github.com/tiangolo/fastapi/issues/4701\r\n* Uzbek: https://github.com/tiangolo/fastapi/issues/4883\r\n* Swedish: https://github.com/tiangolo/fastapi/issues/5146\r\n* Hebrew: https://github.com/tiangolo/fastapi/issues/5157\r\n* Tamil: https://github.com/tiangolo/fastapi/issues/5434\r\n* Arabic: https://github.com/tiangolo/fastapi/issues/3349\r\n---\r\n\r\nNote: this meta-issue is here because GitHub only allows a limited number of issues to be pinned, so I can't pin all of them. I'll update it here when there's a new language.", "output": "Resolution:\nTranslations are now coordinated in GitHub Discussions https://github.com/tiangolo/fastapi/discussions/categories/translations :tada: \r\n\r\nI also updated the bot (GitHub Action) to put the notifications for new translations there, and to update comments for PRs that are done. :rocket: :coffee: \r\n\r\nGiven that, I'll now close this issue. :sunglasses: ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 46}
{"instruction": "How was this issue resolved: Typehints  instead of response_model", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\nNow:\r\n```Python\r\nfrom fastapi import FastAPI\r\nfrom typing import Dict, List\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\", response_model=Dict[str, List[str]])\r\ndef read_root():\r\n    return {\"Hello\": [\"tom\", \"hesus\"]}\r\n```\r\n### The solution you would like\r\nI ", "output": "Resolution:\nQuite happy to see this change! One snag I noticed when upgrading (aside from some `-> Response | list[...]` endpoints) was that it seems any models already in the return hint (eg: `-> MyModel`) seem to be _subclassed_, rather than referenced directly. I was using a subclass based registry pattern (using some `__init_subclass__` magic) which automatically checked for dup names - so these autogenerated subclasses caused dups/errors.\r\n\r\n<details>\r\n<summary>Stacktrace</summary>\r\n\r\n```python\r\nTraceback (most recent call last):\r\n  File \"<string>\", line 1, in <module>\r\n  File \".../api.py\", line 87, in <module>\r\n    def get_amplicon_structure_from_benchling(benchling_entity_id: str) -> BarcodeSchema:\r\n  File \"...venv/lib/python3.10/site-packages/fastapi/routing.py\", line 638, in decorator\r\n    self.add_api_route(\r\n  File \"...venv/lib/python3.10/site-packages/fastapi/routing.py\", line 577, in add_api_route\r\n    route = route_class(\r\n  File \"...venv/lib/python3.10/site-packages/fastapi/routing.py\", line 417, in __init__\r\n    ] = create_cloned_field(self.response_field)\r\n  File \"...venv/lib/python3.10/site-packages/fastapi/utils.py\", line 117, in create_cloned_field\r\n    use_type = create_model(original_type.__name__, __base__=original_type)\r\n  File \"pydantic/main.py\", line 1027, in pydantic.main.create_model\r\n  File \"pydantic/main.py\", line 283, in pydantic.main.ModelMetaclass.__new__\r\n  File \"...venv/lib/python3.10/abc.py\", line 106, in __new__\r\n    cls = super().__new__(mcls, name, bases, namespace, **kwargs)\r\n  File \".../some_models.py\", line 87, in __init_subclass__\r\n    raise ValueError(f\"Duplicate class with feature_class={name}: {dup}\")\r\nValueError: Duplicate class with feature_class=...\r\n```\r\n\r\n</details>\r\n\r\nThis is a pretty esoteric edge case so fine if it's not worth fixing (the well documented `response_model=None` workaround works!), but thought I might flag in case it'd be easy to avoid.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 45}
{"instruction": "How was this issue resolved: Too many emojis in 'Concurrency and async / await' explanation", "input": "The explanation page for concurrency, and more specifically its example with burgers (https://fastapi.tiangolo.com/async/#concurrent-burgers) becomes hard to read for me because of its many emojis.\r\n\r\nAn excerpt:\r\n\r\n> You go with your crush ðŸ˜ to get fast food ðŸ”, you stand in line while the cashier ðŸ’ takes the orders from the people in front of you.\r\n> Then it's your turn, you place your order of 2 very fancy burgers ðŸ” for your crush ðŸ˜ and you.\r\n> You pay ðŸ’¸.\r\n> The cashier ðŸ’ says something to the guy in the kitchen ðŸ‘¨â€ðŸ³ so he knows he has to prepare your burgers ðŸ” (even though he is currently preparing the ones for the previous clients).\r\n> The cashier ðŸ’ gives you the number of your turn.\r\n> While you are waiting, you go with your crush ðŸ˜ and pick a table, you sit and talk with your crush ðŸ˜ for a long time (as your burgers are very fancy and take some time to prepare âœ¨ðŸ”âœ¨).\r\n> As you are sitting on the table with your crush ðŸ˜, while you wait for the burgers ðŸ”, you can spend that time admiring how awesome, cute and smart your crush is âœ¨ðŸ˜âœ¨.\r\n...\r\nBut as you go away from the counter and sit on the table with a number for your turn, you can switch ðŸ”€ your attention to your crush ðŸ˜, and \"work\" â¯ ðŸ¤“ on that. Then you are again doing something very \"productive\" ðŸ¤“, as is flirting with your crush ðŸ˜.\r\n\r\nIn my opinion, the many emojis don't add anything to the explanation and make it hard to read. **Every emoji breaks the flow when reading because my eyes are distracted by the emojis' size and colour.**\r\n\r\nIs the 'ðŸ˜' after every 'crush' necessary? Same with burger and ðŸ”, cashier and ðŸ’ and so on.\r\n\r\nI propose cutting down on or completely removing emojis from the documentation to help with readability.\r\n\r\nThe same issue, though less pronounced, is also apparent in the section 'Asynchronous Code' (https://fastapi.tiangolo.com/async/#asynchronous-code).\r\n\r\n***\r\n\r\n(If you want to know what it feels like to read the documentation, try reading this:)\r\n\r\nIn my ðŸ§‘opinion ðŸ¤”, the manyðŸ”¢ emojis", "output": "Resolution:\nIt's sad that it seems some didn't realize the purpose of the emojis there.\r\n\r\nThe emojis in that section were not intended as plainly decorative. I agree it feels too much and I didn't like how dense it felt. But they had a purpose.\r\n\r\nThe emojis in the article were intended as a [visual cue](https://en.wikipedia.org/wiki/Sensory_cue), to make it easier to relate a reference to one entity with other references to the same entity. They were always the same emoji, the same number (when repeated). It was all to help reduce the [cognitive load](https://en.wikipedia.org/wiki/Cognitive_load) while studying the concepts.\r\n\r\nThat way, when you see an emoji, you can do the mental equivalent of a hash key search (a Python dict lookup), in $O(1)$ (constant time), matching the emoji with the entity. Instead of having to parse again the whole text searching for all the references to try and see if that particular word refers to the burger, the crush, the cook, etc. which would be $O(n)$, linear time (like searching for a value in a list).\r\n\r\nAlso, thumbs up in this issue only count for the people that don't like emojis and come looking for the issue. But for the people that are fine with emojis, they wouldn't come looking for the issue to add a thumbs down, so it's not really a safe/fair measure.\r\n\r\nOn the other hand, that section in the docs is what I have seen screenshotted the most, with people publishing how much they like it. So, I guess it's just a division in taste.\r\n\r\n---\r\n\r\nI don't appreciate sarcastic, passive-aggressive, and demeaning comments, those are not welcome here.\r\n\r\nThanks to everyone here that made comments to support, improve, and help, with clear and calm arguments. That is much appreciated.\r\n\r\n---\r\n\r\nI recently hired Ketrina Yim, a professional illustrator specialized in computer science to add illustrations to that section. That was always my ideal, and the emojis were just trying to help while that was available, it has finally landed.\r\n\r\nYou can see the new docs here: https://fastapi.tiangolo.com/async/#concurrency-and-burgers\r\n\r\nWith that, I reduced the use of emojis a lot. But I still kept some in some places that don't have illustrations and where the visual cues to reduce cognitive load would make sense.\r\n\r\nGiven that, I'm gonna close this issue now. Thanks for the interactions everyone! :coffee: ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 44}
{"instruction": "How was this issue resolved: SQLAlchemy Dependency vs. Middleware vs. scoped_session", "input": "The SQLAlchemy library comes with a `scoped_session` object, which effectively allows for thread-safe database sessions. Is there a reason the docs recommend using the dependency method > middleware method > just a `scoped_session` global?", "output": "Resolution:\n> It really scares me that the [tutorial docs](https://fastapi.tiangolo.com/tutorial/sql-databases/) still state to use the standard dependency driven approach, but from the various conversations around it seems like it falls apart under production load. Do we not yet have an _official_ path for utilizing sqlalchemy with fastapi?\r\n\r\n@shawnwall: That would be SQLAlchemy 1.4's async mode, though by the looks of it, the FastAPI tutorial has yet to be updated to recommend this. It would probably need to go into some details about the kind of thread pool vs connection pool issues that have been raised in issues mentioned here (and issues that have mentioned this one), otherwise I'd forsee some people falling into that same trap even after the tutorial gets updated.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 43}
{"instruction": "How was this issue resolved: Update docs include syntax for source examples", "input": "### Privileged issue\r\n\r\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\r\n\r\n### Issue Content\r\n\r\nThis is a good first contribution. :nerd_face: \r\n\r\nThe code examples shown in the docs are actual Python files. They are even tested in CI, that's why you can always copy paste an example and it will always work, the example is tested.\r\n\r\nThe way those examples are included in the docs used a specific format. But now there's a new format available that is much simpler and easier to use than the previous one, in particular in complex cases, for example when there are examples in multiple versions of Python.\r\n\r\nBut not all the docs have the new format yet. The docs should use the new format to include examples. That is the task. :nerd_face: \r\n\r\n**It should be done as one PR per page updated.**\r\n\r\n## Simple Example\r\n\r\nBefore, the format was like:\r\n\r\n````markdown\r\n```Python hl_lines=\"3\"\r\n{!../../docs_src/first_steps/tutorial001.py!}\r\n```\r\n````\r\n\r\nNow the new format looks like:\r\n\r\n````markdown\r\n{* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n````\r\n\r\n* Instead of `{!` and `!}` it uses `{*` and `*}`\r\n* It no longer has a line above with:\r\n\r\n````markdown\r\n```Python\r\n````\r\n\r\n* And it no longer has a line below with:\r\n\r\n````markdown\r\n```\r\n````\r\n\r\n* The highlight is no longer a line with e.g. `hl_lines=\"3\"` (to highlight line 3), but instead in the same line there's a `hl[3]`.\r\n\r\nAn example PR: https://github.com/fastapi/fastapi/pull/12552\r\n\r\n## Multiple Python Versions\r\n\r\nThere are some cases where there are variants of the same example for multiple versions of Python, or for using `Annotated` or not.\r\n\r\nIn those cases, the current include examples have syntax for tabs, and notes saying `Annotated` should be preferred. For example:\r\n\r\n````markdown\r\n//// tab | Python 3.9+\r\n\r\n```Python hl_lines=\"4  8  12\"\r\n{!> ../../docs_src/security/tutorial006_an_py39.py!}\r\n```\r\n\r\n////\r\n\r\n//// tab | Python 3.8+\r\n\r\n```Python hl_lines=\"2  7  11\"\r\n{!> ../../docs_src/securit", "output": "Resolution:\nThis is finished now, thanks everyone for the help! :cake: :coffee: ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 42}
{"instruction": "How was this issue resolved: about threads issue with fastapi.", "input": "Hi, I have a question about the threads issue with fastapi.\r\n\r\n\r\nWhen I run the example from tutorial `uvicorn main:app --reload --port 4681 --host 0.0.0.0` with the following `main.py`\r\n```python\r\nfrom fastapi import FastAPI\r\napp = FastAPI()\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n@app.get(\"/items/{item_id}\")\r\ndef read_item(item_id: int, q: str = None):\r\n    return {\"item_id\": item_id, \"q\": q}\r\n```\r\n\r\nand it show up the following information\r\n```\r\nINFO: Started server process [18983]\r\nINFO: Waiting for application startup.\r\nINFO: Uvicorn running on http://0.0.0.0:4681 (Press CTRL+C to quit)\r\n```\r\n\r\n__then I use `ps -o nlwp 18983` to see how many threads this process (18983) is using.__\r\n\r\nHowever, everytime when I send a request to this service, the number of threads increase without being closed. To be more specific, __when I send 1000 requests, this process ended up with 1000 threads running.__\r\n\r\nThis is problematic because I tried to serve another more complicated applications, allocating arbitrary number of threads would finally get my machine out of resources.\r\n\r\nIs there any thing I could have done wrong?\r\nThanks in advance!", "output": "Resolution:\n@seahrh and @emarbo's  solution seems to work for us as well.  big +1 to being able to set this as a global config.  For reference our workload is somewhat similar using numpy/scipy along with fastapi to return larger (~10-20mb) time series data.  Thanks for the great discussion and good insights everyone and thanks to @tiangolo of course for the excellent library!", "source": "issue_closed", "type": "qa_resolution", "issue_number": 41}
{"instruction": "How was this issue resolved: Are there any api developer docs?", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nWhat I mean by api developer docs are basically something like sphinx docs for function definitions. This is usually generated from function docstrings (which I didn't see any in my small amount of browsing the FastAPI codebase). For example, here are the docs for github3 https://github3py.readthedocs.io/en/master/api-reference/index.html. It is an easy way to click through the entire package and see class and function definitions.\r\n\r\nDoes FastAPI have these? The tutorial docs look pretty good, but sometimes I just want to know what all the function parameters are independent of the context in a tutorial.", "output": "Resolution:\n@tiangolo don't let perfect be the enemy of good. Documentation seems to be a huge ask and it's currently one of the primary reasons why I'm getting pushback against migrating to fastapi.\r\n\r\nThis issue is now open for over 3 years with nothing to show for it. Add something, anything, then iterate to get it to the state you want it in.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 40}
{"instruction": "How was this issue resolved: Validation in the FastAPI response handler is a lot heavier than expected", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nSo I have built a Tortoise ORM to Pydantic adaptor, and it's about stable, so I started profiling and found some interesting.\r\n\r\nPydantic will validate the data I fetch from the DB, which seems redundant as the DB content is already validated. So we are doing double validation.\r\nFurther profiling I found that the majority of time is spent by FastAPI preparing the data for serialisation, and then validating it, and then actually serialising (This specific step is what https://github.com/tiangolo/fastapi/issues/1224#issuecomment-617243856 refers to)\r\n\r\nSo I am doing essentially triple validation...\r\n\r\nI then saw that there is the orjson integration, I tried that... and it made no difference that I could tell. (I'll get to this later)\r\n\r\nI did a few experiments (none of them properly tested, but just to get an idea) with a simple benchmark:\r\n(The database was populated with 200 junk user profiles generated by hypothesis, response is 45694 bytes)\r\n\r\nKey:\r\nR1 â†’ Using FastAPI to serialise a `List[User]` model automatically (where `User` is a Pydantic model)\r\nR2 â†’ Using FastAPI to serialise a `List[User]` model automatically, but disabled the validation step in `serialize_response`\r\nR3 â†’ Manually serialised the data using an `ORJSONResponse`\r\nR4 â†’ Using FastAPI to serialise a `List[User]` model automatically, bypassed the `jsonable_encoder` as I'm serialising with orjson\r\nR5 â†’ Using FastAPI to serialise a `List[User]` model automatically, bypassed both validation and `jsonable_encoder`\r\nC1 â†’ Use provided pydantic `from_orm` \r\nC2 â†’ Custom constructor that doesn't validate\r\n\r\nMy results are:\r\nR1 + C1 â†’ 42req/s\r\nR1 + C2 â†’ 43req/s  (Seems the 3 FastAPI steps overpower the validation overhead of `from_o", "output": "Resolution:\nAlso note that there are some differences when returning a `Response` vs returning a model, as headers set in dependencies won't be propagated to the response. See https://github.com/tiangolo/fastapi/issues/5498#issuecomment-1280021249\r\n\r\nSee comment from tiangolo https://github.com/tiangolo/fastapi/issues/5498#issuecomment-1308701700", "source": "issue_closed", "type": "qa_resolution", "issue_number": 39}
{"instruction": "How was this issue resolved: how can i run scheduling tasks using fastapi's", "input": "**Description**\r\n\r\nHow can I [...]?\r\n\r\nIs it possible to [...]?\r\n\r\n**Additional context**\r\nAdd any other context or screenshots about the feature request here.", "output": "Resolution:\n> @lambdaq: Yeah, that's what I've come to understand myself over the years. [Prefect](https://github.com/PrefectHQ/prefect) is partially based on FastAPI but they have the task-running part outside of the API server part (which only does scheduling and orchestration) for this reason among others, and you would probably be better using a system that's built for 24/7 task scheduling like that than trying to hack something of your own around an ASGI server.\r\n\r\nI got similar problems and ended up using apscheduler for this matter", "source": "issue_closed", "type": "qa_resolution", "issue_number": 38}
{"instruction": "How was this issue resolved: Will FastAPI support QUERY http method? \"app.query\"", "input": "### Discussed in https://github.com/fastapi/fastapi/discussions/6049\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **FilipeMarch** December 16, 2022</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.query('/query/subjects')\r\ndef query_subjects(schema: ArbitrarySchema):\r\n    with Session(engine) as db:\r\n        subjects = db.query(Subject).all()\r\n        return schema(**subjects)\r\n\r\n# something like this\r\n```\r\n\r\n\r\n### Description\r\n\r\nThere is a new HTTP method called QUERY, I discovered it this week and it is super interesting!\r\n\r\nhttps://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html\r\n\r\nI was trying to make a GET route that would accept a request body, but started receiving an error on Swagger UI:\r\n\r\n[TypeError: Request has method 'GET' and cannot have a body](https://github.com/swagger-api/swagger-ui/issues/5891#issuecomment-1340591857)\r\n\r\nThe idea is that sometimes we need to make a big or complex query, and this is the scenario in which we can see the advantages of GraphQL, and although I have seen that [we can integrate FastAPI with GraphQL](https://fastapi.tiangol", "output": "Resolution:\nFastAPI will support the Query method at some point, but first it needs to have OpenAPI 3.2, ideally a UI that supports it, etc. I'll keep tracking this internally but I'll close this issue as it seems its existence is making a few people send AI generated PRs, in many cases incomplete, not following the internal code conventions, etc. â˜• ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 37}
{"instruction": "How was this issue resolved: How to bridge Pydantic models with SQLAlchemy?", "input": "**Description**\r\n\r\nUp until database interaction is introduced, the tutorial for FastAPI uses pydantic models for everything, such as this example in [the sextion on Extra Models](https://fastapi.tiangolo.com/tutorial/extra-models/) :\r\n\r\n```python\r\nclass UserOut(BaseModel):\r\n    username: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n\r\n\r\nclass UserInDB(BaseModel):\r\n    username: str\r\n    hashed_password: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n```\r\n\r\nThis alows for the \"database model\" to have private data which will not be exposed through the API. Later, in [the section on security](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/), a similar trick is used, but this time using inheritance to stack the two models (which I find makes the return-casting used by some functions better encoded in the type system).\r\n\r\n```py\r\nclass User(BaseModel):\r\n    username: str\r\n    email: str = None\r\n    full_name: str = None\r\n    disabled: bool = None\r\n\r\n\r\nclass UserInDB(User):\r\n    hashed_password: str\r\n```\r\n\r\n```py\r\ndef get_db_user() -> UserInDB:\r\n    return UserInDB(\r\n        username=\"johndoe\", full_name=\"John Doe\",\r\n        email=\"johndoe@example.com\",\r\n        hashed_password=\"fakehashedsecret\",\r\n        disabled=False\r\n    )\r\n\r\ndef get_user() -> User:\r\n    return get_db_user()\r\n```\r\n\r\nHowever, when [proper databases are introduced](https://fastapi.tiangolo.com/tutorial/sql-databases/), those Pydantic models are dropped in favor of a single SQLAlchemy ORM model, with no effort to bridge the two parts. And while one could see this as the SQLAlchemy models completely superseding the Pydantic models, [the fullstack demo app](https://github.com/tiangolo/full-stack-fastapi-postgresql) appears to [actually use both](https://github.com/tiangolo/full-stack-fastapi-postgresql/blob/ecd634e49715bb57fdfeb35b9dba21a6e94cf012/%7B%7Bcookiecutter.project_slug%7D%7D/backend/app/app/api/api_v1/endpoints/login.py#L13-L16), so there appears to be value in attempt", "output": "Resolution:\n@tiangolo I think you created https://github.com/tiangolo/pydantic-sqlalchemy with this issue in the back of your mind. Which approach would you currently recommend (`orm_mode` vs. external libraries also mentioned in this issue)?", "source": "issue_closed", "type": "qa_resolution", "issue_number": 36}
{"instruction": "How was this issue resolved: Suggest middlwares for oauth2 against external providers", "input": "### Is your feature request related to a problem\r\n\r\nIs your feature request related to a problem? Yes\r\n\r\nIt is unclear how to integrate an external oauth provider such as Microsoft, Google, Auth0 with FastAPI.\r\n\r\n### The solution you would like\r\n\r\nA section on the documentation describing how to achieve this, or which libraries do we recommend to do so.\r\n\r\nTwo examples include [the client from authlib](https://docs.authlib.org/en/stable/client/starlette.html) and [starlette-oauth2-api](https://pypi.org/project/starlette-oauth2-api/).\r\n\r\n### Describe alternatives you've considered\r\n\r\nPR an implementation to FastAPI. The reason I avoided this is because OAuth is not a thing of FastAPI only, but of a web app in general.\r\n\r\n### Additional context\r\n\r\nI am the author of starlette-oauth2-api, which we have been using to secure an API of ours against access tokens signed by external providers (multi-tenancy).", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 35}
{"instruction": "How was this issue resolved: Russian translation", "input": "### ðŸ‡·ðŸ‡º Russian translation\r\n\r\nComrades from Russia need this :-)\r\nLet me know if you need a more precise plan for translating documentation into Russian. I created this issue to track and coordinate translation activities.\r\n\r\n_(in Soviet Russia documentation translates YOU)_", "output": "Resolution:\nGood news everyone! ðŸ˜‰ There's a new translation PR to be reviewed: #5890 ðŸŽ‰", "source": "issue_closed", "type": "qa_resolution", "issue_number": 34}
{"instruction": "How was this issue resolved: FastApi & MongoDB - the full guide", "input": "### Description\r\n\r\nIn this issue i'd like to gather all the information about the use of MongoDB, FastApi and Pydantic. At this point this is a \"rather complete\" solution, but i'd like to gather feedback and comments from the community to se how it can be improved.\r\n\r\nThe biggest pain point that started this and several other threads when trying to use FastAPI with mongo is the `_id` field. There are several issues here:\r\n1. Most known one - `_id` field being `ObjectId`, which is not very JSON-friendly\r\n2. `_id` field by it's naming is not very python-friendly (that is, written as is in Pydantic model, it would become a private field - many IDEs will point that)\r\n\r\nBelow i'll try to describe solutions i've found in different places and see what cases do the cover and what's left unsolved.\r\n\r\nLet's say, we have some Joe, who's a regular developer. Joe just discovered FastAPI and is familiar with mongo (to the extend that he can create and fetch documents from DB). Joe wants to build clean and fast api that would:\r\n\r\n1ï¸âƒ£ Be able to define mongo-compatible documents as regular Pydantic models (with all the proper validations in place):\r\n```python\r\nclass User(BaseModel):\r\n    id: ObjectId = Field(description=\"User id\")\r\n    name: str = Field()\r\n```\r\n2ï¸âƒ£ Write routes that would use native Pydantic models as usual:\r\n ```python\r\n@app.post('/me', response_model=User)\r\ndef save_me(body: User):\r\n    ...\r\n```\r\n3ï¸âƒ£ Have api to return json like `{\"id\": \"5ed8b7eaccda20c1d4e95bb0\", \"name\": \"Joe\"}` (it's quite expected in the \"outer world\" to have `id` field for the document rather than `_id`. And it just looks nicer.)\r\n4ï¸âƒ£ Have Swagger and ReDoc documentation to display fields `id` (str), `name` (str)\r\n5ï¸âƒ£ Be able to save Pydantic documents into Mongo with proper `id` field substitution:\r\n```python\r\nuser = User(id=ObjectId(), name='Joe')\r\ninserted = db.user.insert_one(user) # This should insert document as `{\"_id\": user.id, \"name\": \"Joe\"}`\r\nassert inserted.inserted_id == user.id\r\n", "output": "Resolution:\nTo solve the problem, I would report the very convenient **pydantic-mongo** package:\r\nhttps://github.com/jefersondaniel/pydantic-mongo\r\n\r\nIt implements the management of `ObjectId` as described above, as well as abstractions to upsert, query, and delete entities in MongoDB collections.\r\n\r\n> From the project's readme:\r\n```python\r\nfrom pydantic import BaseModel\r\nfrom pydantic_mongo import AbstractRepository, ObjectIdField\r\nfrom pymongo import MongoClient\r\n\r\nclass Spam(BaseModel):\r\n    id: ObjectIdField = None\r\n    foo: Foo\r\n    bars: List[Bar]\r\n\r\n    class Config:\r\n        # The ObjectIdField creates an bson ObjectId value, so its necessary to setup the json encoding\r\n        json_encoders = {ObjectId: str}\r\n\r\nclass SpamRepository(AbstractRepository[Spam]):\r\n    class Meta:\r\n        collection_name = 'spams'\r\n\r\nclient = MongoClient(os.environ[\"MONGODB_URL\"])\r\ndatabase = client[os.environ[\"MONGODB_DATABASE\"]]\r\n\r\nspam = Spam(foo=Foo(count=1, size=1.0),bars=[Bar()])\r\n\r\nspam_repository = SpamRepository(database=database)\r\n\r\n# Insert / Update\r\nspam_repository.save(spam)\r\n\r\n# Delete\r\nspam_repository.delete(spam)\r\n\r\n# Find One By Id\r\nresult = spam_repository.find_one_by_id(spam.id)\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 33}
{"instruction": "How was this issue resolved: How to do flexibly use nested pydantic models for sqlalchemy ORM", "input": "### First check\r\n\r\n* [x ] I added a very descriptive title to this issue.\r\n* [ x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [ x] I searched the FastAPI documentation, with the integrated search.\r\n* [x ] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [ x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [ x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, HTTPException, Body, Request\r\nfrom sqlalchemy import create_engine, Boolean, Column, ForeignKey, Integer, String\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchem", "output": "Resolution:\nI used  __ init__ method in the BaseModel class to convert the nested Dictonary into an ORM  object. \r\n```\r\nclass Star(db.Model, BaseModelMixin):\r\n    id = db.Column(db.Integer, primary_key=True)\r\n    name = db.Column(db.String, nullable=False)\r\n    constellation_id = db.Column(db.Integer, db.ForeignKey('constellation.id'), nullable=False)\r\n\r\n    def __init__(self, name: str):\r\n        self.name = name\r\n\r\n\r\nclass Constellation(db.Model):\r\n    id = db.Column(db.Integer, primary_key=True)\r\n    name = db.Column(db.String, nullable=False)\r\n    abbr = db.Column(db.String, nullable=False)\r\n    right_ascension = db.Column(db.String, nullable=False)\r\n    stars = db.relationship('Star', backref='constellation', lazy=False, cascade='all, delete-orphan')\r\n\r\n    def __init__(self, name: str, abbr: str, right_ascension: str, stars=[]):\r\n        self.name = name\r\n        self.abbr = abbr\r\n        self.right_ascension = right_ascension\r\n        self.stars = [Star(**star) for star in stars]\r\n```", "source": "issue_closed", "type": "qa_resolution", "issue_number": 32}
{"instruction": "How was this issue resolved: No objects ever released by the GC, potential memory leak?", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\n# From the official documentation\r\n# Run with uvicorn main:app --reload\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"Hello World\"}\n```\n\n\n### Description\n\nUse the minimal example provided in the documentation, call the API 1M times. You will see that the memory usage piles up and up but never goes down. The GC can't free any objects. It's very noticeable once you have a real use case like a file upload that DoS'es your service.\r\n\r\n\r\n![memory-profile](https://user-images.githubusercontent.com/4538351/156794820-5bad7c00-6e02-4e27-bac3-ab488baa0df4.png)\r\n\r\nHere some examples from a real service in k8s via lens metrics:\r\n\r\n<img width=\"677\" alt=\"Screenshot 2022-03-04 at 16 47 18\" src=\"https://user-images.githubusercontent.com/4538351/156794991-abe94e21-57f4-4d96-a347-35a96e72c0d3.png\">\r\n\r\n<img width=\"681\" alt=\"Screenshot 2022-03-03 at 20 19 22\" src=\"https://user-images.githubusercontent.com/4538351/156795013-0a9792c3-8948-4d62-93af-31c41626f1eb.png\">\n\n### Operating System\n\nLinux, macOS\n\n### Operating System Details\n\n_No response_\n\n### FastAPI Version\n\n0.74.1\n\n### Python Version\n\nPy", "output": "Resolution:\nAlso, what version of Python are you running?", "source": "issue_closed", "type": "qa_resolution", "issue_number": 31}
{"instruction": "How was this issue resolved: Problems with await in async dependencies (when using dependencies and middleware simultaneously)", "input": "### First Check\n\n- [X] I added a very descriptive title to this issue.\n- [X] I used the GitHub search to find a similar issue and didn't find it.\n- [X] I searched the FastAPI documentation, with the integrated search.\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\n\n### Commit to Help\n\n- [X] I commit to help with one of those options ðŸ‘†\n\n### Example Code\n\n```python\nimport fastapi\r\nimport datetime as dt\r\nimport sqlalchemy as sa\r\n\r\nfrom sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession\r\nfrom sqlalchemy.ext.asyncio import create_async_engine\r\nfrom sqlalchemy.orm import sessionmaker\r\n\r\n\r\nclass _Conn:\r\n    radius_engine: AsyncEngine\r\n    radius_session_maker: sessionmaker\r\n\r\n\r\ndef init_pg_connections() -> None:\r\n    _Conn.radius_engine = create_async_engine(\r\n        'postgresql+asyncpg://postgres:password@host:port/db_name',\r\n        connect_args={\r\n            'server_settings': {\r\n                'application_name': 'test_app'\r\n            }\r\n        },\r\n        pool_size=2, max_overflow=10\r\n    )\r\n    _Conn.radius_session_maker = sessionmaker(\r\n        bind=_Conn.radius_engine,\r\n        autoflush=False, autocommit=False,\r\n        expire_on_commit=False,\r\n        class_=AsyncSession\r\n    )\r\n\r\n\r\nasync def get_db():\r\n    db: AsyncSession = _Conn.radius_session_maker()\r\n    try:\r\n        yield db\r\n    finally:\r\n        print('finally get_db. Before close')\r\n        await db.close()\r\n        print('finally get_db. After close')\r\n\r\n\r\ndef get_app():\r\n    app = fastapi.FastAPI(\r\n        on_startup=[init_", "output": "Resolution:\nIf I don't use Depends or any other middleware, do I risk explode database sessions?", "source": "issue_closed", "type": "qa_resolution", "issue_number": 30}
{"instruction": "How was this issue resolved: fastapi dev runs stuck", "input": "### Privileged issue\n\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\n\n### Issue Content\n\nThe first time I ran fastapi dev, there was no problem, but I encountered a code error. Then after I modified the code and saved it, a WARNING: WatchFiles detected changes in 'tool/index.py'. Reloading... then got stuck and could not exit.\r\n\r\n<img width=\"983\" alt=\"image\" src=\"https://github.com/tiangolo/fastapi/assets/29888469/f596a4fb-af29-4098-b489-3d9efee08f2c\">", "output": "Resolution:\nIt seems this was a question, it should have been started in GitHub Discussions, so I'll move it.\n\nIt seems this is not related to FastAPI or FastAPI CLI but Uvicorn, and maybe not even that but PyCharm, it should probably be asked there.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 29}
{"instruction": "How was this issue resolved: First-class session support in FastAPI", "input": "### Is your feature request related to a problem\r\n\r\nAll of the security schemas currently supported by FastAPI rely on some sort of \"client-server synergy\" , where, for instance, the client is expected to know and remember an OAuth token or the user credentials to be sent via headers. This works fairly well for single-page applications, but if you need to integrate authentication to an app that uses templates, keeping track of that authentication data becomes a challenge. Most applications would use server-side sessions to deal with this, but FastAPI doesn't really have a system to deal with sessions right now.\r\n\r\n### Describe alternatives you've considered\r\n\r\n#### Using Starlette's SessionMiddleware\r\n\r\nWhile Starlette's `SessionMiddleware` is mentionned a number of times in the FastAPI documentation, it does not integrate very well with the framework itself . What it does is that it adds a `request.session` dict on the `Request` object that lets the backend store and retreive information from it, and just before the response get sent, [that dict is serialized, combined to a timestamp, signed, converted into base 64 and appended as a cookie](https://github.com/encode/starlette/blob/b8bd1696492e501bd617bd151278999c68b30e2b/starlette/middleware/sessions.py#L52-L63). The client is then expected to send theat cookie back so that the server so that information can be decoded and used. This is what the Django doc describes as [the cookie-based approach](https://docs.djangoproject.com/en/2.2/topics/http/sessions/).\r\n\r\nThe problem with all this is that the entire process happens outside of what FastAPI can handle, and therefore does not appear in the generated OpenAPI documentation as an authentication schema.\r\n\r\nHaving read the source for that middleware and the documentation for itsdangerous, I also understand that this kind of \"session blob\" authentication method isn't really supported by OpenAPI, since all supported auth methods are expected to use constants to handle a", "output": "Resolution:\nThis is something that I've had here for a long time, but in the end, server-side sessions would depend on server-side storage, and FastAPI doesn't have any requirements or tight coupling with server side storage.\n\nI do think it would be useful to have documentation of how to handle server-side sessions stored somewhere (e.g. Redis or Postgres). I don't think there's a need for a package, just a bit of docs explaining how things are put together.\n\nIt could be a blog post, or at some point could end up in the \"How To\" section in FastAPI. But I don't think it would make sense to have first-class code in FastAPI exclussively for this. The same way, I think it could be a nice-to-have, but not something to keep tracking in the issues here.\n\nSo, I'll have it in mind, but for now I'll close this one.\n\n---\n\nHaving issues open for specific things is becoming problematic as they attract AI slop PRs, so I'm closing this for cleanup. â˜• ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 28}
{"instruction": "How was this issue resolved: ðŸ™ Find maintainers for FastAPI", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n\r\n### Description\r\n\r\nAt the moment, all contributions to the FastAPI are made with @tiangolo (directly or through a PR review).  \r\n\r\n@tiangolo is doing a great job ðŸ’ª, but fast developing project with great community like FastAPI demand much more time.  \r\n(It can be seen by the number of open issues and pull request)\r\n\r\n### Wanted Solution\r\n\r\nSuggestion is to __find several active community members__ and add them to the __repository maintainers__, as other projects (e.g. Flask and Django) do. ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦\r\n\r\nThis will help the development of the project and make the atmosphere for third-party contributors much more pleasant. ðŸ‘¾\r\n\r\nHope @tiangolo will consider this possibility\r\n\r\nupd: discussion on this #3970\r\n\r\n### Wanted Code\r\n\r\n```python\r\nfrom fastapi.community import active_members  \r\n\r\nactive_members.make_maintainers()\r\n```", "output": "Resolution:\nFinally , community effort paid off ! ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 27}
{"instruction": "How was this issue resolved: Websocket Routes Only Work on FastAPI, not APIRouter", "input": "**Describe the bug**\r\nWebsocket routes appear to only work on the main FastAPI object, not on APIRouter objects.  When the same function is copied from a FastAPI object to an APIRouter object instead of working properly it just throws a 403.\r\n\r\n**To Reproduce**\r\nSteps to reproduce the behavior:\r\n1. The following works as expected:\r\n```python\r\nfrom fastapi import FastAPI\r\napp = FastAPI()\r\n\r\n@app.websocket_route(\"/hello\")\r\nasync def hello(websocket):\r\n    await websocket.accept()\r\n    await websocket.send_text(\"Hello!\")\r\n    response = await websocket.receive_text()\r\n    print(response)\r\n    await websocket.close()\r\n    print(\"Closed\")\r\n```\r\n2. Moving `hello` to an APIRouter fails:\r\n```python\r\n# main.py\r\nfrom fastapi import FastAPI\r\nimport other\r\napp = FastAPI()\r\napp.include_router(other.router)\r\n```\r\n\r\n```python\r\n# other.py\r\nfrom fastapi import APIRouter\r\nrouter = APIRouter()\r\n\r\n@router.websocket_route(\"/routerhello\")\r\nasync def hello(websocket):\r\n    await websocket.accept()\r\n    await websocket.send_text(\"Router Hello!\")\r\n    response = await websocket.receive_text()\r\n    print(response)\r\n    await websocket.close()\r\n    print(\"Router Closed\")\r\n```\r\n**Expected behavior**\r\nI expect a websocket route to work on both a FastAPI and APIRouter object.\r\n\r\n**Screenshots**\r\nNot applicable.\r\n\r\n**Environment:**\r\n - OS: macOS 10.14.3\r\n - FastAPI Version: 0.9.0\r\n\r\n- Python version, get it with: 3.7.2\r\n\r\n**Additional context**\r\nTesting websocket client side with `websocat`.", "output": "Resolution:\nThis was solved years ago, if you encounter a similar issue, please open a discussion.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 26}
{"instruction": "How was this issue resolved: Very poor performance does not align with marketing", "input": "I wanted to check the temperature of this project and so I ran a quick, very simple, benchmark with `wrk` and the default example:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n```\r\n\r\nEverything default with wrk, regular Ubuntu Linux, Python 3.8.2, latest FastAPI as of now.\r\n\r\n> wrk http://localhost:8000\r\n\r\nUvicorn with logging disabled (obviously), as per the README:\r\n\r\n> python3 -m uvicorn fast:app --log-level critical\r\n\r\nI get very poor performance, way worse than Node.js and really, really far from Golang:\r\n\r\n```\r\nRunning 10s test @ http://localhost:8000\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency     1.83ms  365.59us   3.90ms   75.34%\r\n    Req/Sec     2.74k   116.21     2.98k    65.00%\r\n  54447 requests in 10.00s, 7.37MB read\r\nRequests/sec:   5442.89\r\nTransfer/sec:    754.78KB\r\n```\r\n\r\nThis machine can do 400k req/sec on one single thread using other software, so 5k is not at all fast. Even Node.js does 20-30k on this machine, so this does not align at all with the README:\r\n\r\n```\r\nThe key features are:\r\n\r\nFast: Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available.\r\n```\r\n\r\nWhere do you post benchmarks? How did you come to that conclusion? I cannot see you have posted any benchmarks at all?\r\n\r\nPlease fix marketing, it is not at all true.", "output": "Resolution:\nI saw people pointing out database tests. This is important because you will use DBs etc, but it isn't testing the WebFramework itself! It is comparing node.js pg vs python asyncpg or node.js json vs python json/orjson/ujson etc.\r\n\r\nFastAPI is not a server, so you can only measure the overhead over raw ASGI and measure the ASGI Server performance.\r\n\r\nFor measuring overhead, TechEmPower plaintext is actually a cool tool. so let's do it!\r\n\r\nFirst let's see how some frameworks with common (uvicorn and meinheld) servers in general, are compared.\r\n\r\n![image](https://user-images.githubusercontent.com/6379399/208662450-cb5918cf-b0f3-4728-b1d3-3ac472ed46c8.png)\r\n\r\nSo in raw throughput gunicorn+uvicorn is not doing great, and fastiapi using it will not be able to catch up with go frameworks like Gin or Fiber, or even with express and fastify node.js frameworks. Only socketify.py with PyPy pass the throughput of Fiber in this case. So I made an ASGI server (still in development) and WSGI server using socketify (aka uWS C++) as base.\r\n\r\n![image](https://user-images.githubusercontent.com/6379399/208651554-59313b34-7468-4d41-8c42-6daeb65531fc.png)\r\n\r\nSo testing ASGI servers and WebFrameworks, Emmett and Falcon using uvicorn are faster than FastAPI, and faster than node.js express, remember node.js express is really slow.\r\n\r\nUsing socketify ASGI FastAPI is able to catch up with Emmett and Falcon but If Emmett and Falcon uses socketify ASGI too, they will be faster of course. But still not at the same level of performance as Fastify in node.js for example.\r\n\r\nThe raw ASGI test of socketify with CPython is faster than Fastify but the overhead of WebFrameworks just put the performance down, but even raw-asgi in CPython is not able to catch up with Gin golang framework (with is not fast for golang standards)\r\n\r\nUsing the same server as the base you can see that Falcon has less overhead than Emmett and Emmett has less overhead than FastAPI.\r\n\r\nSocketify.py is not optimized for CPython yet but is optimized for PyPy, and you can see that using PyPy FastAPI, Emmett and Falcon passes Gin, but not even close to Fiber performance! That's because the ASGI server it self is slower than Fiber!\r\n\r\nSo the claim:\r\n> Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic).\r\n\r\nIs just nonsense, because FastAPI is not a Server, Uvicorn Server is slower than node.js express, fastify, gin, and fiber SERVERS! Socketify.py ASGI Server is faster than express, fastify, gin servers but slower than Fiber server.\r\n\r\nThe question must always be using X server with FastAPI overhead on top, can it be on par with NodeJS and Go?\r\nThe answer is Maybe because, uvicorn is slow compared to it, and socketify ASGI it's on pair with express, fastify, or gin, but it is not on pair with fasthttp, fiber or even with socketify.py itself without using ASGI!\r\n\r\nASGI just has a lot of overhead! and on top of it, FastAPI has a lot of overhead too!\r\n\r\nYou can claim that Falcon/Emmett is faster than FastAPI, and you can also claim that socketify.py is faster than some node.js servers and golang servers, but can not claim that FastAPI is faster than node.js or go because is comparing apples to oranges.\r\n\r\nCan FastAPI claim be fast? Yes! but need to be compared with WebFrameworks, not Servers! Can FastAPI claim to be the fastest Python WebFramework in all scenarios? No, because others WebFrameworks like Emmett and Falcon have less overhead.\r\n\r\nASGI WebFrameworks in general needs to reduce overhead, most of the overhead is dynamic allocations and the asyncio event loop itself, and it can be mitigated a LOT using Factories to reuse some Tasks/Futures and Request/Response objects in general instead of GC them every time, and using PyPy to be able to use stack allocations.\r\n\r\nRaw throughput is very important for any big application because most production codes should use in-memory caching for responses. That's why with socketify.py you can use sync route to check your in-memory cache and use `res.run_async(coro)` to go async only if you need to get the data itself. And that is why I will develop a Caching tool to not even touch Python or Python GIL and just send the response from C++ world when cached.\r\n\r\nYou can claim:\r\n> High Performance, faster than Express.js, Fastify.js Node.JS Frameworks, and Gin Golang Framework (thanks to Socketify.py and PyPy).\r\n\r\nIt's not \"on pair\" because it's faster with PyPy or slower with CPython.\r\n\r\nIf you want to see some WSGI numbers to compare overhead here is a chart:\r\n\r\n![image](https://user-images.githubusercontent.com/6379399/208656500-f7d0fd7e-2568-4f51-9583-2c46385104eb.png)\r\n\r\nWSGI has less overhead because it's not using asyncio and because is not doing a lot of unnecessary dynamic allocations, in fact, Socketify.py WSGI does more coping and work than ASGI because it uses ASGI native API and covert the headers before calling the app itself, most of the slowdown is asyncio event loop overhead.\r\n\r\nDjango is ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 25}
{"instruction": "How was this issue resolved: Can't read settings .env file", "input": "Not working for me...\r\n\r\n\r\n    db_url=\"postgres\" # .env file\r\n   \r\n    class Settings(BaseSettings):\r\n       db_url: str\r\n\r\n       class Config:\r\n          env_file = \".env\"\r\n\r\n\r\n     settings = Settings()\r\n\r\n  \r\n     @lru_cache()\r\n     def get_settings():\r\n       return {\r\n        \"db_url\": settings.db_url,\r\n     }\r\n\r\nGetting error -> **pydantic.error_wrappers.ValidationError: 1 validation error for Settings db_url field required (type=value_error.missing)**", "output": "Resolution:\nThanks [nikoBrajdic](https://github.com/nikoBrajdic)\r\n\r\n> What the docs don't state obviously enough is that you must declare the same fields in both the .env file AND the settings class!\r\n\r\nSeveral tutorials out there suggest that any items not specified in the env file will be read from the OS environment:\r\n>     # This is why you wonâ€™t see code like\r\n>     #    SECRET_KEY: str = os.getenv(\"SECRET_KEY\")\r\nbut don't bother to mention that waht you NEED to see is\r\n>     #    SECRET_KEY: str\r\n\r\n\r\nI still wish there was a \"debug\" mechanism to trace the initialization / .env processing stuff just to verify that it is working, since a badly named env_file doesn't throw any warnings...", "source": "issue_closed", "type": "qa_resolution", "issue_number": 24}
{"instruction": "How was this issue resolved: multipart/form-data: Unable to parse complex types in a request form", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it. -  _**See additional context**_\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nimport inspect\r\nfrom typing import Dict, Type\r\n\r\nfrom fastapi import Depends, FastAPI, File, Form\r\nfrom pydantic import BaseModel\r\n\r\napp = FastAPI()\r\n\r\n\r\ndef as_form(cls: Type[BaseModel]):\r\n    \"\"\"\r\n    Adds an as_form class method to decorated models. The as_form class method\r\n    can be used with FastAPI endpoints\r\n    \"\"\"\r\n    new_params = [\r\n        inspect.Parameter(\r\n            field.alias,\r\n            inspect.Parameter.POSITIONAL_ONLY,\r\n            default=(Form(field.default) if not field.required else Form(...)),\r\n            annotation=field.outer_type_,\r\n        )\r\n        for field in cls.__fields__.values()\r\n    ]\r\n\r\n    async def _as_form(**data)", "output": "Resolution:\n> @xueweiwujxw check your pydantic version is up to date. Works with pydantic version >=1.10.0\r\n\r\nIt works. Thank you.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 23}
{"instruction": "How was this issue resolved: Your upgrade of 113 broken all gradio apps - a fix needed ASAP this is devastating", "input": "a very basic just gradio having app\r\n\r\nfast api 111 fixes issue\r\n\r\nall of my followers now reporting errors and so hard to fix all\r\n\r\ni don't know how can you publish such a devastating bug having version please fix it ASAP\r\n\r\n\r\n```\r\n2024-09-06 00:12:20,515 - INFO - HTTP Request: GET https://api.gradio.app/gradio-messaging/en \"HTTP/1.1 200 OK\"\r\nRunning on local URL:  http://127.0.0.1:7860\r\n2024-09-06 00:12:20,542 - INFO - HTTP Request: GET http://127.0.0.1:7860/startup-events \"HTTP/1.1 200 OK\"\r\n2024-09-06 00:12:20,552 - INFO - HTTP Request: HEAD http://127.0.0.1:7860/ \"HTTP/1.1 200 OK\"\r\n\r\nTo create a public link, set `share=True` in `launch()`.\r\n2024-09-06 00:12:20,673 - INFO - HTTP Request: GET https://checkip.amazonaws.com/ \"HTTP/1.1 200 \"\r\n2024-09-06 00:12:21,337 - INFO - HTTP Request: GET https://api.gradio.app/pkg-version \"HTTP/1.1 200 OK\"\r\nERROR:    Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\pydantic\\type_adapter.py\", line 209, in __init__\r\n    core_schema = _getattr_no_parents(type, '__pydantic_core_schema__')\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\pydantic\\type_adapter.py\", line 98, in _getattr_no_parents\r\n    raise AttributeError(attribute)\r\nAttributeError: __pydantic_core_schema__\r\n\r\nDuring handling of the above exception, another exception occurred:\r\n\r\nTraceback (most recent call last):\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\uvicorn\\protocols\\http\\h11_impl.py\", line 406, in run_asgi\r\n    result = await app(  # type: ignore[func-returns-value]\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\uvicorn\\middleware\\proxy_headers.py\", line 70, in __call__\r\n    return await self.app(scope, receive, send)\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\fastapi\\applications.py\", line 1054, in __call__\r\n    await super().__call__(scope, receive, send)\r\n  File \"R:\\Image_Caption_Editor_v6\\venv\\lib\\site-packages\\starlette\\applic", "output": "Resolution:\nAssuming the original need was handled, this will be automatically closed now. But feel free to add more comments or create new issues or PRs.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 22}
{"instruction": "How was this issue resolved: Are there plans to make class-based-views a first-class feature?", "input": "**Description**\r\n\r\nHi @tiangolo! First off kudos on FastAPI, beautiful stuff. My team (about a dozen backenders, pinging one here @gvbgduh) are in the midst of porting out Py2 services to Py3 and thought it'd be a good time to move away from Flask and Flask-RESTful and into something that makes better use of the Py3 features (predominantly async). Thus far FastAPI/Starlette is the top contender but the one feature we're missing the most is class-based-views (CBVs) as opposed to the defacto function-based-views (FBVs). Thus we were wondering if there's any plans to introduce CBVs as a first-class feature in FastAPI.\r\n\r\nWhile we know Starlette plays well with CBVs we looove the automagical features FastAPI offers like validation, OpenAPI generation, etc, things we had to do in very round-about ways prior.\r\n\r\nWay we see it CBVs have the following primary perks:\r\n- Centralised routing since you tend to declare the different routes in one place, typically after instantiating the application.\r\n- Code reusability since you can easily do OOP and inherit (eg through mixins) or compose common functionality around.\r\n- Would make it much easier to port existing CBVs to FastAPI since we'd be coming from Flask-RESTful.\r\n\r\nThus far we've found we can 'hack' CBVs into FastAPI as such:\r\n\r\n```\r\nfrom typing import Dict\r\n\r\nimport fastapi\r\nfrom starlette.endpoints import HTTPEndpoint\r\n\r\nfrom app.services.api.models import Something\r\n\r\n\r\napp = fastapi.FastAPI(debug=True)\r\n\r\n\r\nclass ResourceRoot(HTTPEndpoint):\r\n    def get(self):\r\n        # do stuff\r\n\r\n\r\nclass ResourceSomething(HTTPEndpoint):\r\n\r\n    def get(self, some_id: str) -> Dict:\r\n        # do stuff\r\n\r\n    def post(self, something: Something) -> None:\r\n        # do stuff\r\n\r\n\r\nresource_root = ResourceRoot(scope={\"type\": \"http\"})\r\nresource_something = ResourceSomething(scope={\"type\": \"http\"})\r\napp.add_api_route(\r\n    path=\"/\",\r\n    endpoint=resource_root.get,\r\n    methods=[\"GET\"],\r\n)\r\napp.add_api_route(\r\n    path=\"/something\",\r\n    en", "output": "Resolution:\n@tiangolo thank you for your FastAPI and I've been using it for more than an year now but I cannot disagree with the fact that using Starlette from the same creator of Django Rest Framework and seeing tools like Flask with class based view, I still struggle to understand why FastAPI does not natively support it, at all, this pushes a lot of people off and let me just try to give you a few simple examples why.\r\n\r\n1. Class based views apply the OOP principle, even if some people don't like it, it's the most used paradigm.\r\n2. You don't need to repeat logic across the rest of the views. DRY principle is good and if we need to repeat our code over and over again, it becomes ugly, hard to maintain and maybe creates a lot of tech debt.\r\n3. Arguing that \"what can you do in CBV that you can't in function based views\" I would say to read point 1 and 2.\r\n4. FastAPI was pointed as a tool that could bring the best of django and the best of flask in one. Here I have mixed feelings because even Flask allows both CBS and function based views as well as django.\r\n\r\nIt would be amazing to have something CBS native for FastAPI as well. This would allow us to baiscally do the moves from monoliths and flask into full FastAPI and I'm 100% sure that I'm not the only one thinking like this :). Again, fantastic framework.\r\n\r\nStarlette already supports HTTPEndpoint (https://www.starlette.io/endpoints/) so I think this could be something that could be added to FastAPI.\r\n\r\nI can't convince my company to fully adopt it (neither the companies I worked before) because this simple feature is a killer if cannot be there.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 21}
{"instruction": "How was this issue resolved: Context managers in `Depends` are broken after 0.106", "input": "### Discussed in https://github.com/tiangolo/fastapi/discussions/11107\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **FeeeeK** February  7, 2024</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, Request\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Session:\r\n    def __init__(self):\r\n        print(\"creating session\")\r\n\r\n    async def __aenter__(self):\r\n        print(\"opening session\")\r\n        return self\r\n\r\n    async def __aexit__(self, exc_type, exc, tb):\r\n        print(\"closing session\")\r\n\r\n    async def commit(self):\r\n        print(\"committing session\")\r\n\r\n    async def rollback(self):\r\n        print(\"rolling back session\")\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def commit_session(request: Request, call_next):\r\n    # minimalistic middleware for example, my code uses ASGI middleware\r\n    response = await call_next(request)\r\n    db_session = request.scope.get(\"db_session\")\r\n    if not db_session:\r\n        return response\r\n\r\n    if response.status_code // 200 != 1:\r\n        await db_session.rollback()\r\n    else:\r\n        await db_session.commit()\r\n\r\n    return response\r\n\r\n\r\nasync def get_db_session(request: Request):\r\n    async with Ses", "output": "Resolution:\nFastAPI 0.118.0 was just released with the fix in https://github.com/fastapi/fastapi/pull/14099. ðŸ› ðŸš€ ðŸŽ‰ ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 20}
{"instruction": "How was this issue resolved: Using pydantic models for GET request query params? Currently not possible, have to use dataclasses or normal classes.", "input": "**Description**\r\n\r\nIs there a way to use pydantic models for GET requests? I would like to have a similar interface for both query params and for the body. So for instance, an example could look like this:\r\n\r\n```\r\nclass PingArgs(BaseModel):\r\n    \"\"\"Model input for PingArgs.\"\"\"\r\n\r\n    dt: datetime.datetime = ...\r\n    to_sum: List[int] = ...\r\n\r\n    @validator(\"dt\", pre=False, always=True, whole=True)\r\n    def validate_dt(cls, v, values):\r\n        \"\"\"Validate dt.\"\"\"\r\n        parsed_dt = v.replace(tzinfo=None)\r\n        return parsed_dt\r\n\r\n@router.get(\"/ping\", tags=[\"basic\"])\r\ndef ping(args: PingArgs, request: Request):\r\n    \"\"\"Example.\"\"\"\r\n    return JSONResponse(\r\n        status_code=starlette.status.HTTP_200_OK,\r\n        content={\"detail\": \"pong\", \"dt\": args.dt.isoformat() \"summed\": sum(x for x in args.to_sum)},\r\n    )\r\n```\r\n\r\nWhere as, right now I think you would have to do something like this:\r\n\r\n```\r\n@router.get(\"/ping\", tags=[\"basic\"])\r\ndef ping(dt: datetime.datetime = Query(None), to_sum: List[int] = Query(None), request: Request):\r\n    \"\"\"Example.\"\"\"\r\n    parsed_dt = dt.replace(tzinfo=None)\r\n    \r\n    return JSONResponse(\r\n        status_code=starlette.status.HTTP_200_OK,\r\n        content={\"detail\": \"pong\", \"dt\": dt.isoformat() \"summed\": sum(x for x in to_sum)},\r\n    )\r\n```\r\n\r\nHope this can be clarified.", "output": "Resolution:\nSort of, with my method above FastAPI, will first perform pydantic validation on the types e.g. in my example it will ensure `video` is a string and `project` is `ProjectType`, it won't call any of the `@validator` methods.\r\nIf there are no failures at that stage then the `QueryModel` kicks in and performs full validation of the model, e.g. running the `@validator` method for `video`.\r\nThe `QueryModel` I demonstrated above will only return the first error, you could modify it to return multiple. Just make sure the initial type checking FastAPI does won't fail and you should be golden.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 19}
{"instruction": "How was this issue resolved: BrokenResourceError", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [x] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\napp.py\r\n```python\r\nimport time\r\nimport uvicorn\r\nfrom fastapi import FastAPI, Request\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.middleware(\"http\")\r\nasync def middleware(request: Request, call_next):\r\n    return await call_next(request)\r\n\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    time.sleep(4)\r\n    return {\"Hello\": \"World\"}\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(app=\"app:app\", port=8000)\r\n```\r\nscript.py\r\n```python\r\nimport requests as requests\r\n\r\nr = requests.get(f\"http://127.0.0.1:8000\", timeout=2)\r\n```\r\n\r\n### Description\r\nIf you trigger script.py, error will appear.\r\nAfter upgrade fastapi to 0.70.0 In some requests in our application its apearing this error.  So what we can do? What is problem?\r\n```\r\nERROR:    Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"venv/lib/python3.8/site-packages/uvicorn/protocols/http/httptools_impl.py\", line 398, in run_asgi\r\n    result = await app(self.scope, self.receive, self.send)\r\n  File \"venv/lib/python3.8/site-packages/uvicorn/middleware/proxy_headers.py\", line 45, in __call__\r\n    return await self.app(scope, receive, send)\r\n", "output": "Resolution:\nDo you use `BaseHTTPMiddleware` somewhere in your code? Either directly like:\r\n```python\r\nclass CustomMiddleware(BaseHTTPMiddleware:\r\n    pass\r\n```\r\n or indirectly like:\r\n```python\r\n@app.middleware('http')\r\ndef middlewarefunc():\r\n    pass\r\n```\r\n\r\nI found that most people above are experiencing this with that particular middleware, which actually uses MemoryStream of anyio. ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 18}
{"instruction": "How was this issue resolved: Dependency Injection - Singleton?", "input": "**Don't you think the dependency injection framework needs a singleton type?**\r\n\r\nI checked the documentation and as I can see there is no option for creating a class as a singleton. If I want to pass in a class as a dependency it will be created every time. So a feature to create singleton and if that already exists just pass it in as a dependency would be great. Because if you create a huge dependency tree than you have to specify one-by-one to make singletons. \r\n\r\nMaybe I missed something how to do that but if not that could be a new feature.", "output": "Resolution:\nto be not dependent on the request object, wouldn't something like this be a suitable solution (not tested yet):\r\n\r\n```\r\nclass Dependency01:\r\n  pass\r\n\r\n\r\nclass Dependency02:\r\n  pass\r\n```\r\n\r\nThe ServiceProvider is just a wrapper class to provide access to all dependencies.\r\nThey are stored in class variables to eliminate the need for instantiating the Provider more than once.\r\n\r\n```\r\nclass ServiceProvider:\r\n    dependency_01: Dependency01\r\n    dependency_02: Dependency02\r\n\r\n    def __init__(self):\r\n        cls = self.__class__\r\n\r\n        cls.dependency_01 = Dependency01()\r\n        cls.dependency_02 = Dependency02()\r\n\r\n    @classmethod\r\n    def get_dependency_01(cls):\r\n        return cls.dependency_01\r\n\r\n    def shutdown(self):\r\n        pass\r\n```\r\n\r\nNow we instantiate the Provider once on app startup. After this, our dependencies are available via the class methods of the ServiceProvider Class\r\n\r\n```\r\n# start dependencies in the startup event\r\n@app.on_event(\"startup\")\r\ndef startup():\r\n    app.state.service_provider = ServiceProvider()\r\n\r\n# cleanup when shutting down\r\n@app.on_event(\"shutdown\")\r\ndef shutdown():\r\n    app.state.service_provider.shutdown()\r\n\r\n@app.get(\"/\")\r\nasync def hello(dependecy_01: Dependency01 = Depends(ServiceProvider.get_dependency_01)):\r\n    pass\r\n```\r\n\r\nThe nice thing about this would be, after the app started, the dependency injection via Depends would also work outside of route methods as it is not dependent on the request object.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 17}
{"instruction": "How was this issue resolved: Use of socket.io", "input": "**Description**\r\n\r\nHow can I use socket.io instead of the plain websocket integration? I guess this is more a question belonging to starlette.\r\n\r\nCurrently migrating from a flask application using flask-socketio / python-socketio\r\n\r\nAny hint is appreciated. Thx.", "output": "Resolution:\nHello @jonra1993 thanks for your help! I got it woking now :)\r\n\r\n...but I also got another error and if anyone gets the same error, here is my solution / hint:\r\n\r\n---\r\n\r\n### Error message:\r\n\r\n```log\r\nERROR:    Exception in ASGI application\r\nTraceback (most recent call last):\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/uvicorn/protocols/websockets/websockets_impl.py\", line 184, in run_asgi\r\n    result = await self.app(self.scope, self.asgi_receive, self.asgi_send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/uvicorn/middleware/proxy_headers.py\", line 75, in __call__\r\n    return await self.app(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/fastapi/applications.py\", line 261, in __call__\r\n    await super().__call__(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/starlette/applications.py\", line 112, in __call__\r\n    await self.middleware_stack(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/starlette/middleware/errors.py\", line 146, in __call__\r\n    await self.app(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/starlette/exceptions.py\", line 58, in __call__\r\n    await self.app(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/fastapi/middleware/asyncexitstack.py\", line 21, in __call__\r\n    raise e\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/fastapi/middleware/asyncexitstack.py\", line 18, in __call__\r\n    await self.app(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/starlette/routing.py\", line 656, in __call__\r\n    await route.handle(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/starlette/routing.py\", line 408, in handle\r\n    await self.app(scope, receive, send)\r\n  File \"/workspaces/ifmDataLogger/.venv/lib/python3.9/site-packages/starlette/staticfiles.py\", line 86, in __call__\r\n    assert scope[\"type\"] == \"http\"\r\nAssertionError\r\nINFO:     connection open\r\nINFO:     connection closed\r\n```\r\n\r\nWith loguru i can see `scope[\"type\"]` is `websocket`\r\n```log\r\n    assert scope[\"type\"] == \"http\"\r\n           â”” {'type': 'websocket', 'asgi': {'version': '3.0', 'spec_version': '2.3'}, 'http_version': '1.1', 'scheme': 'ws', 'server': ('1...\r\n```\r\n\r\n### Solution:\r\nI also have to change the order of my route mounts:\r\n**Befor:**\r\n```python\r\n  # Main router for the API.\r\n  app.include_router(router=api_router, prefix=\"/api\")\r\n  \r\n  # add static files\r\n  app.mount(\"/static\", StaticFiles(directory=\"/static\"), name=\"static\")\r\n  app.mount(\"/\", StaticFiles(directory=\"/pages\"), name=\"pages\")\r\n  \r\n  # add websocket\r\n  app.mount(\"/ws\", asgi, name=\"socket\")\r\n```\r\n**After:**\r\n```python\r\n  # Main router for the API.\r\n  app.include_router(router=api_router, prefix=\"/api\")\r\n\r\n  # add websocket\r\n  app.mount(\"/ws\", asgi, name=\"socket\")\r\n  \r\n  # add static files\r\n  app.mount(\"/static\", StaticFiles(directory=\"/static\"), name=\"static\")\r\n  app.mount(\"/\", StaticFiles(directory=\"/pages\"), name=\"pages\")\r\n```\r\n\r\nRef: https://github.com/encode/starlette/issues/1548 and https://www.starlette.io/routing/#route-priority", "source": "issue_closed", "type": "qa_resolution", "issue_number": 16}
{"instruction": "How was this issue resolved: using external oAuth providers", "input": "Hi,\r\n\r\nFirst of all, thank you for all the amazing work you've done with FastAPI. I'm just scratching the surface and I'm already amazed by what you're able to do right out of the box.\r\n\r\nAs for my question, At my institute we use a centralized authentication service for all webapps base on [ORY Hydra](https://github.com/ory/hydra). Is there an easy way built in to integrate an external server to authenticate again and use the token query the API?\r\n\r\nThanks\r\nM", "output": "Resolution:\nHere is my workaround:\r\n\r\n1. Make endpoints for every social login providers (`/login/twitter`, `/login/google`, ...). In these endpoints, use [Authlib](https://github.com/lepture/authlib) to get access token from those social login providers. Authlib handles all OAuth client stuff (redirection, OAuth xxx flow work, ...).\r\n2. Make endpoints (`/auth/twitter`, `/auth/google` ) for receiving access token from Twitter / Google.\r\n3. After getting an access code, redirect the user to FastAPI OAuth endpoint (`/auth`), and issue our JWT to the user. The FastAPI OAuth endpoint is what we defined in a `fastapi.security.OAuth2` class instance. This makes OpenAPI auth working.\r\n4. Users (browser) don't access Twitter / Google API directly. Users access FastAPI API only. FastAPI accesses Twitter / Google API.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 15}
{"instruction": "How was this issue resolved: Passing UploadFile objects into a StreamingResponse closes it in v0.106.0 but not v0.105.0", "input": "### Discussed in https://github.com/tiangolo/fastapi/discussions/10856\r\n\r\n<div type='discussions-op-text'>\r\n\r\n<sup>Originally posted by **adrwz** December 28, 2023</sup>\r\n### First Check\r\n\r\n- [X] I added a very descriptive title here.\r\n- [X] I used the GitHub search to find a similar question and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/pydantic/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nasync def upload_file_event(files: List[UploadFile]):\r\n    print(\"2\", files[0].filename, files[0].file._file.closed)\r\n\r\n    # ... more code ...\r\n\r\n\r\n@router.post(\"/upload_session_file\")\r\nasync def upload_file(files: List[UploadFile] = File(...)):\r\n    print(\"1\", files[0].filename, files[0].file._file.closed)\r\n\r\n    try:\r\n        return StreamingResponse(\r\n            upload_file_event(files),\r\n            media_type=\"text/event-stream\",\r\n        )\r\n    except Exception as error:\r\n        logging.error(error)\r\n        raise HTTPException(status_code=500, detail=\"Internal Server Error\")\r\n```\r\n\r\n\r\n### Description\r\n\r\nHitting this endpoint with an uploaded file on v0.105.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename false\r\n```\r\n\r\nHitting this endpoint with an uploaded file on v0.106.0 will print:\r\n\r\n```\r\n1 filename false\r\n2 filename true\r\n```\r\n\r\nUnfortunately this means I'm unable to upload files in a StreamingResponse with fastapi>=0.106.0\r\n\r\n### Operating System\r", "output": "Resolution:\nThanks @msehnout your workaround really helped me out! +1 to getting an official fix for this, I spent way too long trying to figure out why the file-like object wasn't working properly.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 14}
{"instruction": "How was this issue resolved: Provide timing data for things FastAPI does outside of user code", "input": "**Is your feature request related to a problem? Please describe.**\r\nI currently find myself using FastAPI as an API frontend for a database running queries of varying levels of complexity that usually return fairly large quantities of data. The problem I have is that, when attempting to figure out why an API request is taking time to respond, there's a lot going on outside of what fencing the code inside your route with the usual `time_start = time.time()`, `time_delta = time.time() - time_start` won't tell you.\r\n\r\nIn your average FastAPI application, there's 4 main causes for slowdowns:\r\n* Endpoint code running (app)\r\n* Waiting for the database (io)\r\n* Data validation (pydantic)\r\n* Data serialization (json/ujson)\r\n\r\nOf those 4, only the first two are actually part of the user code, the other two are handled behind the scenes by FastAPI. If I'm testing a route that's returning 50MBs of JSON (for whatever reason), it's actually rather tricky to determine whether switching from `json` to `ujson` or `orjson` will have any performance benefit or if the slowdown is coming from Pydantic choking on the sheer amount of data being fed to it or the database being slow.\r\n\r\n**Describe the solution you'd like**\r\nGiven FastAPI is performing operations outside of what the user can observe or measure, it should probably expose timing data for those things in some way (especially validation and serialization, since I doubt routing is going to factor a lot in the processing time). I don't know how the implementation should go, though, given any middleware is only going to receive a Starlette `Response` object and FastAPI probably shouldn't be doing this sort of thing automatically anymore than it does with CORS. The `Response` object could probably be extended in some way to contain some sort of `timing` dict, though that's sure to cause all sorts of compatibility issues, so I don't know whether that can be done without some upstream work with Starlette.\r\n\r\n**Describe alternatives yo", "output": "Resolution:\n> I tried @sm-Fifteen 's implementation from [the comment there](https://github.com/florimondmanca/awesome-asgi/issues/17#issuecomment-571651344) and I got stats in the developer tools in the browser. That's awesome! ðŸš€\r\n\r\nThanks! ðŸ˜„ I'm a bit impressed myself at how well this all turned out.\r\n\r\n> I think that deserves existing as a published ASGI middleware package.\r\n> \r\n> Maybe @sm-Fifteen could publish it, or dmontagu could include it in `fastapi-utils`?\r\n> \r\n> Also, trying it locally I had to change the line:\r\n> \r\n> ```python\r\n> response['headers'].append([\"server-timing\", b','.join(server_timing)])\r\n> ```\r\n> \r\n> to\r\n> \r\n> ```python\r\n> response['headers'].append([b\"server-timing\", b','.join(server_timing)])\r\n> ```\r\n> \r\n> (`b\"server-timing\"` as `bytes`).\r\n\r\nYeah, I probably missed a few things here or there. Like I said in that other post, this was more meant as a WIP proof-of-concept, and I was worried about a few remaining yappi issues (namely: [\"How should the profiler free memory?\"](https://github.com/sumerc/yappi/issues/42), [\"What's a reliable way to tell yappi to profile a specific function?\"](https://github.com/sumerc/yappi/issues/41)) ([also raised by dmontagu](https://github.com/sumerc/yappi/issues/38)) causing problems so I haven't touched it much since. I can probably just polish up what's there, add a memory threshold where the middleware just wipes the profiler memory so it doesn't inflate until Python goes OOM, add a README listing the caveats and publish it.\r\n\r\n> @sm-Fifteen about timing the endpoint alone, I see the value in this and in being able to time just the endpoint duration. Would you like to send a PR putting that in a separate function?\r\n\r\nWell,, if you're open to it, then I might as well. It's certainly going to be easier than the crazy solution I was considering, where I somehow time `get_request_handler.<locals>.app` and substract the duration of everything else.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 13}
{"instruction": "How was this issue resolved: ApiKey Header documentation", "input": "Hi,\r\n\r\nDo you have some documentation or example regarding configuration for ApiKey (header) and how to verify it on FastAPI ?\r\n\r\nthanks in advance,\r\n\r\nRÃ©my.", "output": "Resolution:\n> If no one has a good idea\n\nI think the last snippet is straightforward and minimalist, and should be the doc example (some variables may be renamed). For reference, note @OverkillGuy did write a doc [still accessible here](https://web.archive.org/web/20220630152316/https://629517f1bb68e70ec44b79ec--fastapi.netlify.app/advanced/security/api-key/) in his PR which, obviously, didn't make it.\n\nIt wasn't perfect (again, use of `Security` with no reason instead of `Depends`, `403` instead of `401`, and [some other concerns](https://github.com/fastapi/fastapi/pull/4818#issuecomment-1321089199)), but interestingly, it was also mentioning `APIKeyCookie` and `APIKeyQuery` possibilities.\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 12}
{"instruction": "How was this issue resolved: Korean translations", "input": "### ðŸ‡°ðŸ‡· Korean translations (ko)\r\n\r\nI hope to translate the whole docs into Korean.  \r\nThis issue is opened to track the progress of Korean language translation.\r\n\r\nAny suggestion is welcome, and I will appreciate it. ðŸ˜ƒ \r\n\r\n### ðŸ“š Glossary\r\nUse [python official Korean glossary](https://docs.python.org/ko/3/glossary.html) for maintaining consistency.\r\n\r\nIf you can't find a proper word in the glossary, you can find it from https://www.flowdas.com/pages/python-docs-ko.html python Korean document maintainer, @flowdas, maintains.\r\n\r\nAlso, use less English as you can. For instance, at [ì²«ê±¸ìŒ](https://fastapi.tiangolo.com/ko/tutorial/first-steps/#_7)\r\n\r\n- PUT : ë°ì´í„°ë¥¼ ~ì—…ë°ì´íŠ¸~ìˆ˜ì •í•˜ê¸° ìœ„í•´\r\n\r\nSee https://github.com/tiangolo/fastapi/discussions/3167#discussioncomment-1502428 (Thanks, @0417taehyun)\r\n\r\n### âœðŸ» Writing style (2020-11-07 added)\r\në¹„ê²©ì‹ì²´(Informal)ì¸ í•´ìš”ì²´ë¥¼ ì§€ì–‘í•˜ê³  ê²©ì‹ì²´(Formal)ì¸ í•©ì‡¼ì²´ë¥¼ ì§€í–¥í•©ë‹ˆë‹¤.\r\n\r\ne.g.\r\n- ~ì´ì—ìš” (NOT Recommended)\r\n- ~ìž…ë‹ˆë‹¤.\r\n\r\n### ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Discussion (2021-05-04 added)\r\nI opened a discussion, https://github.com/tiangolo/fastapi/discussions/3167.\r\nIf you have a suggestion or an idea, please comment on it the discussion.\r\n\r\nOR\r\n\r\nYou can join [FastAPI Discord](https://discord.gg/VQjSZaeJmf) and talk to in `Korean` channel!\r\n\r\n### ðŸŽ PR Guide\r\nSee https://fastapi.tiangolo.com/contributing/#translations, please.\r\n\r\nYou don't have to get any permission. FastAPI is an open-source project.\r\nAnd I'm not an owner, just a contributor like anyone else.\r\nIf you want to contribute, do it right now!", "output": "Resolution:\nGood news everyone! ðŸ˜‰ There's a new translation PR to be reviewed: #5605 ðŸŽ‰", "source": "issue_closed", "type": "qa_resolution", "issue_number": 11}
{"instruction": "How was this issue resolved: Gunicorn Workers Hangs And Consumes Memory Forever", "input": "**Describe the bug**\r\nI have deployed FastAPI which queries the database and returns the results. I made sure closing the DB connection and all. I'm running gunicorn with this line ;\r\n`gunicorn -w 8 -k uvicorn.workers.UvicornH11Worker -b 0.0.0.0 app:app --timeout 10`\r\nSo after exposing it to the web, I run a load test which makes 30-40 requests in parallel to the fastapi. And the problem starts here. I'm watching the 'HTOP' in the mean time and I see that RAM usage is always growing, seems like no task is killed after completing it's job. Then I checked the Task numbers, same goes for it too, seems like gunicorn workers do not get killed. After some time RAM usage gets at it's maximum, and starts to throw errors. So I killed the gunicorn app but the thing is processes spawned by main gunicorn proces did not get killed and still using all the memory. \r\n\r\n**Environment:**\r\n - OS:  Ubuntu 18.04\r\n - FastAPI Version : 0.38.1\r\n\r\n- Python version : 3.7.4", "output": "Resolution:\nHi all \r\n\r\nIn My flask restful web application I tried setting the max_requests option in gunicorn config file as 500 requests. so after every 500 requests the worker will reboot, this helped me reducing some amount of memory but still I face the increasing memory issue ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 10}
{"instruction": "How was this issue resolved: French translations", "input": "# Bonjour ðŸ‡«ðŸ‡·\r\n\r\nWelcome to the issue that coordinates the French translation effort.\r\n\r\n## Purpose \r\n\r\n- Avoiding several people working on the same document at the same time. \r\n\r\nThe first person who declares that he/she is working on a translation gets the responsibility to carry it out. If a PR seems to be stalled, we can discuss a transfer of responsibility here.\r\n\r\n- Enforcing best practices\r\n\r\nBest practices are listed later in this description. You can propose your practice at any time, ideally with a supporting source and an example. \r\n\r\nDefining and sharing best practices will help to avoid common mistakes and will allow faster and easier reviews.\r\n\r\n- Help and build the community\r\n\r\nDo not hesitate to ask any questions regarding the french translation effort here. The stronger the community, the more effective we will be and the more we will enjoy. \r\n\r\n- Provide a french translation for this awesome library (last but not least)\r\n\r\nIf you are here, you probably like **FastAPI**, and maybe you even speak French. Giving more people the opportunity to get started using the documentation in its native language will encourage adoption. In that spirit, let's contribute to the magic of open source in this way.\r\n\r\n## How to contribute\r\n\r\n### Review \r\n\r\nKeep in mind that the easiest way to participate is to review the PRs. We need to avoid accumulating PRs waiting for review.\r\n\r\n### Translate\r\n\r\nIf you are not familiar with contributing to open source projects have a look at https://github.com/firstcontributions/first-contributions.\r\n\r\nIn any case, take a look at the documentation section related to the [contribution](https://fastapi.tiangolo.com/contributing/#development-contributing) and more precisely the part about the [documentation](https://fastapi.tiangolo.com/contributing/#docs).\r\n\r\nOnce you are decided to translate a document, make yourself known here by leaving a message here (eg. https://github.com/tiangolo/fastapi/issues/1972#issuecomment-702956335).\r\n\r\n", "output": "Resolution:\nHi @axel584, thanks for contributing! ðŸ‘\r\n\r\nTo have an idea of how to contribute the best would be to review open PRs.\r\nYou will see what files to update and what terms we usually use.\r\n\r\nIf you have suggestions, leave a comment the PR author is responsible for accepting them.\r\n\r\nTo approve a PR, go to the 'Files changed tab', then click on 'review changes' green button, and select 'approve' before submitting your review.\r\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 8}
{"instruction": "How was this issue resolved: Japanese Translation", "input": "### Tracking Japanese Translation\r\nWe can use this Issue to track the progress of the Japanese language translations.:sunglasses:\r\n\r\nPlease post here what page you plan on translating so we can coordinate. ðŸš€\r\n\r\n### Tips\r\n- If the term is a technical term, leave in English and add an explanation of the meaning of the word in Japanese.\r\n- Please unify translations as follows:\r\n\r\nen | ja | Note\r\n-- | -- | --\r\n!!! note | !!! note \"å‚™è€ƒ\" | \r\n!!! info | !!! info \"æƒ…å ±\" | \r\n!!! tip | !!! tip \"è±†çŸ¥è­˜\" | \r\n!!! check | !!! check \"ç¢ºèª\" | \r\npath operation | Â  | Â \r\nvalidation | Â  | Â \r\ncompletion | Â  | Â \r\nautomatic documentation", "output": "Resolution:\nadvanced/response-directly.md at PR #2191 [needing review] ðŸš€ ", "source": "issue_closed", "type": "qa_resolution", "issue_number": 7}
{"instruction": "How was this issue resolved: msgpack response if client asks for application/x-msgpack", "input": "hi,\r\nwe are in the process of evaling fastapi for a large app migration from flask. Quick question on a very interesting and useful piece of functionality. \r\nThis builds upon the validations you have created for encoding json data and will be very useful for us out-of-the-box.\r\n\r\nhttps://msgpack.org/index.html is an enhancement to json which is highly compressed. There are some benchmarks that show it is as fast as protocol buffers...while making it a drop-in alternative to json. \r\n\r\nmsgpack is very important for Asia which are highly internet bandwidth constrained. We are prepared to tradeoff speed in exchange for lesser bandwidth (e.g. http://indiegamr.com/cut-your-data-exchange-traffic-by-up-to-50-with-one-line-of-code-msgpack-vs-json/ )\r\n\r\nTo be fair, it may be same size as gzipped json responses...but after having done android app deployments over a million devices in the field in asia, we realized that one has to write custom compression/decompression for gzipped json response handling. However msgpack has fairly well supported libraries. \r\n\r\nmsgpack is fairly production ready. Lots of downstream python libraries use it in production - https://github.com/0rpc/zerorpc-python\r\n\r\nThis enhancement request is for fastapi to respond in msgpack if the requesting client ask for the mimetype `application/x-msgpack`. The default behavior continues to be the same as currently.\r\n\r\nThere is no impact to any client of a fastapi deployment unless they specifically ask for msgpack (in which case, they will get better performance).\r\n\r\nI'm also pasting some criticisms of msgpack and comparisons with competing/derived json formats like CBOR\r\n\r\n- https://news.ycombinator.com/item?id=14067747\r\n- http://zderadicka.eu/comparison-of-json-like-serializations-json-vs-ubjson-vs-messagepack-vs-cbor/\r\n- https://techtutorialsx.com/2019/06/20/esp32-arduinojson-messagepack-serialization/\r\n- https://gist.github.com/frsyuki/2908191\r\n- https://prataprc.github.io/msgpack-vs-cbor.html", "output": "Resolution:\nBrilliant.\n\nThank you so much !\n\nOn Fri, 27 Mar, 2020, 02:10 Florimond Manca, <notifications@github.com>\nwrote:\n\n> @sandys <https://github.com/sandys> Just issued 1.0 for msgpack-asgi, and\n> now the first code snippet there shows usage that's compatible with\n> FastAPI. ;-)\n>\n> app.add_middleware(MessagePackMiddleware)\n>\n> Figured it wasn't that big of a step given the notice and that the rest of\n> the docs use plain ASGIâ€¦\n>\n> â€”\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/521#issuecomment-604673463>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAASYU642JW7R5NITHO7BYDRJO4T3ANCNFSM4IVUIA7A>\n> .\n>\n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 6}
{"instruction": "How was this issue resolved: ðŸ‡§ðŸ‡·Portuguese translations", "input": "## Portuguese translation tracking  <span>&#x1f1e7;&#x1f1f7;</span>\r\n\r\n### Is your feature request related to a problem\r\n\r\nI want to be able to track chapters that are in progress or already translated. \r\n\r\n### The solution you would like\r\n\r\nEach person who is working in a chapter should notify in this issue.  Comment with the name of the file. If more than two weeks are passed, other people can take this file. \r\n\r\n### Describe alternatives you've considered\r\n\r\nWe can track using our telegram channel `@fastapibr`, but the issue can be easy.\r\n\r\n### Additional context\r\n\r\nThere is no additional context.", "output": "Resolution:\nGood news everyone! ðŸ˜‰ There's a new translation PR to be reviewed: #4111 ðŸŽ‰", "source": "issue_closed", "type": "qa_resolution", "issue_number": 5}
{"instruction": "How was this issue resolved: The memory usage piles up over the time and leads to OOM", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ ] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [ ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ ] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\nHere's a self-contained, [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n<!-- Replace the code below with your own self-contained, minimal, reproducible, example, if I (or some", "output": "Resolution:\nFWIW -- you may have luck switching to hypercorn workers (plus you get http/2)", "source": "issue_closed", "type": "qa_resolution", "issue_number": 4}
{"instruction": "How was this issue resolved: Spanish translations", "input": "### Spanish translations tracking\r\n\r\nWe can use this Issue to track the progress of the Spanish language translations. ðŸ¤“ \r\n\r\nPlease let us know here what page you plan on translating so we can coordinate. ðŸš€ \r\n\r\n#### Tips\r\n\r\n- We chose to use \"tu\" instead of \"usted\" or \"vos\"\r\n\r\n- If the term is a technical term, leave in English and add an explanation of the meaning of the word in Spanish.  You can do it with a note or an `abbr` element. This should help us avoid confusion with confusing Spanish translations, for example using \"instancia\" for \"instance\". \r\n\r\nThank you for your help! Gracias por tu ayuda! ðŸŽ‰", "output": "Resolution:\nwow, you're working quite fast on it\n\n----- Original Message -----\nFrom: \"Pedro A. Moreno\" <notifications@github.com>\nTo: tiangolo/fastapi <fastapi@noreply.github.com>\nCc: jorgerpo <jorgehrpo@gmail.com>,  Mention <mention@noreply.github.com>\nDate: Mon, 25 Jan 2021 08:41:17 -0800\nSubject: Re: [tiangolo/fastapi] [FEATURE] Spanish translations (#1218)\n\n> ??! I'm starting to translate [deployment/deta.md](https://github.com/tiangolo/fastapi/blob/master/docs/en/docs/deployment/deta.md)\n> \n> \n> \n> -- \n> \n> You are receiving this because you were mentioned.\n> \n> Reply to this email directly or view it on GitHub:\n> \n> https://github.com/tiangolo/fastapi/issues/1218#issuecomment-766946661\n> \n", "source": "issue_closed", "type": "qa_resolution", "issue_number": 3}
{"instruction": "How was this issue resolved: CORSMiddleware not work", "input": "Hi,\r\nI searched the FastAPI documentation( https://fastapi.tiangolo.com/tutorial/cors/). But get errors:\r\nAccess to XMLHttpRequest at \"http://127.0.0.1:8086/api\" from origin \"http://www.example.com\" has been blocked by CORS policy:Response to preflight request doesn't pass access control check:No 'Access-Control-Allow-Origin' header is present on the requeste resource.\r\n\r\n\"http://127.0.0.1:8086/api\" and \"http://www.example.com\" are in same pc.\r\n\r\nfrom fastapi import FastAPI\r\nfrom starlette.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=[\"*\"],      \r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"], \r\n    allow_headers=[\"*\"],\r\n)", "output": "Resolution:\nJust FYI, after plenty of observations and debugging I noticed that the CORS documentation at https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS is no longer true / complete.\r\n\r\nBrowsers are now more strict than the specification. For example, a few pain points for Chrome:\r\n1. It can make OPTIONS (pre-flight) requests before each GET request (could not find the exact conditions in which it doesn't).\r\n2. It requires the CORS headers be set also on GET responses, not just the OPTIONS responses (this can have significant implications if you are relying on an external middleware i.e. AWS API Gateway or nginx to handle the CORS).\r\n3. Developer tools no longer show the OPTIONS requests, instead they simply show the GET request failed with a message in the console log that does not always reflect the reality. This makes debugging the exact failure point very tricky.", "source": "issue_closed", "type": "qa_resolution", "issue_number": 2}
{"instruction": "How was this issue resolved: Chineses translations", "input": "## Chinese translation tracking\r\n\r\n### Is your feature request related to a problem\r\n\r\nIs your feature request related to a problem?\r\n\r\nI want to be able to track chapters that are in progress or already translated.\r\n\r\n### The solution you would like\r\n\r\nEach person who is working in a chapter should notify in this issue. Comment with the name of the file. If more than two weeks are passed, other people can take this file.\r\n\r\n### Describe alternatives you've considered\r\n\r\nWe use notion to distribution chapter and tracking translating  sate.\r\nIf you want join our, you can contact with us.  @waynerv @RunningIkkyu \r\n\r\n### Additional context\r\nIt â€™s okay to talk about this in this issue.", "output": "Resolution:\nGood news everyone! ðŸ˜‰ There's a new translation PR to be reviewed: #3825 ðŸŽ‰", "source": "issue_closed", "type": "qa_resolution", "issue_number": 1}
{"instruction": "Need help tracking API usage", "input": "### First Check\r\n\r\n- [X] I added a very descriptive title to this issue.\r\n- [X] I used the GitHub search to find a similar issue and didn't find it.\r\n- [X] I searched the FastAPI documentation, with the integrated search.\r\n- [X] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n- [X] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n- [X] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n- [X] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n- [X] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n### Commit to Help\r\n\r\n- [X] I commit to help with one of those options ðŸ‘†\r\n\r\n### Example Code\r\n\r\n```python\r\nfrom typing import Callable\r\nfrom fastapi import Request, Response, Depends\r\nfrom fastapi.routing import APIRoute\r\nfrom server.routes.users import fastapi_users\r\nfrom server.models.users import *\r\n\r\nclass session_log(APIRoute):\r\n    def get_route_handler(self) -> Callable:\r\n        original_route_handler = super().get_route_handler()\r\n\r\n        async def custom_route_handler(request: Request,\r\n        user: User = fastapi_users.get_current_user\r\n        ) -> Response:\r\n            response: Response = await original_route_handler(request)\r\n            # print(f\"route response: {response}\")\r\n            try:\r\n                print(\"User\", str(user))\r\n            except Exception as e:\r\n                print(f\"Error : {e}\")\r\n            return response\r\n\r\n        return custom_route_handler\r\n```\r\n\r\n\r\n### Description\r\n\r\nHi, I'm looking for a way to track api usage on user basis. We are using fastapi-users for user management. Can anyone please suggest a way to do this. I tried using a custom API Router but was unable to fetch user details as it done through dependency injection and I kept getting errors like Depends object ha", "output": "Hi @ari-jain013, if your logs don't require the response object, you could create a dependency for logging ([that depends on user dependency](https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/)) and inject it on all routes.\r\n\r\nFor logging, check:  https://github.com/tiangolo/fastapi/issues/778#issuecomment-563284270\r\n\r\nFor adding the dependency on all paths, check: https://fastapi.tiangolo.com/tutorial/bigger-applications/\r\n> And we can add a list of dependencies that will be added to all the path operations in the router and will be executed/solved for each request made to them.\r\n\r\n**EDIT:** Just to add an example \r\n```python\r\nfrom fastapi import FastAPI, APIRouter, Depends\r\n\r\napp = FastAPI()\r\n\r\ndef user_dep() -> int:\r\n    print(\"CALLED USER DEPENDENCY\")\r\n    user = 0\r\n    return user\r\n\r\ndef logger_dep(user: int = Depends(user_dep)):\r\n    print('CALLED LOGGER', user)\r\n\r\nlogged_router = APIRouter(dependencies=[Depends(logger_dep)])\r\n\r\n@app.get(\"/not-logged\")\r\nasync def not_logged(user: int = Depends(user_dep)):\r\n    return user\r\n\r\n@logged_router.get(\"/logged\")\r\nasync def logged(user: int = Depends(user_dep)):\r\n    return user\r\n\r\napp.include_router(logged_router)\r\n```\r\n\r\nYou can confirm, user dependency is only called once for each path (other calls use cached value): \r\n```python\r\nfrom fastapi.testclient import TestClient\r\nclient = TestClient(app)\r\nclient.get('/logged')\r\n```\r\nGives:\r\n>CALLED USER DEPENDENCY\r\n>CALLED LOGGER 0\n\nOkay, I think I can start with this but again it would be great analytics if I could also track is the response was successful or not.\r\n\r\nThank you for the quick reply\n\nIf you need to wait for the response, I would add a middleware for logging. For user info, [starlette allows you attach states to the request object](https://www.starlette.io/requests/#other-state), which you can then access from the middleware. Not sure if there is a downside to using this with FastAPI, but the following example runs correctly. \r\n\r\n```python\r\nfrom fastapi import FastAPI, Depends, Request\r\n\r\nasync def user_dep() -> int:\r\n    user = 0\r\n    return user\r\n\r\nasync def add_request_state(request: Request, user: int = Depends(user_dep)):\r\n    request.state.user = user\r\n\r\napp = FastAPI(dependencies=[Depends(add_request_state)])\r\n\r\n@app.middleware(\"http\")\r\nasync def add_logs(request: Request, call_next):\r\n    response = await call_next(request)\r\n    print (\"some logging logic for user\", request.state.user)\r\n    print (\"response status code: \", response.status_code)\r\n    return response\r\n\r\n\r\n@app.get(\"/test\")\r\nasync def logged(user: int=Depends(user_dep)):\r\n    return user\r\n\r\n# Test behavior\r\nfrom fastapi.testclient import TestClient\r\nclient = TestClient(app)\r\nclient.get('/test')\r\n```\r\n> some logging logic for user 0\r\n> response status code:  200", "source": "issue", "type": "how_to", "issue_number": 117}
{"instruction": "How to pass list in query parameters?", "input": "**Description**\r\n\r\nI need to support several query parameters with same name in GET route. Typical request looks like this:\r\nhttp://localhost/item?num=1&num=2\r\n\r\nI configured a route\r\n````\r\n@app.get(\"/item\", content_type=UJSONResponse)\r\nasync def get_part(num: list):\r\n    found = False\r\n    for i in num:\r\n         if i in some_data:\r\n             found = True\r\n             break\r\n    return {\"found\": found}\r\n````\r\nThe idea is, that I can pass several numbers to check, if they exist in some_data. In my opinion, it is not a good idea to get numbers from body here, because it is a simple GET request, but in current version application expects argument \"num\" in body, so on my request (written above) I receive a response\r\n\r\n`{\"detail\":[{\"loc\":[\"body\",\"num\"],\"msg\":\"field required\",\"type\":\"value_error.missing\"}]}`\r\n\r\nAs I know, it is not restricted to pass several query parameters with the same name in an HTTP request by any specifications, so I would like to ask, is it possible to configure a route in FastAPI, which will be able to parse several query parameters with the same name?", "output": "It is supported (and tested), but not documented yet, but you can just use standard Python types (a `List`) :)\r\n\r\n```Python\r\nfrom typing import List\r\n\r\nfrom fastapi import FastAPI, Query\r\n\r\napp = FastAPI()\r\n@app.get(\"/items/\")\r\ndef read_items(q: List[int] = Query(None)):\r\n    return {\"q\": q}\r\n```\n\nIt is now properly documented :memo: :tada: \r\n\r\nFor query parameters: https://fastapi.tiangolo.com/tutorial/query-params-str-validations/#query-parameter-list-multiple-values\r\n\r\nAnd for duplicate headers: https://fastapi.tiangolo.com/tutorial/header-params/#duplicate-headers\n\nI guess this is solved now, so I'll close the issue. But feel free to add more comments or create new issues.", "source": "issue", "type": "how_to", "issue_number": 114}
{"instruction": "Only show documentation while logged in", "input": "**Description**\r\n\r\nIs it possible to only show the documentation based on being logged in? Many times I create an API which should only expose it's documentation when somebody is logged in.", "output": "Sorry for the delay.\r\n\r\nIn short, **yes** *.\r\n\r\n*Now goes the \"it depends\"...\r\n\r\n## Long version\r\n\r\nHow are you logging in users?\r\n\r\n### Simplest, less secure\r\n\r\nThe simplest, less secure option I can imagine, is embeding your Swagger UI in your frontend, and show it selectively on if the user is authenticated or not.\r\n\r\n### FastAPI security\r\n\r\nFastAPI doesn't enforce a specific way to log in users, but you can use several approaches, e.g.:\r\n\r\n* JWT tokens in HTTP headers.\r\n* Session Cookies.\r\n* HTTP Basic Auth.\r\n* ...others.\r\n\r\n### OAuth2 JWT tokens\r\n\r\n**spoiler**: I think this wouldn't work for you.\r\n\r\nThe suggestion in the docs, using OAuth2 with the \"password flow\" (JWT tokens in HTTP headers), involves the following steps:\r\n\r\n* The client sends a `POST` with form data, including `username` and `password`.\r\n* The server returns a JSON body with an `access_token`.\r\n* For the next requests, to authenticated endpoints, the client sends that access token in a header.\r\n* The server checks that access token in the header, validates it, etc, and returns the content.\r\n\r\nUsing that, it is common to hold that access token in memory in the client (in a JS variable) or in `localStorage`. And then, when the client (your JS code in the browser) requests a protected endpoint, it sends the access token in the HTTP header. But you have to code it explicitly.\r\n\r\nNow, when you open the browser in the docs (Swagger UI), it doesn't automatically send any token from anywhere, because it would have to be added explicitly in code, taken from wherever you put it.\r\n\r\n### Cookies\r\n\r\nAnother option would be to use Cookies. Because the browser sends those Cookies automatically. But in that case, the API and the Swagger UI must live in the same host (the same combination of `http` or `https` and domain), for the browser to actually send the Cookies.\r\n\r\nBut still, all that doesn't change the actual `/openapi.json` endpoint to be available. So, you might want to use Cookies to override it too.\r\n\r\n### Basic Auth\r\n\r\nAnother simpler option would be to protect those endpoints with HTTP Basic Auth. So, the browser would show the default authentication pop-up and would remember the credentials used there for some time. But that would be more or less disconnected from your current authentication system.\n\nThanks for your elaborate answer! I will check-out the OAuth2 JWT token, Cookies and Basic Auth options and see what the best route is. Is there an easy / quick way to add a Depends / Security option to the documentation endpoints? \n\nYes, it is relatively easy to add dependencies to those endpoints. You can create your `FastAPI` removing the automatic docs endpoints: https://fastapi.tiangolo.com/tutorial/application-configuration/#docs-urls\r\n\r\nAnd then you can create them by hand, using the utils from `fastapi.openapi.docs`, there's a `get_swagger_ui_html` and `get_redoc_html` functions. There you can create the endpoints/path operations as normally.\r\n\r\nBut the next problem (probably the main one) is how to authenticate the user and where, outside the docs endpoints.", "source": "issue", "type": "how_to", "issue_number": 113}
{"instruction": "How to work with form data?", "input": "Hello everyone!\r\nI need to process form data but I can't do that with fastapi. To try understand how can I do it I used Postman to send data in different ways:\r\nfrom form-data tab\r\nfrom x-www-form-urlencoded\r\nwith header \"Content-Type: application/x-www-form-urlencoded\"\r\nwith header \"Content-Type: application/json\"\r\nwithout headers\r\n\r\nIn any case I have the same result: {\"detail\": \"There was an error parsing the body\"}.\r\n\r\n![postman](https://user-images.githubusercontent.com/22984590/57228831-54404d80-7047-11e9-8fa6-4502b8a29dca.png)\r\n\r\n```\r\nfrom fastapi import FastAPI, HTTPException, Form\r\n\r\n@app.post(\"/subscription_email\")\r\ndef subscription_email(*, customers: int = Form(...)):\r\n    return customers\r\n```\r\nCode based on example from docs.\r\n\r\nPlease, help me to fix it and understand how to work woth form data from POST requests.", "output": "Here is what I'm using for file upload (using forms):\r\n\r\nhttps://fastapi.tiangolo.com/tutorial/request-forms-and-files/\r\n\r\n    @router.post(\"/nanopubs/import/file\", tags=[\"Nanopubs\"])\r\n    def import_nanopubs(\r\n        file: UploadFile = File(...),\r\n        overwrite: bool = Query(False, description=\"Overwrite if exists when true\"),\r\n        validation: bool = Query(True, description=\"Validate nanopub when true\"),\r\n        email: str = Query(\"\", description=\"Will send email with processing results\"),\r\n    ):\r\n\r\n        if file:\r\n            contents = file.file.read().decode(\"utf-8\")\r\n            try:\r\n                nanopubs = json.loads(contents)\r\n            except Exception as e:\r\n                log.error(\"Error reading nanopub json content\", error=str(e))\r\n\n\n@wshayes thank you for advice. It works fine with query parameters but still doesn't work with data from form fields.\n\nyour example works fine out of the box with the swagger generated at /docs\r\n\r\nedit: email doesnt support markdown, see screens below\r\n", "source": "issue", "type": "how_to", "issue_number": 112}
{"instruction": "How to manage relationships in (pydantic) models", "input": "EDIT: add proper greetings ðŸ™„ \r\n\r\nHi guys,\r\n\r\nMany thanks for this fantastic repo. It rocks. Not to mention https://dockerswarm.rocks/, I am now in the process to review all my projects from this base ðŸ¥‡ \r\n\r\n**Here is my question :**\r\n\r\nHow can I declare a one-to-many relationship in the pydantic models?\r\n\r\n**Context**\r\n\r\nI have a first object 'Rule', that is attached to a second 'City'.\r\n\r\nI have tried the following without success :\r\n\r\nrules.py\r\n```\r\nfrom app.models.cities import City\r\n\r\nclass RuleBase(BaseModel):\r\n    mode: Optional[RuleMode] = None\r\n    value: Optional[float] = None\r\n    city: Optional[City] = None\r\n```\r\n\r\n\r\ncities.py\r\n```\r\nclass City(BaseModel):\r\n    id: int\r\n    name: str\r\n    rules: Optional[List['Rule']]\r\n```\r\n\r\nError in tests:\r\n\r\n```\r\nImportError while loading conftest '/app/app/tests/conftest.py'.\r\napp/app/tests/conftest.py:4: in <module>\r\n    from app.models.cities import City, Rectangle, Point\r\napp/app/models/cities.py:50: in <module>\r\n    class City(BaseModel):\r\nusr/local/lib/python3.6/site-packages/pydantic/main.py:179: in __new__\r\n    config=config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:118: in infer\r\n    schema=schema,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:152: in prepare\r\n    self._populate_sub_fields()\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in _populate_sub_fields\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:177: in <listcomp>\r\n    self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:210: in _create_sub_type\r\n    model_config=self.model_config,\r\nusr/local/lib/python3.6/site-packages/pydantic/fields.py:87: in __init__\r\n    self.prepare()\r\nusr/local/lib/python3.6/si", "output": "It won't answer your question exactly but I feel it's the same pattern where you have recursivity and declare an attribute of a model while that depends on another not yet created\r\n\r\nmy model looks like this :\r\n\r\n```\r\n<LoggerModel name='root' level=20 children=[<LoggerModel name='__main__' level=10 children=[]>, <LoggerModel name='__mp_maâ€¦>\r\n```\r\n\r\n```\r\nfrom __future__ import annotations\r\n\r\nfrom typing import ForwardRef, List, Optional\r\n\r\nfrom pydantic import BaseModel\r\n\r\nListLoggerModel = ForwardRef(\"List[LoggerModel]\")\r\n\r\nclass LoggerModel(BaseModel):\r\n    name: str\r\n    level: Optional[int]\r\n    children: ListLoggerModel = None\r\n\r\n\r\nLoggerModel.update_forward_refs()\r\n```\n\nThanks for the hint!\r\n\r\nI got an ImportError with python 3.6.8\r\n\r\n```\r\n>>> from typing import ForwardRef\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nImportError: cannot import name 'ForwardRef'\r\n```\r\n\r\nTherefore I installed python 3.7.3 and that solved the issue.\r\n\r\nProbably something to report to https://github.com/tiangolo/full-stack-fastapi-postgresql, from which I started from :)\n\nForwardref is a python 3 thing indeed, maybe there s a way to achieve the\nsame without, @tiangolo will know for sure !\n\nLe ven. 12 avr. 2019 Ã  7:59 PM, Manu <notifications@github.com> a Ã©crit :\n\n> Thanks for the hint!\n>\n> I got an ImportError with python 3.6.8\n>\n> >>> from typing import ForwardRef\n> Traceback (most recent call last):\n>   File \"<stdin>\", line 1, in <module>\n> ImportError: cannot import name 'ForwardRef'\n>\n> Therefore I installed python 3.7.3 and that solved the issue.\n>\n> Probably something to report to\n> https://github.com/tiangolo/full-stack-fastapi-postgresql, from which I\n> started from :)\n>\n> â€”\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/153#issuecomment-482667182>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABDZPnowf6UmatNDVrS7YpgPPMgkXMCnks5vgMlkgaJpZM4csUX5>\n> .\n>\n", "source": "issue", "type": "how_to", "issue_number": 96}
{"instruction": "How to Prevent the 307 Temporary Redirect When There's a Missing Trailing Slash", "input": "### Description\r\n\r\nJust like the author of #731, I don't want a 307 temporary redirect which is automatically sent by uvicorn when there's a missing trailing slash in the api call. However, the solution given in that issue, i.e. route path like \"/?\" no longer works in the versions after this April as reported in in #1787, #1648 and else. Certain developers states this is an unexpected behavior and won't be supported in the future. In this case, I'm wondering what is the current elegant way to realize this. Or there's any way to handle both \"\" and \"/\" two paths simultaneously?", "output": "You can have multiple decorators with path routes w/ and w/o the trailing slash.  Not incredibly elegant because then you get duplicate endpoints in your swagger docs.\r\n\r\nIt should be mentioned this is a Starlette issue. There are several issues about this in the repo, here is one of them: https://github.com/encode/starlette/issues/1008\r\n\r\nIf FastAPI could handle this, it might be to somehow identify and remove the duplicate entries in swagger docs.\n\n@falkben just use include_in_schema=False on one decorator.\n\nYours answers together is a very good workaround!", "source": "issue", "type": "how_to", "issue_number": 90}
{"instruction": "What is the efficient way to get images using FAST API?", "input": "How to get an image using Fast API ?", "output": "```Python\r\n\r\nfrom fastapi import FastAPI, File, UploadFile\r\nfrom fastapi.responses import FileResponse\r\nfrom pydantic import BaseModel\r\n\r\nimport numpy as np\r\n\r\nfrom PIL import Image\r\n\r\nimport shutil\r\n\r\nimport tensorflow as tf\r\nfrom object_detection.utils import label_map_util\r\nfrom object_detection.utils import visualization_utils as viz_utils\r\n\r\napp = FastAPI()\r\n\r\ndetect_fn = tf.saved_model.load('saved_model')\r\ncategory_index = label_map_util.create_category_index_from_labelmap(\"label_map.pbtxt\",use_display_name=True)\r\n\r\n\r\ndef load_image_into_numpy_array(path):\r\n    \"\"\"Load an image from file into a numpy array.\r\n\r\n    Puts image into numpy array to feed into tensorflow graph.\r\n    Note that by convention we put it into a numpy array with shape\r\n    (height, width, channels), where channels=3 for RGB.\r\n\r\n    Args:\r\n      path: the file path to the image\r\n\r\n    Returns:\r\n      uint8 numpy array with shape (img_height, img_width, 3)\r\n    \"\"\"\r\n    return np.array(Image.open(path))\r\n\r\n\r\ndef predict(image):\r\n     # The input needs to be a tensor, convert it using `tf.convert_to_tensor`.\r\n    image_np = np.array(image.file)\r\n    input_tensor = tf.convert_to_tensor(image_np)\r\n    # The model expects a batch of images, so add an axis with `tf.newaxis`.\r\n    input_tensor = input_tensor[tf.newaxis, ...]\r\n\r\n    # input_tensor = np.expand_dims(image_np, 0)\r\n    detections = detect_fn(input_tensor)\r\n\r\n    # All outputs are batches tensors.\r\n    # Convert to numpy arrays, and take index [0] to remove the batch dimension.\r\n    # We're only interested in the first num_detections.\r\n    num_detections = int(detections.pop('num_detections'))\r\n    \r\n    detections = {key: value[0, :num_detections].numpy()\r\n                   for key, value in detections.items()}\r\n    detections['num_detections'] = num_detections\r\n\r\n    # detection_classes should be ints.\r\n    detections['detection_classes'] = detections['detection_classes'].astype(np.int64)\r\n\r\n    image_np_with_detections = image_np.copy()\r\n\r\n    viz_utils.visualize_boxes_and_labels_on_image_array(\r\n          image_np_with_detections,\r\n          detections['detection_boxes'],\r\n          detections['detection_classes'],\r\n          detections['detection_scores'],\r\n          category_index,\r\n          use_normalized_coordinates=True,\r\n          max_boxes_to_draw=200,\r\n          min_score_thresh=.50,\r\n          agnostic_mode=False)\r\n    print(\"Detected\")\r\n    return image_np_with_detections\r\n\r\n\r\n@app.get(\"/\")\r\nasync def main():\r\n    return FileResponse(r\"misdo.jpg\")\r\n\r\n\r\n@app.post(\"/uploadfile/\")\r\nasync def create_upload_file(image: UploadFile = File(...)):\r\n    predicted_image = predict(image)\r\n    return predicted_image```\r\n\r\n###ValueError: Failed to convert a NumPy array to a Tensor (Unsupported object type SpooledTemporaryFile).\n\n> Get an image of/from what?\r\n\r\nCould you look at my code and suggest me a way to pass image and get inference from it?\n\nYou can post an image using a form file upload, the rest is up to you.\n\nSee here: https://fastapi.tiangolo.com/tutorial/request-files/", "source": "issue", "type": "how_to", "issue_number": 88}
{"instruction": "How can I serve static files (html, js) easily?", "input": "**Description**\r\n\r\n How can I serve static files (html, js) easily? Even though I don't need to inject python data, I attempted to do it with jinja and encountered issues.\r\n\r\n**Additional context**\r\n I tried something like: \r\n\r\n```\r\n@router.get(\"/webui/{file_name}\", name=\"webui.show\")\r\nasync def webui_show(file_name: str):\r\n    template = jinja2.get_template(file_name)\r\n    content = template.render()\r\n    return HTMLResponse(content=content, status_code=200)\r\n```\r\n\r\nWhere jinja2 was \r\n```\r\nloader = FileSystemLoader(web_dir(\"dist\"))\r\n# no escaping while deubing\r\njinja2 = Environment(loader=loader, autoescape=False)\r\n```\r\n\r\nBut I received an error message \"jinja2.exceptions.TemplateSyntaxError: Expected an expression, got 'end of print statement'\" when returning JavaScript files. What's sanctioned way to implement simple static file serving in fastapi? If so, it'd be nice to have some documentation around it.", "output": "FastAPI being based on Starlette you may use it for that purpose: https://www.starlette.io/staticfiles/\n\n@3lpsy if you have a directory with static files, you can do as @euri10 suggests.\r\n\r\nIf you want to return some specific files (not necessarily from a fixed static directory), you can use a `FileResponse`: https://www.starlette.io/responses/#fileresponse\n\nThanks for the responses @euri10  and @tiangolo. I was attaching the StaticFiles instance to the FastAPI() app incorrectly because I thought StaticFiles was a route but it's more of an ASGI app. For anyone else trying to do the same, you can do something like: \r\n\r\n```\r\napi = FastAPI(title=config.API_PROJECT_NAME, openapi_url=\"/api/v1/openapi.json\")\r\napi.mount(\"/static\", StaticFiles(directory=\"static\"))\r\n```\r\n\r\n", "source": "issue", "type": "how_to", "issue_number": 84}
{"instruction": "How does one setup a global timeout to all requests?", "input": "### First check\r\n<details>\r\n\r\n<summary>\r\n<i>Ticked all checks, then first commitment choice</i>\r\n</summary>\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n\r\n</details>\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Description\r\n\r\nHi there, first of all many thanks for the work on FastAPI - this is now my goto framework for building Python-based REST APIs :)\r\n", "output": "Hi @PLNech \r\n\r\nI am developing my own API using FastAPI and ran into the same \"problem\" as I am trying to add a global timeout to all my requests. \r\n\r\nI am still new to fastapi but from what I understand I believe the \"fastapi\" way to do so would be to use a middleware as they are designed to be ran at every request by nature. As I searched on how to do so I found this\r\n[gitter community thread](https://gitter.im/encode/community?at=5eee4457fa0c9221fc4ddeb4) and thought it could maybe help you. \r\n\r\nI am going to implement both your solution and the middleware based one and see which one I prefer and works best. Also note that there seems to be a problem with starlette 0.13.3 and higher so keep that in mind.\r\n\r\nAlso if you found a workaround by now I am more than interested.\r\n\r\nHope it helped you a bit\n\nHi @ZionStage, thanks for your message! I haven't found a workaround for now. Looking forward to continuing this conversation with you as we move forward on this topic :)\n\nHey @PLNech \r\n\r\nI have implemented and tested the middleware and it seems to be working fine for me. Here is my code \r\n```python\r\nimport asyncio\r\nimport time\r\n\r\n\r\nimport pytest\r\n\r\nfrom fastapi import FastAPI, Request, Response, HTTPException\r\nfrom fastapi.responses import JSONResponse\r\nfrom httpx import AsyncClient\r\nfrom starlette.status import HTTP_504_GATEWAY_TIMEOUT\r\n\r\nREQUEST_TIMEOUT_ERROR = 1  # Threshold\r\n\r\napp = FastAPI() # Fake app\r\n\r\n# Creating a test path\r\n@app.get(\"/test_path\")\r\nasync def route_for_test(sleep_time: float) -> None:\r\n    await asyncio.sleep(sleep_time)\r\n\r\n# Adding a middleware returning a 504 error if the request processing time is above a certain threshold\r\n@app.middleware(\"http\")\r\nasync def timeout_middleware(request: Request, call_next):\r\n    try:\r\n        start_time = time.time()\r\n        return await asyncio.wait_for(call_next(request), timeout=REQUEST_TIMEOUT_ERROR)\r\n\r\n    except asyncio.TimeoutError:\r\n        process_time = time.time() - start_time\r\n        return JSONResponse({'detail': 'Request processing time excedeed limit',\r\n                             'processing_time': process_time},\r\n                            status_code=HTTP_504_GATEWAY_TIMEOUT)\r\n\r\n# Testing wether or not the middleware triggers\r\n@pytest.mark.asyncio\r\nasync def test_504_error_triggers():\r\n    # Creating an asynchronous client to test our asynchronous function\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\r\n        response = await ac.get(\"/test_path?sleep_time=3\")\r\n    content = eval(response.content.decode())\r\n    assert response.status_code == HTTP_504_GATEWAY_TIMEOUT\r\n    assert content['processing_time'] < 1.1\r\n\r\n# Testing middleware's consistency for requests having a processing time close to the threshold \r\n@pytest.mark.asyncio\r\nasync def test_504_error_consistency():\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\r\n        errors = 0\r\n        sleep_time = REQUEST_TIMEOUT_ERROR*0.9\r\n        for i in range(100):\r\n            response = await ac.get(\"/test_path?sleep_time={}\".format(sleep_time))\r\n            if response.status_code == HTTP_504_GATEWAY_TIMEOUT:\r\n                errors += 1\r\n        assert errors == 0\r\n\r\n# Testing middleware's precision\r\n# ie : Testing if it triggers when it should not and vice versa\r\n@pytest.mark.asyncio\r\nasync def test_504_error_precision():\r\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\r\n        should_trigger = []\r\n        should_pass = []\r\n        have_triggered = []\r\n        have_passed = []\r\n        for i in range(200):\r\n            sleep_time = 2 * REQUEST_TIMEOUT_ERROR * random.random()\r\n            if sleep_time < 1.1:\r\n                should_pass.append(i)\r\n            else:\r\n                should_trigger.append(i)\r\n            response = await ac.get(\"/test_path?sleep_time={}\".format(sleep_time))\r\n            if response.status_code == HTTP_504_GATEWAY_TIMEOUT:\r\n                have_triggered.append(i)\r\n            else:\r\n                have_passed.append(i)\r\n        assert should_trigger == have_triggered\r\n```\r\n\r\nI created three tests, the first one is designed to see wether or not the middleware actually does its job. \r\nThe second one is just there to check if there is any consistency problem with a single request. \r\nThe third one is here to check if I ran into the same issue raised in the [thread I mentioned](https://gitter.im/encode/community?at=5eee4457fa0c9221fc4ddeb4). \r\n\r\nAs far as I am concerned the first two tests passed without a problem.\r\n**However** the third one failed. There are requests that have triggered when they should not : \r\n```\r\nE           AssertionError: assert [3, 7, 10, 11, 12, 14, ...] == [3, 7, 8, 10, 11, 12, ...]\r\nE             At index 2 diff: 10 != 8\r\nE             Right contains 11 more items, first extra item: 165\r\n```\r\nThis is the issue mentioned in the thread. I'll downgrade to starlette 0.13.2 and see if the test pass.\r\n\r\nI might have made some mistakes or overlooked some things so I", "source": "issue", "type": "how_to", "issue_number": 81}
{"instruction": "How to use different middleware for different routes/path", "input": "### First check\r\n\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n\r\n### Description\r\n\r\nIs it possible to use different middleware for different routes/path?\r\n\r\n### Additional context\r\n\r\nIn my case my need comes from CORS. But, I am sure there is other cases than CORS requirements that someone would need different middlewares for different paths.\r\n\r\n* I want `myapi.com/path1` to allow origins of calls from `myfrontend.com`\r\n* I want `myapi.com/path2` to allow origins of calls from anywhere ('*') since it is a public facing api.\r\n\r\nI checked if it was possible to add a middleware at a router level and did not find any documentation about it.\r\n\r\n### Code example\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastapi.middleware.cors import CORSMiddleware\r\n\r\napp = FastAPI()\r\n\r\napp.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['myfrontend.com'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# I want /path1 to allow only calls from 'myfrontend.com'\r\n@app.get(\"/path1\")\r\nasync def path1():\r\n    return {\"status\": \"alive\"}\r\n\r\n# I want /path2 to be a public facing api that can be accessed from anywhere ['*']\r\n@app.get(\"/path2\")\r\nasync def path2():\r\n    return {\"status\": \"alive\"}\r\n\r\n```", "output": "I haven't use this way, but you can have a try.\r\nHow about use subapp?\r\n[documention](https://fastapi.tiangolo.com/advanced/sub-applications-proxy/#mount-the-sub-application)\n\nThank you @Dustyposa this looks exactly like what I was looking for.\r\n\r\nHere is a example implementation in case someone else stumble upon the same problem\r\n\r\n```python\r\n# app1.py\r\n\r\nfrom fastapi import FastAPI\r\n\r\napp1 = FastAPI(openapi_prefix=\"/app1\")\r\n\r\n@app1.get(\"path1\")\r\nasync def path1():\r\n    return { \"message\": \"app1\"}\r\n```\r\n\r\n```python\r\n# app2.py\r\n\r\nfrom fastapi import FastAPI\r\n\r\napp2 = FastAPI(openapi_prefix=\"/app2\")\r\n\r\n@app1.get(\"path2\")\r\nasync def path2():\r\n    return { \"message\": \"app2\"}\r\n```\r\n\r\n```python\r\n# main.py\r\n\r\nfrom fastapi import FastAPI\r\nfrom app1 import app1\r\nfrom app2 import app2\r\n\r\n\r\napp1.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['myfrontend.com'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\n# here we can add middlewares that are only for app2 and not executed on paths of app1\r\n# the CORS policy is different for app2. (allows '*' instead of 'myfrontend.com')\r\napp2.add_middleware(\r\n    CORSMiddleware,\r\n    allow_origins=['*'],\r\n    allow_credentials=True,\r\n    allow_methods=[\"*\"],\r\n    allow_headers=[\"*\"],\r\n)\r\n\r\napp = FastAPI()\r\n\r\napp.mount(\"/app1\", app1) # if does not work try: app.mount(app1, \"/app1\")\r\napp.mount(\"/app2\", app2) # if does not work try: app.mount(app2, \"/app2\")\r\n\r\n@app.get(\"/\")\r\nasync def root():\r\n    return {\"message\": \"alive\"}\r\n\r\n```\n\nThanks for your help here @Dustyposa :bowing_man: :cake: \r\n\r\nAnd thanks for reporting back and closing the issue @philippegirard :rocket: ", "source": "issue", "type": "how_to", "issue_number": 75}
{"instruction": "How to hide certain fields in Pydantic models?", "input": "Example:\r\n\r\nI have created_at and updated_at fields that I want to auto populate on the model using default_factory, but I don't want the user to be able to set them via an endpoint. I thought this could be achieved by the read only Field arg but then I can never set it.\r\n\r\nWhat's the best way to go about this?", "output": "``` python\r\nfrom pydantic import BaseModel,Field\r\nfrom datetime import datetime\r\n\r\n\r\n\r\nclass User(BaseModel):\r\n    name:str\r\n    create_at: datetime = datetime.now()\r\n\r\nuser_in_system = User(name='includeamin')\r\nprint(user_in_system.dict(exclude={'create_at'}))\r\n# output: {'name': 'includeamin'}\r\n```\n\nSorry I should have clarified, how do you hide them in the openapi spec? :)\n\nI mean you could create two models, one internal and one external, but you have to be careful between converting between two models (performance v.s. validation).", "source": "issue", "type": "how_to", "issue_number": 74}
{"instruction": "How to achieve nested parameterized dependencies?", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n\r\n\r\n### Example\r\n\r\nGiven the follow minimal working example, where `Test1` and `Test2` are parameterized dependencies (as described in https://fastapi.tiangolo.com/advanced/advanced-dependencies/). One parameter of `Test2` should be forwarded to `Test1` which should be injected into `Test2`.:\r\n\r\n```Python\r\nimport uvicorn\r\nfrom fastapi import Depends, FastAPI\r\napp = FastAPI()\r\n\r\nclass Test1():\r\n\r\n    def __init__(self, t1) -> None:\r\n        self.t1 = t1\r\n\r\n    def __call__(self):\r\n        return self.t1\r\n\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n\r\n    def __call__(self):\r\n        return Depends(Test1(t1=self.t2))\r\n\r\n@app.get(\"/test/\")\r\ndef test_call(test: str = Depends(Test2(t2='test'))):\r\n    return test\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True, debug=True)\r\n```\r\n\r\n### Description\r\n\r\nIt is not possible to include `Test1` as dependency in the `call` parameters of `Test2` since there wouldn't be any access to the parameter of `Test1`.\r\nDirectly calling `Depends` as in the example above also does not work since there does not seem to be any dependency injection at this level.\r\n\r\nHow to achieve this kind of nesting? Is this simply not po", "output": "you could add a `Test1` instance in `Test2.__init__`\r\nyou could get an instance as input like : `Depends(Test2(t2='test2', test1=Test1(t1='test1')))`\r\nor you can create one in `__init__` like:\r\n```\r\nclass Test2():\r\n\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n        self.test1=Test1(t1=t2)\r\n```\n\n@ihakh This does not provide any dependency injection to the `__call__` method of `Test1`. Getting this to work with dependency injections is the point of this question / feature request.\n\nHey @Spenhouet, thanks for the interest.\r\n\r\nI think I'm having a bit of trouble understanding the use case. I think I can imagine simple ways to solve it without requiring support for that, but I'm probably missing details of your use case.\r\n\r\nFor example, this seems to work:\r\n\r\n```Python\r\nimport uvicorn\r\nfrom fastapi import Depends, FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\nclass Test1:\r\n    def __init__(self, t1) -> None:\r\n        self.t1 = t1\r\n\r\n    def __call__(self):\r\n        return self.t1\r\n\r\n\r\nclass Test2:\r\n    def __init__(self, t2) -> None:\r\n        self.t2 = t2\r\n\r\n    def __call__(self):\r\n        return Test1(t1=self.t2)()\r\n\r\n\r\n@app.get(\"/test/\")\r\ndef test_call(test: str = Depends(Test2(t2=\"test\"))):\r\n    return test\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True, debug=True)\r\n```\r\n\r\n", "source": "issue", "type": "how_to", "issue_number": 72}
{"instruction": "Automatically support HEAD method for all GET routes, as Starlette does", "input": "### First check\r\n\r\n* [x] I added a very descriptive title to this issue.\r\n* [x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [x] I searched the FastAPI documentation, with the integrated search.\r\n* [x] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [x] After submitting this, I commit to:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * Or, I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n### Example\r\n\r\nHere's a self-contained [minimal, reproducible, example](https://stackoverflow.com/help/minimal-reproducible-example) with my use case:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\nimport pytest\r\nfrom fastapi.testclient import TestClient\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n\r\nclient = TestClient(app)\r\n\r\ndef test_index_head():\r\n    response = client.head(\"/\")\r\n    assert response.status_code == 200\r\n```\r\n\r\n### Description\r\n\r\n* The above test fails because the HEAD request returns a 405.\r\n* This is counterintuitive.\r\n\r\n### The solution you would like\r\n\r\n* To better support the HTTP standard, all routes that handle GET methods should automatically handle HEAD methods, too.\r\n* This is similar to what Starlette's router already does: https://github.com/encode/starlette/issues/45\r\n* This should happen wi", "output": "encode/starlette#45 is only about static FileResponse. I don't know how a default should be set for a dynamic API.\n\nNot so, if you look at the related commit at https://github.com/encode/starlette/pull/132/files in `starlette/routing.py`, you can see Starlette adds `HEAD` methods automatically for every `Route` that supports `GET`, regardless of whether they are `FileResponse` or not.\r\n\r\nMany web frameworks do this by default too, e.g. Flask (https://flask.palletsprojects.com/en/1.1.x/quickstart/#http-methods) and Django. It makes sense to do that because a server should respond to an `HTTP HEAD` request as defined in the spec, see e.g.:\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD\r\n\r\n\"The HTTP HEAD method requests the headers that are returned if the specified resource would be requested with an HTTP GET method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.\"\r\n\r\nClients use this for cache invalidation. The server just needs to run the route method, respond with the headers but discard the response body. Ideally, FastAPI would automatically add an OPTIONS method handler, too. This would help make FastAPI a first class web framework.\r\n\r\nThis is safe even for a dynamic API, because to follow REST principles, HTTP GET routes should always be idempotent and have no side-effects (as should HEAD, PUT, DELETE, OPTIONS and TRACE). Only HTTP POSTs are allowed to have side effects (see https://tools.ietf.org/html/rfc7231#section-4.2.2).\r\n\r\nThis behavior could be controlled by a flag defaulting to true.\n\nThanks @matthewlloyd for the very clear argument and especially for the self-contained example, that helps a lot.\r\n\r\nIndeed, here in the spec: https://tools.ietf.org/html/rfc7231#section-4.3.2 it says:\r\n\r\n> The server SHOULD send the same header fields in response to a HEAD request as it would have sent if the request had been a GET [...]\r\n\r\nAnd the OpenAPI spec doesn't say anything contradicting it, so FastAPI should support it.\r\n\r\nI think ideally, it should handle HEAD requests automatically for GET requests, without adding them to the OpenAPI schema. I think HEAD operations should be added to OpenAPI only when explicitly declared in the code (ideally).\r\n\r\n---\r\n\r\nThanks @victorphoenix3 for working on this! Let me know if you need any help with it.", "source": "issue", "type": "how_to", "issue_number": 64}
{"instruction": "How to send 204 response?", "input": "I tried to send 204 response in delete method\r\n\r\nExample handler\r\n```\r\n@router.delete('/{order_id}/', tags=['smart order'], status_code=204)\r\nasync def cancel_smart_order(\r\n        session: Session = Depends(get_session),\r\n        order_id: UUID = Path(...)\r\n):\r\n    order = await session.get(order_id)\r\n\r\n    if order.status != OrderStatus.open:\r\n        raise HTTPException(409, f'Order have status: {order.status}')\r\n\r\n    order.status = OrderStatus.canceled\r\n\r\n    await session.commit_only(order)\r\n```\r\n\r\nBut got error `h11._util.LocalProtocolError: Too much data for declared Content-Length`. Seems framefork convert None to null but set content length 0.", "output": "Not sure why the content-length is wrong; that may be a bug. But if you want to return an actual empty response, just set `response_class=Response` in the route decorator (the default is `JSONResponse`, which converts `None` to `\"null\"` as you have noticed).\n\nIt is a bug. I found that if `(event.status_code in (204, or request_method == b\" or (request_method == b\" and 200 <= event.status_code < 300))` than content length set to 0, but by defualt if return None then framevork try to conver None to json and got (`null`(len 4)). Need to add check on status code and try to convert only if the expression above is False.\n\n@heckad \r\nCould you share where this check is performed in the code?\r\n\r\nI don't *necessarily* think it's a bug for a `JSONResponse` to convert `None` to `\"null\"`, regardless of the status code you return; it's up to you to specify that the response class should be `Response` and not `JSONResponse`. But it definitely is a bug if it manually sets the content length to 0 even when that's not the case.\r\n\r\nI personally think the most consistent solution would be to drop the special case for the 204 status code (at least for `JSONResponse`).\r\n\r\nIt could make sense to display some kind of warning if using a 204 response code with a `JSONResponse` though?", "source": "issue", "type": "how_to", "issue_number": 54}
{"instruction": "How can I pass the configuration in the app?", "input": "How can I pass the configuration in the app? Can I do it in some way like it was in Flask with app.config, or this framework manages it differently?", "output": "You will be able to pass anything you want to app.state I've starlette is\non 0.12.9\n\nLe jeu. 5 sept. 2019 Ã  5:14 PM, Artsiom Dolatau <notifications@github.com>\na Ã©crit :\n\n> How can I pass the configuration in the app? Can I do it in some simple\n> way like it was in Flask with app.config, or this framework doesn't support\n> even this?\n>\n> â€”\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/tiangolo/fastapi/issues/508?email_source=notifications&email_token=AAINSPVIGGYSLBWKF7TYFOLQIEO3PA5CNFSM4IT7DHBKYY3PNVWWK3TUL52HS4DFUVEXG43VMWVGG33NNVSW45C7NFSM4HJSGYQA>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAINSPQ5XZ73CSBHDJMJSPTQIEO3PANCNFSM4IT7DHBA>\n> .\n>\n\n\nI typically use a subclass of `pydantic.BaseSettings` so I can read config from the environment, then create an `lru_cache`d function that returns a config instance, then wherever I need access to a config setting I just call the `lru_cache`d function to get the config and read the setting off of it.\n\ni have the same question here - what is the equivalent of app.config in flask ? https://flask.palletsprojects.com/en/1.1.x/config/\r\n\r\nto specific, are there any convenience functions similar to\r\n```\r\napp.config.from_object('yourapplication.default_settings')\r\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\r\n```\r\nwe need to load different configurations based on production or staging environment.", "source": "issue", "type": "how_to", "issue_number": 48}
{"instruction": "Update docs include syntax for source examples", "input": "### Privileged issue\r\n\r\n- [X] I'm @tiangolo or he asked me directly to create an issue here.\r\n\r\n### Issue Content\r\n\r\nThis is a good first contribution. :nerd_face: \r\n\r\nThe code examples shown in the docs are actual Python files. They are even tested in CI, that's why you can always copy paste an example and it will always work, the example is tested.\r\n\r\nThe way those examples are included in the docs used a specific format. But now there's a new format available that is much simpler and easier to use than the previous one, in particular in complex cases, for example when there are examples in multiple versions of Python.\r\n\r\nBut not all the docs have the new format yet. The docs should use the new format to include examples. That is the task. :nerd_face: \r\n\r\n**It should be done as one PR per page updated.**\r\n\r\n## Simple Example\r\n\r\nBefore, the format was like:\r\n\r\n````markdown\r\n```Python hl_lines=\"3\"\r\n{!../../docs_src/first_steps/tutorial001.py!}\r\n```\r\n````\r\n\r\nNow the new format looks like:\r\n\r\n````markdown\r\n{* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n````\r\n\r\n* Instead of `{!` and `!}` it uses `{*` and `*}`\r\n* It no longer has a line above with:\r\n\r\n````markdown\r\n```Python\r\n````\r\n\r\n* And it no longer has a line below with:\r\n\r\n````markdown\r\n```\r\n````\r\n\r\n* The highlight is no longer a line with e.g. `hl_lines=\"3\"` (to highlight line 3), but instead in the same line there's a `hl[3]`.\r\n\r\nAn example PR: https://github.com/fastapi/fastapi/pull/12552\r\n\r\n## Multiple Python Versions\r\n\r\nThere are some cases where there are variants of the same example for multiple versions of Python, or for using `Annotated` or not.\r\n\r\nIn those cases, the current include examples have syntax for tabs, and notes saying `Annotated` should be preferred. For example:\r\n\r\n````markdown\r\n//// tab | Python 3.9+\r\n\r\n```Python hl_lines=\"4  8  12\"\r\n{!> ../../docs_src/security/tutorial006_an_py39.py!}\r\n```\r\n\r\n////\r\n\r\n//// tab | Python 3.8+\r\n\r\n```Python hl_lines=\"2  7  11\"\r\n{!> ../../docs_src/securit", "output": "Osis\r\n\r\nOn Sat, Oct 26, 2024, 6:37 PM SebastiÃ¡n RamÃ­rez ***@***.***>\r\nwrote:\r\n\r\n> Privileged issue\r\n>\r\n>    - I'm @tiangolo <https://github.com/tiangolo> or he asked me directly\r\n>    to create an issue here.\r\n>\r\n> Issue Content\r\n>\r\n> This is a good first contribution. ðŸ¤“\r\n>\r\n> The code examples shown in the docs are actual Python files. They are even\r\n> tested in CI, that's why you can always copy paste an example and it will\r\n> always work, the example is tested.\r\n>\r\n> The way those examples are included in the docs used a specific format.\r\n> But now there's a new format available that is much simpler and easier to\r\n> use than the previous one, in particular in complex cases, for example when\r\n> there are examples in multiple versions of Python.\r\n>\r\n> But not all the docs have the new format yet. The docs should use the new\r\n> format to include examples. That is the task. ðŸ¤“\r\n>\r\n> It should be done as one PR per page updated.\r\n> Simple Example\r\n>\r\n> Before, the format was like:\r\n>\r\n> ```Python hl_lines=\"3\"\r\n> {!../../docs_src/first_steps/tutorial001.py!}```\r\n>\r\n> Now the new format looks like:\r\n>\r\n> {* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n>\r\n>\r\n>    - Instead of {! and !} it uses {* and *}\r\n>    - It no longer has a line above with:\r\n>\r\n> ```Python\r\n>\r\n>\r\n>    - And it no longer has a line below with:\r\n>\r\n> ```\r\n>\r\n>\r\n>    - The highlight is no longer a line with e.g. hl_lines=\"3\" (to\r\n>    highlight line 3), but instead in the same line there's a hl[3].\r\n>\r\n> An example PR: #12552 <https://github.com/fastapi/fastapi/pull/12552>\r\n> Multiple Python Versions\r\n>\r\n> There are some cases where there are variants of the same example for\r\n> multiple versions of Python, or for using Annotated or not.\r\n>\r\n> In those cases, the current include examples have syntax for tabs, and\r\n> notes saying Annotated should be preferred. For example:\r\n>\r\n> //// tab | Python 3.9+\r\n> ```Python hl_lines=\"4  8  12\"\r\n> {!> ../../docs_src/security/tutorial006_an_py39.py!}```\r\n>\r\n> ////\r\n>\r\n> //// tab | Python 3.8+\r\n> ```Python hl_lines=\"2  7  11\"\r\n> {!> ../../docs_src/security/tutorial006_an.py!}```\r\n>\r\n> ////\r\n>\r\n> //// tab | Python 3.8+ non-Annotated\r\n>\r\n> /// tip\r\n>\r\n> Prefer to use the `Annotated` version if possible.\r\n>\r\n> ///\r\n> ```Python hl_lines=\"2  6  10\"\r\n> {!> ../../docs_src/security/tutorial006.py!}```\r\n>\r\n> ////\r\n>\r\n> In these cases, it should be updated to only include the first one (the\r\n> others will be included automatically ðŸ˜Ž ):\r\n>\r\n> {* ../../docs_src/security/tutorial006_an_py39.py hl[4,8,12] *}\r\n>\r\n>\r\n>    - The syntax for tabs is also removed, all the other variants are\r\n>    included automatically.\r\n>    - The highlight lines are included for that same first file, the\r\n>    fragment with hl_lines=\"4 8 12\" is replaced with hl[4,8,12]\r\n>\r\n> An example PR: #12553 <https://github.com/fastapi/fastapi/pull/12553>\r\n>\r\n> â€”\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/fastapi/fastapi/issues/12554>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/ABCOVL2FRNCDPALCW7LAZRLZ5OHY5AVCNFSM6AAAAABQUZLFL2VHI2DSMVQWIX3LMV43ASLTON2WKOZSGYYTKOBVGYYDINA>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n\n\nIeje\r\n\r\nOn Sat, Oct 26, 2024, 6:54 PM Rajendra Prasad K ***@***.***>\r\nwrote:\r\n\r\n> Osis\r\n>\r\n> On Sat, Oct 26, 2024, 6:37 PM SebastiÃ¡n RamÃ­rez ***@***.***>\r\n> wrote:\r\n>\r\n>> Privileged issue\r\n>>\r\n>>    - I'm @tiangolo <https://github.com/tiangolo> or he asked me directly\r\n>>    to create an issue here.\r\n>>\r\n>> Issue Content\r\n>>\r\n>> This is a good first contribution. ðŸ¤“\r\n>>\r\n>> The code examples shown in the docs are actual Python files. They are\r\n>> even tested in CI, that's why you can always copy paste an example and it\r\n>> will always work, the example is tested.\r\n>>\r\n>> The way those examples are included in the docs used a specific format.\r\n>> But now there's a new format available that is much simpler and easier to\r\n>> use than the previous one, in particular in complex cases, for example when\r\n>> there are examples in multiple versions of Python.\r\n>>\r\n>> But not all the docs have the new format yet. The docs should use the new\r\n>> format to include examples. That is the task. ðŸ¤“\r\n>>\r\n>> It should be done as one PR per page updated.\r\n>> Simple Example\r\n>>\r\n>> Before, the format was like:\r\n>>\r\n>> ```Python hl_lines=\"3\"\r\n>> {!../../docs_src/first_steps/tutorial001.py!}```\r\n>>\r\n>> Now the new format looks like:\r\n>>\r\n>> {* ../../docs_src/first_steps/tutorial001.py hl[3] *}\r\n>>\r\n>>\r\n>>    - Instead of {! and !} it uses {* and *}\r\n>>    - It no longer has a line above with:\r\n>>\r\n>> ```Python\r\n>>\r\n>>\r\n>>    - And it no longer has a line below with:\r\n>>\r\n>> ```\r\n>>\r\n>>\r\n>>    - The highlight is no longer a line with e.g. hl_lines=\"3\" (to\r\n>>    highlight line 3), but instead in the same line there's a hl[3].\r\n>>\r\n>> An example PR: #12552 <https://github.com/fastapi/fastapi/pull/12552>\r\n>> Multiple Python Versions\r\n>>\r\n>> The", "source": "issue", "type": "how_to", "issue_number": 42}
{"instruction": "how can i run scheduling tasks using fastapi's", "input": "**Description**\r\n\r\nHow can I [...]?\r\n\r\nIs it possible to [...]?\r\n\r\n**Additional context**\r\nAdd any other context or screenshots about the feature request here.", "output": "it's not strictly speaking a FastAPI question but here are some options, find what works best for you\r\n\r\nthe best without any doubt :grin: https://linux.die.net/man/5/crontab\r\n\r\nsome python tools > \r\nhttps://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html\r\nhttps://docs.python.org/3/library/sched.html\r\nhttps://github.com/dbader/schedule\r\nhttps://github.com/Bogdanp/dramatiq/tree/master/examples/scheduling\r\n\n\nyes those methods I know but it is not working with an async function\n\nhttps://github.com/aio-libs/aiojobs maybe ? never tried it", "source": "issue", "type": "how_to", "issue_number": 38}
{"instruction": "How to bridge Pydantic models with SQLAlchemy?", "input": "**Description**\r\n\r\nUp until database interaction is introduced, the tutorial for FastAPI uses pydantic models for everything, such as this example in [the sextion on Extra Models](https://fastapi.tiangolo.com/tutorial/extra-models/) :\r\n\r\n```python\r\nclass UserOut(BaseModel):\r\n    username: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n\r\n\r\nclass UserInDB(BaseModel):\r\n    username: str\r\n    hashed_password: str\r\n    email: EmailStr\r\n    full_name: str = None\r\n```\r\n\r\nThis alows for the \"database model\" to have private data which will not be exposed through the API. Later, in [the section on security](https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/), a similar trick is used, but this time using inheritance to stack the two models (which I find makes the return-casting used by some functions better encoded in the type system).\r\n\r\n```py\r\nclass User(BaseModel):\r\n    username: str\r\n    email: str = None\r\n    full_name: str = None\r\n    disabled: bool = None\r\n\r\n\r\nclass UserInDB(User):\r\n    hashed_password: str\r\n```\r\n\r\n```py\r\ndef get_db_user() -> UserInDB:\r\n    return UserInDB(\r\n        username=\"johndoe\", full_name=\"John Doe\",\r\n        email=\"johndoe@example.com\",\r\n        hashed_password=\"fakehashedsecret\",\r\n        disabled=False\r\n    )\r\n\r\ndef get_user() -> User:\r\n    return get_db_user()\r\n```\r\n\r\nHowever, when [proper databases are introduced](https://fastapi.tiangolo.com/tutorial/sql-databases/), those Pydantic models are dropped in favor of a single SQLAlchemy ORM model, with no effort to bridge the two parts. And while one could see this as the SQLAlchemy models completely superseding the Pydantic models, [the fullstack demo app](https://github.com/tiangolo/full-stack-fastapi-postgresql) appears to [actually use both](https://github.com/tiangolo/full-stack-fastapi-postgresql/blob/ecd634e49715bb57fdfeb35b9dba21a6e94cf012/%7B%7Bcookiecutter.project_slug%7D%7D/backend/app/app/api/api_v1/endpoints/login.py#L13-L16), so there appears to be value in attempt", "output": "From what I can tell, there is no problem using both pydantic models and SQLAlchemy models, and if you want to use sqlalchemy as your ORM you will *need* to use both.\r\n\r\nI've found this a little frustrating because, at least in my experience, it leads to lots of similarly-named objects and repetition of definitions, and frequent translation between the types depending on how you are using them. @tiangolo I would be interested if you have any suggestions for design patterns that would reduce the amount of \"translation\" code associated with having separate pydantic and sqlalchemy models.\r\n\r\nMore generally, I would be interested to hear if anyone has found a clean approach to bridging the gap between pydantic and a database, especially if it integrates nicely with an asynchronous database driver (I've been using ([encode/databases](https://github.com/encode/databases)), which only supports SQLAlchemy core,  not the ORM). In particular, it would be nice if I only had to create a single class for each conceptual model (I'd be okay with separate classes for pydantic and the orm as long as they could be derived from a common root).\r\n\r\nMy current approach has been to create a container class that holds references to the database table and the appropriate creation/in-db pydantic models (similar to UserCreate and UserInDB from the docs), and has a variety of generic classmethods for CRUD that make use of the creation/in-db types for input / return, but it still feels like a hack.\n\nHi @dmontagu , \r\n\r\nI am interested in your 'hack' ðŸ˜„ Could you share some code sample ?\r\n\r\nOn my side, I find it useful to split the models used for frontend interaction (Pydantic) from those used for the DB interaction and business logic (SQLAlchemy).\r\n\r\nI have therefore followed the scaffold from https://github.com/tiangolo/full-stack-fastapi-postgresql, with some repetition between models and db_models. But again, I am fine with it since it adresses different purpose. The point where repetition becomes to cumbersome is the crud layer, where you basically have to copy-paste again and again the same pieces of code. I have made a PR to try to reduce this friction: https://github.com/tiangolo/full-stack-fastapi-postgresql/pull/23\r\n\r\nI am curious to see how this goes along with @dmontagu approach...\r\n\r\nBy the way, fastapi takes care to translate SQLAlchemy models to pydantic ones on the api endpoint layer, with two limitations I have found so far on JSON fields (see https://github.com/tiangolo/fastapi/issues/211 for details) and Enum fields in a specific use case (see https://github.com/tiangolo/fastapi/issues/196)\n\nSo, Pydantic and SQLAlchemy are separated. Pydantic is used for documentation, validation, and data serialization. SQLAlchemy for SQL ORM stuff.\r\n\r\nFastAPI is not coupled with any DB, so, SQLAlchemy is optional.\r\n\r\nIf you don't care about having documentation, validation, and serialization, you don't need to use Pydantic, you could return SQLAlchemy models directly. They would be converted to JSON in a \"best-effort\" way.\r\n\r\nIf you want both, for now, you have to write both.\r\n\r\nI agree I don't like the duplication of properties in classes. But there's still no way to automatically generate one from the other.\r\n\r\nThat's a good candidate for a third-party package, that generates Pydantic models from SQLAlchemy models (or other ORMs) automatically. But it doesn't exist yet. There are some attempts at doing [something similar](https://github.com/awesometoolbox/ormantic) but I don't know a complete solution yet. Hopefully, someone will build it (or I'll do it later).\r\n\r\n---\r\n\r\nFor now, I'll take it as a request to update the docs clarifying the use of both Pydantic and SQLAlchemy at the same time.", "source": "issue", "type": "how_to", "issue_number": 36}
{"instruction": "How to do flexibly use nested pydantic models for sqlalchemy ORM", "input": "### First check\r\n\r\n* [x ] I added a very descriptive title to this issue.\r\n* [ x] I used the GitHub search to find a similar issue and didn't find it.\r\n* [ x] I searched the FastAPI documentation, with the integrated search.\r\n* [x ] I already searched in Google \"How to X in FastAPI\" and didn't find any information.\r\n* [ x] I already read and followed all the tutorial in the docs and didn't find an answer.\r\n* [ x] I already checked if it is not related to FastAPI but to [Pydantic](https://github.com/samuelcolvin/pydantic).\r\n* [x ] I already checked if it is not related to FastAPI but to [Swagger UI](https://github.com/swagger-api/swagger-ui).\r\n* [ x] I already checked if it is not related to FastAPI but to [ReDoc](https://github.com/Redocly/redoc).\r\n* [ x] After submitting this, I commit to one of:\r\n    * Read open issues with questions until I find 2 issues where I can help someone and add a comment to help there.\r\n    * I already hit the \"watch\" button in this repository to receive notifications and I commit to help at least 2 people that ask questions in the future.\r\n    * Implement a Pull Request for a confirmed bug.\r\n\r\n<!-- \r\n\r\nI'm asking all this because answering questions and solving problems in GitHub issues consumes a lot of time. I end up not being able to add new features, fix bugs, review Pull Requests, etc. as fast as I wish because I have to spend too much time handling issues.\r\n\r\nAll that, on top of all the incredible help provided by a bunch of community members that give a lot of their time to come here and help others.\r\n\r\nThat's a lot of work they are doing, but if more FastAPI users came to help others like them just a little bit more, it would be much less effort for them (and you and me ðŸ˜…).\r\n\r\n-->\r\n\r\n### Example\r\n\r\n```python\r\nfrom fastapi import Depends, FastAPI, HTTPException, Body, Request\r\nfrom sqlalchemy import create_engine, Boolean, Column, ForeignKey, Integer, String\r\nfrom sqlalchemy.ext.declarative import declarative_base\r\nfrom sqlalchem", "output": "Have you tried @tiangolo's [Pydantic SQLAlchemy](https://github.com/tiangolo/pydantic-sqlalchemy) ?\n\nThank you for the contribution, but your proposal is for converting sqlalchemy model to pydantic, I need a way to convert a nested model from pydantic to sqlalchemy.\n\nI am thinking about a recursive function to do what I want. I currently need an external \"maping\" dict that translates the pydantic sub class to the related sqlalchemy class by their name. Would be helpful if someone could provide an example of a recursive function for two dicts. Added difficulty that sub model could be lists or direct keys.", "source": "issue", "type": "how_to", "issue_number": 32}
{"instruction": "Very poor performance does not align with marketing", "input": "I wanted to check the temperature of this project and so I ran a quick, very simple, benchmark with `wrk` and the default example:\r\n\r\n```Python\r\nfrom fastapi import FastAPI\r\n\r\napp = FastAPI()\r\n\r\n\r\n@app.get(\"/\")\r\ndef read_root():\r\n    return {\"Hello\": \"World\"}\r\n```\r\n\r\nEverything default with wrk, regular Ubuntu Linux, Python 3.8.2, latest FastAPI as of now.\r\n\r\n> wrk http://localhost:8000\r\n\r\nUvicorn with logging disabled (obviously), as per the README:\r\n\r\n> python3 -m uvicorn fast:app --log-level critical\r\n\r\nI get very poor performance, way worse than Node.js and really, really far from Golang:\r\n\r\n```\r\nRunning 10s test @ http://localhost:8000\r\n  2 threads and 10 connections\r\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\r\n    Latency     1.83ms  365.59us   3.90ms   75.34%\r\n    Req/Sec     2.74k   116.21     2.98k    65.00%\r\n  54447 requests in 10.00s, 7.37MB read\r\nRequests/sec:   5442.89\r\nTransfer/sec:    754.78KB\r\n```\r\n\r\nThis machine can do 400k req/sec on one single thread using other software, so 5k is not at all fast. Even Node.js does 20-30k on this machine, so this does not align at all with the README:\r\n\r\n```\r\nThe key features are:\r\n\r\nFast: Very high performance, on par with NodeJS and Go (thanks to Starlette and Pydantic). One of the fastest Python frameworks available.\r\n```\r\n\r\nWhere do you post benchmarks? How did you come to that conclusion? I cannot see you have posted any benchmarks at all?\r\n\r\nPlease fix marketing, it is not at all true.", "output": "If you [read README further](https://github.com/tiangolo/fastapi/blob/master/README.md#performance)...\r\n\r\n> Independent TechEmpower benchmarks show **FastAPI** applications running under Uvicorn as <a href=\"https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7\" class=\"external-link\" target=\"_blank\">one of the fastest Python frameworks available</a>, only below Starlette and Uvicorn themselves (used internally by FastAPI). (*)\r\n>\r\n> To understand more about it, see the section <a href=\"https://fastapi.tiangolo.com/benchmarks/\" class=\"internal-link\" target=\"_blank\">Benchmarks</a>.\n\nOkay, so taking the source **you** gave me (entirely disregarding my own test), I can read the following:\r\n\r\n\r\n268 | fastapi | 159,445 | 2.2%\r\n-- | -- | -- | --\r\n\r\n199 | uvicorn | 382,930 | 5.2%\r\n-- | -- | -- | --\r\n\r\n124 | nodejs | 884,444 | 12.0%\r\n-- | -- | -- | --\r\n\r\n27 | fasthttp | 5,962,266 | 81.2%\r\n-- | -- | -- | --\r\n\r\nWhich is in very stark contrast with the README:\r\n\r\n> Very high performance, on par with NodeJS and Go\r\n\r\nhttps://www.collinsdictionary.com/dictionary/english/on-a-par-with\r\n\r\n2.2% is not \"on par with\" 12%. It's like comparing wine with light beer - they are entirely disjoint, you cannot possibly claim light beer gets you as hammered as wine?\r\n\r\nAnd the golang thing.... jeeeez!\n\n@alexhultman Your point might be valid, but I think you might be oversimplifying your tests here. Benchmarks are a tricky thing, but it's important to know what is it that you are comparing.\r\n\r\nFastApi is a Web application framework that provides quite a bit over just an application server.\r\n\r\nSo if you are comparing FastAPI, say, to NodeJs, then the test should be done over a Web Application Framework as NestJS or similar.\r\n\r\nSame thing with Golang. the comparison should be against Revel or something like this. \r\n\r\nIn @tiangolo's documentation on benchmarks you can read:\r\n\r\n> If you didn't use FastAPI and used Starlette directly (or another tool, like Sanic, Flask, Responder, etc) you would have to implement all the data validation and serialization yourself. So, your final application would still have the same overhead as if it was built using FastAPI. And in many cases, this data validation and serialization is the biggest amount of code written in applications.\r\n\r\nhttps://fastapi.tiangolo.com/benchmarks/\r\n\r\nI believe that when the developers say:\r\n\r\n> Very high performance, on par with NodeJS and Go\r\n\r\nThey mean a full application on Golang or NodeJS (on some framework) vs a Full application on FastAPI. ", "source": "issue", "type": "how_to", "issue_number": 25}
{"instruction": "Provide timing data for things FastAPI does outside of user code", "input": "**Is your feature request related to a problem? Please describe.**\r\nI currently find myself using FastAPI as an API frontend for a database running queries of varying levels of complexity that usually return fairly large quantities of data. The problem I have is that, when attempting to figure out why an API request is taking time to respond, there's a lot going on outside of what fencing the code inside your route with the usual `time_start = time.time()`, `time_delta = time.time() - time_start` won't tell you.\r\n\r\nIn your average FastAPI application, there's 4 main causes for slowdowns:\r\n* Endpoint code running (app)\r\n* Waiting for the database (io)\r\n* Data validation (pydantic)\r\n* Data serialization (json/ujson)\r\n\r\nOf those 4, only the first two are actually part of the user code, the other two are handled behind the scenes by FastAPI. If I'm testing a route that's returning 50MBs of JSON (for whatever reason), it's actually rather tricky to determine whether switching from `json` to `ujson` or `orjson` will have any performance benefit or if the slowdown is coming from Pydantic choking on the sheer amount of data being fed to it or the database being slow.\r\n\r\n**Describe the solution you'd like**\r\nGiven FastAPI is performing operations outside of what the user can observe or measure, it should probably expose timing data for those things in some way (especially validation and serialization, since I doubt routing is going to factor a lot in the processing time). I don't know how the implementation should go, though, given any middleware is only going to receive a Starlette `Response` object and FastAPI probably shouldn't be doing this sort of thing automatically anymore than it does with CORS. The `Response` object could probably be extended in some way to contain some sort of `timing` dict, though that's sure to cause all sorts of compatibility issues, so I don't know whether that can be done without some upstream work with Starlette.\r\n\r\n**Describe alternatives yo", "output": "A couple tangential profiling-related notes that may be of interest to anyone working with \"50MBs of JSON\"-sized payloads:\r\n<details>\r\n    <summary>Click to expand</summary>\r\n\r\n* Serialization may *also* involve two (potentially very costly!) steps: 1) if specifying a `response_model`, where the returned data is parsed into the `response_model`, and 2) in all cases unless you return a `Response` directly, where `fastapi.encoders.jsonable_encoder` is used to convert your output to json.\r\n    * For payloads with long lists or dicts with many keys this function call is not cheap, and unless you return a `Response` or one of its subclasses from your endpoint, in most cases, the cost of `jsonable_encoder` will probably dwarf the call to `json.dumps` or faster alternatives from other packages.\r\n* For faster creation of pydantic model instances, consider using `BaseModel.construct` if you *know* the input data doesn't require parsing (e.g., whenever you perform the instantiation yourself in a type-safe way, rather than relying on fastapi's parsing machinery).\r\n    * I profiled this method at ~30-40x faster than calls to `BaseModel.__init__`, even for relatively small payloads.\r\n    * The API is a little awkward in pydantic v0.32.2 since you have to pass the values as a dict (and have to specify the fields set), but starting in v1 it has the same API as the `__init__` calls and is even type-checked by the pydantic mypy plugin (a good reason for FastAPI to update to pydantic v1 as soon as possible!).\r\n</details>\r\n\r\n-----\r\n\r\nAddressing the main point brought up in this issue, I think it might be worth looking into [yappi](https://github.com/sumerc/yappi) -- if you look at the docs for the [get_func_stats](https://github.com/sumerc/yappi/blob/master/doc/api.md#get_func_statsfilternone) function and the [YFuncStat](https://github.com/sumerc/yappi/blob/master/doc/api.md#yfuncstat) class, it looks like it should be relatively easy to package up the profiling results inside an ASGI middleware. (Also, for what it's worth, it has built-in support in PyCharm.)\r\n\r\nI'm not very familiar with the `Server-Timing` header, but based on a quick skim of the linked docs, it seems that such a yappi ASGI middleware could return Server-Timing headers for each of its YFuncStat instances, presumably with some (configurable) filtering and formatting. (Obviously it could also just log the results to the console.)\r\n\r\n\n\n> A couple tangential profiling-related notes that may be of interest to anyone working with \"50MBs of JSON\"-sized payloads:\r\n\r\nAh, that's interesting, I'd usually just build my own `RawJSONResponse` class and handle json conversion on my own so I could bypass Pydantic entirely, but this is certainly much cleaner if you trust your input source.\r\n\r\n> Addressing the main point brought up in this issue, I think it might be worth looking into [yappi](https://github.com/sumerc/yappi) -- if you look at the docs for the [get_func_stats](https://github.com/sumerc/yappi/blob/master/doc/api.md#get_func_statsfilternone) function and the [YFuncStat](https://github.com/sumerc/yappi/blob/master/doc/api.md#yfuncstat) class, it looks like it should be relatively easy to package up the profiling results inside an ASGI middleware. (Also, for what it's worth, it has built-in support in PyCharm.)\r\n> \r\n> I'm not very familiar with the `Server-Timing` header, but based on a quick skim of the linked docs, it seems that such a yappi ASGI middleware could return Server-Timing headers for each of its YFuncStat instances, presumably with some (configurable) filtering and formatting. (Obviously it could also just log the results to the console.)\r\n\r\nThanks for pointing out yappi. I've tried the middleware solution with it, and while it's working well enough, it runs into the issue where, since profiling is global, if a route is called while another one is running, the profiler gets confused and the resulting profiling data will be incorrect or missing.\r\n\r\n```py\r\nfrom starlette.middleware.base import BaseHTTPMiddleware\r\nfrom starlette.responses import Response\r\nfrom starlette.requests import Request\r\n\r\nimport fastapi\r\nimport json\r\nimport sqlalchemy\r\n\r\nimport yappi\r\n\r\nclass BenchMiddleware(BaseHTTPMiddleware):\r\n    async def dispatch(self, request: Request, call_next) -> Response:\r\n        yappi.start()\r\n        response = await call_next(request)\r\n        yappi.stop()\r\n\r\n        #yappi.get_func_stats().sort('ttot', sort_order=\"desc\").print_all() # All time\r\n\r\n        db_exec_time = yappi.get_func_stats(dict(name=sqlalchemy.engine.base.Engine.execute.__qualname__))\r\n        #db_fetch_time = yappi.get_func_stats(dict(name=sqlalchemy.engine.result.ResultProxy.fetchone.__qualname__))\r\n        pydantic_time = yappi.get_func_stats(dict(name=fastapi.routing.serialize_response.__qualname__))\r\n        render_time = yappi.get_func_stats(dict(name=response.render.__qualname__))\r\n\r\n        server_timing = []\r\n\r\n        if not db_exec_time.empty():\r\n            server_", "source": "issue", "type": "how_to", "issue_number": 13}
